[
  {
    "id": "EXP-MS-0001",
    "component": "Creating Application Networks – API-led Layers",
    "difficulty": "Extreme",
    "question": "An Experience API orchestrates calls to three System APIs and applies business rules, while a Process API already exists for the same capability. What architectural violation has occurred?",
    "options": {
      "A": "Overuse of System APIs",
      "B": "Bypassing the Process API layer",
      "C": "Incorrect API versioning",
      "D": "Improper error mapping"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business orchestration belongs in Process APIs. Bypassing them violates API-led layering.",
      "incorrect": {
        "A": "System APIs can be reused appropriately.",
        "C": "Versioning is unrelated here.",
        "D": "Error handling is not the core issue."
      }
    }
  },
  {
    "id": "EXP-MS-0002",
    "component": "Creating Application Networks – Loose Coupling",
    "difficulty": "Extreme",
    "question": "A Process API response change immediately breaks multiple Experience APIs. Which principle failed?",
    "options": {
      "A": "Statelessness",
      "B": "Loose coupling",
      "C": "Protocol abstraction",
      "D": "API discoverability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Breaking dependent APIs indicates tight coupling between layers.",
      "incorrect": {
        "A": "Statelessness concerns session state.",
        "C": "Protocol abstraction is transport-related.",
        "D": "Discoverability is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0003",
    "component": "Creating Application Networks – C4E Operating Model",
    "difficulty": "Extreme",
    "question": "Which C4E responsibility ensures APIs adhere to enterprise standards before deployment?",
    "options": {
      "A": "API Consumers",
      "B": "API Product Owners",
      "C": "Platform Team",
      "D": "Runtime Operators"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The Platform Team enforces standards, tooling, and governance.",
      "incorrect": {
        "A": "Consumers only use APIs.",
        "B": "Product Owners manage lifecycle.",
        "D": "Operators manage runtime."
      }
    }
  },
  {
    "id": "EXP-MS-0004",
    "component": "Creating Application Networks – System API Scope",
    "difficulty": "Extreme",
    "question": "A System API embeds business validation logic reused across channels. What long-term risk does this introduce?",
    "options": {
      "A": "Improved reuse",
      "B": "Business logic duplication",
      "C": "Lower latency",
      "D": "Simpler Experience APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business logic belongs in Process APIs; placing it in System APIs causes duplication.",
      "incorrect": {
        "A": "Reuse does not justify misplaced logic.",
        "C": "Latency is not guaranteed.",
        "D": "Experience APIs become constrained."
      }
    }
  },
  {
    "id": "EXP-MS-0005",
    "component": "Creating Application Networks – Experience API Responsibility",
    "difficulty": "Extreme",
    "question": "Which responsibility uniquely belongs to Experience APIs?",
    "options": {
      "A": "Backend protocol abstraction",
      "B": "Business orchestration",
      "C": "Channel-specific transformation",
      "D": "Database interaction"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Experience APIs tailor responses for specific channels.",
      "incorrect": {
        "A": "System API responsibility.",
        "B": "Process API responsibility.",
        "D": "Handled by System APIs."
      }
    }
  },
  {
    "id": "EXP-MS-0006",
    "component": "Creating Application Networks – Process API Role",
    "difficulty": "Extreme",
    "question": "A Process API aggregates customer, order, and payment data. Which architectural responsibility is being fulfilled?",
    "options": {
      "A": "Channel optimization",
      "B": "Business orchestration",
      "C": "Backend exposure",
      "D": "Policy enforcement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs orchestrate and combine business data.",
      "incorrect": {
        "A": "Belongs to Experience APIs.",
        "C": "Backends remain abstracted.",
        "D": "Policies are gateway-level."
      }
    }
  },
  {
    "id": "EXP-MS-0007",
    "component": "Creating Application Networks – Versioning Strategy",
    "difficulty": "Extreme",
    "question": "Which change requires a major version increment?",
    "options": {
      "A": "Adding an optional response field",
      "B": "Removing a response attribute",
      "C": "Performance improvement",
      "D": "Adding logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing response attributes breaks existing consumers.",
      "incorrect": {
        "A": "Optional fields are backward-compatible.",
        "C": "Performance changes are non-breaking.",
        "D": "Logging is internal."
      }
    }
  },
  {
    "id": "EXP-MS-0008",
    "component": "Creating Application Networks – Error Abstraction",
    "difficulty": "Extreme",
    "question": "Which layer should translate technical backend errors into business-friendly errors?",
    "options": {
      "A": "Experience API",
      "B": "Process API",
      "C": "System API",
      "D": "Client application"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs abstract technical failures into business semantics.",
      "incorrect": {
        "A": "Experience APIs focus on presentation.",
        "C": "System APIs expose backend behavior.",
        "D": "Clients should not handle backend errors."
      }
    }
  },
  {
    "id": "EXP-MS-0009",
    "component": "Creating Application Networks – Channel Decoupling",
    "difficulty": "Extreme",
    "question": "A new mobile channel is introduced without backend changes. Which layer absorbs most change?",
    "options": {
      "A": "System API",
      "B": "Process API",
      "C": "Experience API",
      "D": "API Gateway"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Experience APIs are channel-specific and change frequently.",
      "incorrect": {
        "A": "System APIs remain stable.",
        "B": "Process APIs represent business logic.",
        "D": "Gateways manage policies."
      }
    }
  },
  {
    "id": "EXP-MS-0010",
    "component": "Creating Application Networks – Reuse Strategy",
    "difficulty": "Extreme",
    "question": "Which artifact best enables discovery and reuse of APIs?",
    "options": {
      "A": "Runtime Manager",
      "B": "Anypoint Exchange",
      "C": "API Gateway",
      "D": "CloudHub logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exchange is the central hub for reusable API assets.",
      "incorrect": {
        "A": "Runtime Manager handles deployments.",
        "C": "Gateway enforces policies.",
        "D": "Logs are operational."
      }
    }
  },

  {
    "id": "EXP-MS-0011",
    "component": "Creating Application Networks – Stability Zones",
    "difficulty": "Extreme",
    "question": "Which API layer should be most stable over time?",
    "options": {
      "A": "Experience API",
      "B": "Process API",
      "C": "System API",
      "D": "All equally"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "System APIs abstract backend systems and should change least.",
      "incorrect": {
        "A": "Experience APIs evolve with channels.",
        "B": "Process APIs evolve with business.",
        "D": "Stability differs by layer."
      }
    }
  },
  {
    "id": "EXP-MS-0012",
    "component": "Creating Application Networks – API Governance",
    "difficulty": "Extreme",
    "question": "Which practice most effectively prevents API sprawl?",
    "options": {
      "A": "Frequent deployments",
      "B": "Reuse-first enforcement via Exchange",
      "C": "More Experience APIs",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse-first governance prevents duplicate APIs.",
      "incorrect": {
        "A": "Deployments do not prevent sprawl.",
        "C": "More APIs increase sprawl.",
        "D": "Hard-coding worsens governance."
      }
    }
  },
  {
    "id": "EXP-MS-0013",
    "component": "Creating Application Networks – Backend Abstraction",
    "difficulty": "Extreme",
    "question": "A database schema change does not impact API consumers. What enabled this?",
    "options": {
      "A": "Experience API formatting",
      "B": "Process API orchestration",
      "C": "System API abstraction",
      "D": "API Gateway policies"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "System APIs abstract backend implementation details.",
      "incorrect": {
        "A": "Experience APIs do not abstract backends.",
        "B": "Process APIs assume stable System APIs.",
        "D": "Policies do not abstract schemas."
      }
    }
  },
  {
    "id": "EXP-MS-0014",
    "component": "Creating Application Networks – API Ownership",
    "difficulty": "Extreme",
    "question": "Who defines API lifecycle, SLAs, and roadmap in a C4E model?",
    "options": {
      "A": "API Consumers",
      "B": "Platform Team",
      "C": "API Product Owner",
      "D": "Runtime Operator"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "API Product Owners manage lifecycle and business value.",
      "incorrect": {
        "A": "Consumers do not own APIs.",
        "B": "Platform teams enable governance.",
        "D": "Operators manage runtime only."
      }
    }
  },
  {
    "id": "EXP-MS-0015",
    "component": "Creating Application Networks – Error Containment",
    "difficulty": "Extreme",
    "question": "Which layer should prevent backend outages from directly impacting clients?",
    "options": {
      "A": "Experience API",
      "B": "Process API",
      "C": "System API",
      "D": "Client application"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs act as shock absorbers between backends and channels.",
      "incorrect": {
        "A": "Experience APIs should remain lightweight.",
        "C": "System APIs expose backend behavior.",
        "D": "Clients should not handle outages."
      }
    }
  },
  {
    "id": "EXP-MS-0016",
    "component": "Creating Application Networks – API Evolution",
    "difficulty": "Extreme",
    "question": "What is the safest way to introduce a breaking API change?",
    "options": {
      "A": "Silent deployment",
      "B": "Major version with parallel support",
      "C": "Immediate replacement",
      "D": "Policy-based override"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parallel major versions allow safe consumer migration.",
      "incorrect": {
        "A": "Silent changes break consumers.",
        "C": "Immediate replacement causes outages.",
        "D": "Policies cannot change contracts."
      }
    }
  },
  {
    "id": "EXP-MS-0017",
    "component": "Creating Application Networks – Metrics",
    "difficulty": "Extreme",
    "question": "Which metric best reflects a healthy application network?",
    "options": {
      "A": "CPU utilization",
      "B": "API reuse rate",
      "C": "Deployment frequency",
      "D": "Worker count"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High reuse indicates effective abstraction and governance.",
      "incorrect": {
        "A": "CPU is operational.",
        "C": "Deployment is delivery-focused.",
        "D": "Worker count is infrastructure."
      }
    }
  },
  {
    "id": "EXP-MS-0018",
    "component": "Creating Application Networks – Long-running Operations",
    "difficulty": "Extreme",
    "question": "Why should long-running business processes avoid synchronous execution?",
    "options": {
      "A": "Higher cost",
      "B": "Thread exhaustion",
      "C": "Security exposure",
      "D": "Policy violations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Synchronous long-running flows exhaust threads and reduce scalability.",
      "incorrect": {
        "A": "Cost is secondary.",
        "C": "Security is unrelated.",
        "D": "Policies do not address threading."
      }
    }
  },
  {
    "id": "EXP-MS-0019",
    "component": "Creating Application Networks – API Discoverability",
    "difficulty": "Extreme",
    "question": "What enables teams to find existing APIs before building new ones?",
    "options": {
      "A": "Runtime logs",
      "B": "Anypoint Exchange",
      "C": "API Gateway",
      "D": "CloudHub"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exchange is the discovery and reuse hub.",
      "incorrect": {
        "A": "Logs are operational.",
        "C": "Gateways enforce policies.",
        "D": "CloudHub hosts runtimes."
      }
    }
  },
  {
    "id": "EXP-MS-0020",
    "component": "Creating Application Networks – Boundary Enforcement",
    "difficulty": "Extreme",
    "question": "Which change should always trigger a consumer impact analysis?",
    "options": {
      "A": "Internal refactoring",
      "B": "Removing a request or response field",
      "C": "Logging enhancement",
      "D": "Performance tuning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing fields breaks contracts and impacts consumers.",
      "incorrect": {
        "A": "Internal changes are safe.",
        "C": "Logging is non-functional.",
        "D": "Performance tuning is non-breaking."
      }
    }
  },
  {
    "id": "EXP-MS-0021",
    "component": "Creating Application Networks – Experience API Anti-patterns",
    "difficulty": "Extreme",
    "question": "An Experience API exposes database primary keys directly to client applications. What architectural risk does this introduce?",
    "options": {
      "A": "Reduced performance",
      "B": "Tight coupling to backend implementation",
      "C": "Increased payload size",
      "D": "Policy enforcement failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exposing internal identifiers couples clients to backend implementation details.",
      "incorrect": {
        "A": "Performance impact is not primary.",
        "C": "Payload size is secondary.",
        "D": "Policies do not address identifiers."
      }
    }
  },
  {
    "id": "EXP-MS-0022",
    "component": "Creating Application Networks – Process API Granularity",
    "difficulty": "Extreme",
    "question": "A Process API grows continuously and serves unrelated business capabilities. What architectural smell does this indicate?",
    "options": {
      "A": "High reuse",
      "B": "God Process API",
      "C": "Improper Experience API design",
      "D": "System API instability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Overloaded Process APIs become monolithic and hard to evolve.",
      "incorrect": {
        "A": "Reuse does not justify unrelated responsibilities.",
        "C": "Experience APIs are not the root cause.",
        "D": "System APIs are not involved."
      }
    }
  },
  {
    "id": "EXP-MS-0023",
    "component": "Creating Application Networks – API Stability Zones",
    "difficulty": "Extreme",
    "question": "Which API layer should tolerate the highest frequency of change?",
    "options": {
      "A": "System API",
      "B": "Process API",
      "C": "Experience API",
      "D": "API Gateway"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Experience APIs evolve rapidly to meet channel-specific needs.",
      "incorrect": {
        "A": "System APIs should be most stable.",
        "B": "Process APIs change with business evolution.",
        "D": "Gateways manage policies, not business logic."
      }
    }
  },
  {
    "id": "EXP-MS-0024",
    "component": "Creating Application Networks – Error Propagation",
    "difficulty": "Extreme",
    "question": "A System API returns HTTP 500. The Process API converts it to HTTP 200 with a business error object. What principle is applied?",
    "options": {
      "A": "Error masking",
      "B": "Business abstraction",
      "C": "Protocol translation",
      "D": "Policy enforcement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs abstract technical errors into business-level responses.",
      "incorrect": {
        "A": "Masking implies hiding without meaning.",
        "C": "Protocol remains HTTP.",
        "D": "Policies are not involved."
      }
    }
  },
  {
    "id": "EXP-MS-0025",
    "component": "Creating Application Networks – C4E Governance",
    "difficulty": "Extreme",
    "question": "Which practice most effectively prevents teams from building duplicate APIs?",
    "options": {
      "A": "Post-deployment audits",
      "B": "Reuse-first mandate with Exchange discovery",
      "C": "Increased runtime monitoring",
      "D": "Higher worker sizing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enforcing reuse at design time prevents duplication.",
      "incorrect": {
        "A": "Audits are reactive.",
        "C": "Monitoring does not prevent duplication.",
        "D": "Worker sizing is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0026",
    "component": "Creating Application Networks – API-led Contracts",
    "difficulty": "Extreme",
    "question": "A Process API changes a response field name but keeps the same semantic meaning. Consumers break. What was underestimated?",
    "options": {
      "A": "Business logic complexity",
      "B": "Contract rigidity",
      "C": "Payload size",
      "D": "Policy compatibility"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Even semantic-preserving changes break strict API contracts.",
      "incorrect": {
        "A": "Logic may remain unchanged.",
        "C": "Payload size is irrelevant.",
        "D": "Policies do not change payloads."
      }
    }
  },
  {
    "id": "EXP-MS-0027",
    "component": "Creating Application Networks – System API Exposure",
    "difficulty": "Extreme",
    "question": "Why should System APIs rarely be exposed directly to external consumers?",
    "options": {
      "A": "They are slow",
      "B": "They expose backend-specific semantics",
      "C": "They lack security support",
      "D": "They are unstable"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs are designed to abstract backend details, not expose them.",
      "incorrect": {
        "A": "Performance varies by implementation.",
        "C": "Security can be applied.",
        "D": "Instability is not inherent."
      }
    }
  },
  {
    "id": "EXP-MS-0028",
    "component": "Creating Application Networks – API Ownership",
    "difficulty": "Extreme",
    "question": "An API without a clear owner begins to accumulate inconsistent changes. What governance gap does this reflect?",
    "options": {
      "A": "Lack of runtime visibility",
      "B": "Missing accountability",
      "C": "Improper versioning strategy",
      "D": "Insufficient documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without ownership, accountability and consistency degrade.",
      "incorrect": {
        "A": "Visibility does not enforce decisions.",
        "C": "Versioning does not replace ownership.",
        "D": "Documentation is secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0029",
    "component": "Creating Application Networks – Process API Responsibilities",
    "difficulty": "Extreme",
    "question": "Which responsibility should never belong to a Process API?",
    "options": {
      "A": "Business rule orchestration",
      "B": "Aggregating multiple System APIs",
      "C": "Channel-specific payload shaping",
      "D": "Business error translation"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Channel-specific shaping belongs in Experience APIs.",
      "incorrect": {
        "A": "This is a core Process API role.",
        "B": "Aggregation is expected.",
        "D": "Error translation is appropriate."
      }
    }
  },
  {
    "id": "EXP-MS-0030",
    "component": "Creating Application Networks – API Scalability",
    "difficulty": "Extreme",
    "question": "A Process API performs synchronous orchestration across five slow backends. What is the most likely runtime impact?",
    "options": {
      "A": "Higher throughput",
      "B": "Thread exhaustion under load",
      "C": "Improved consistency",
      "D": "Lower memory usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blocking orchestration reduces available threads and scalability.",
      "incorrect": {
        "A": "Throughput decreases.",
        "C": "Consistency is unrelated.",
        "D": "Memory usage may increase."
      }
    }
  },

  {
    "id": "EXP-MS-0031",
    "component": "Creating Application Networks – API Reuse Signals",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates a reusable API design?",
    "options": {
      "A": "High request volume",
      "B": "Consumption by multiple unrelated teams",
      "C": "Large payloads",
      "D": "Frequent deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cross-team adoption indicates proper abstraction and reuse.",
      "incorrect": {
        "A": "Volume alone does not imply reuse.",
        "C": "Payload size is irrelevant.",
        "D": "Deployment frequency is operational."
      }
    }
  },
  {
    "id": "EXP-MS-0032",
    "component": "Creating Application Networks – API Boundaries",
    "difficulty": "Extreme",
    "question": "Which change should always trigger a major version increment?",
    "options": {
      "A": "Adding optional metadata",
      "B": "Removing an existing endpoint",
      "C": "Improving internal performance",
      "D": "Adding logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing endpoints is a breaking change.",
      "incorrect": {
        "A": "Optional metadata is backward-compatible.",
        "C": "Performance changes are non-breaking.",
        "D": "Logging is internal."
      }
    }
  },
  {
    "id": "EXP-MS-0033",
    "component": "Creating Application Networks – API-led Value",
    "difficulty": "Extreme",
    "question": "What is the primary enterprise benefit of API-led connectivity?",
    "options": {
      "A": "Lower infrastructure cost",
      "B": "Faster delivery through reuse",
      "C": "Reduced network latency",
      "D": "Simpler deployment pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse enables faster delivery and adaptability.",
      "incorrect": {
        "A": "Cost reduction is indirect.",
        "C": "Latency is operational.",
        "D": "Pipelines remain complex."
      }
    }
  },
  {
    "id": "EXP-MS-0034",
    "component": "Creating Application Networks – C4E Enablement",
    "difficulty": "Extreme",
    "question": "Which C4E output most directly enables developer self-service?",
    "options": {
      "A": "Operational dashboards",
      "B": "Reusable API assets",
      "C": "Incident runbooks",
      "D": "Runtime alerts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable assets allow teams to build independently.",
      "incorrect": {
        "A": "Dashboards are operational.",
        "C": "Runbooks are reactive.",
        "D": "Alerts are runtime-focused."
      }
    }
  },
  {
    "id": "EXP-MS-0035",
    "component": "Creating Application Networks – API Contracts",
    "difficulty": "Extreme",
    "question": "Why should API contracts avoid exposing backend table names?",
    "options": {
      "A": "They increase payload size",
      "B": "They leak implementation details",
      "C": "They reduce throughput",
      "D": "They break policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exposing internals tightly couples consumers to backend design.",
      "incorrect": {
        "A": "Payload size is minor.",
        "C": "Throughput is unrelated.",
        "D": "Policies do not address schema names."
      }
    }
  },

  {
    "id": "EXP-MS-0036",
    "component": "Creating Application Networks – API Governance",
    "difficulty": "Extreme",
    "question": "Which mechanism enforces API standards before implementation begins?",
    "options": {
      "A": "Runtime monitoring",
      "B": "Design-time RAML reviews",
      "C": "Error handling policies",
      "D": "Autoscaling rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-time reviews prevent violations early.",
      "incorrect": {
        "A": "Monitoring is reactive.",
        "C": "Policies act at runtime.",
        "D": "Autoscaling is infrastructure-level."
      }
    }
  },
  {
    "id": "EXP-MS-0037",
    "component": "Creating Application Networks – Experience API Evolution",
    "difficulty": "Extreme",
    "question": "Why is frequent change acceptable in Experience APIs but risky in System APIs?",
    "options": {
      "A": "Experience APIs are smaller",
      "B": "System APIs have broader consumer impact",
      "C": "Experience APIs lack contracts",
      "D": "System APIs are auto-generated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs have wide reuse; changes have a large blast radius.",
      "incorrect": {
        "A": "Size is not the core reason.",
        "C": "Both layers have contracts.",
        "D": "System APIs are not autogenerated."
      }
    }
  },
  {
    "id": "EXP-MS-0038",
    "component": "Creating Application Networks – Dependency Management",
    "difficulty": "Extreme",
    "question": "A Process API depends on a deprecated System API. What is the correct action?",
    "options": {
      "A": "Ignore deprecation",
      "B": "Introduce a replacement and migrate",
      "C": "Remove dependency immediately",
      "D": "Expose System API externally"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Controlled migration avoids breaking downstream consumers.",
      "incorrect": {
        "A": "Ignoring deprecation increases risk.",
        "C": "Immediate removal causes outages.",
        "D": "Exposure does not solve deprecation."
      }
    }
  },
  {
    "id": "EXP-MS-0039",
    "component": "Creating Application Networks – API-led Anti-patterns",
    "difficulty": "Extreme",
    "question": "Which pattern most strongly indicates point-to-point integration?",
    "options": {
      "A": "Layered APIs with reuse",
      "B": "Direct Experience-to-System API calls",
      "C": "Centralized Process APIs",
      "D": "Exchange-based discovery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Direct calls bypassing Process APIs recreate point-to-point coupling.",
      "incorrect": {
        "A": "Layering avoids point-to-point.",
        "C": "Centralized orchestration is valid.",
        "D": "Discovery reduces duplication."
      }
    }
  },
  {
    "id": "EXP-MS-0040",
    "component": "Creating Application Networks – API-led Completion",
    "difficulty": "Extreme",
    "question": "Which outcome best indicates a mature API-led organization?",
    "options": {
      "A": "High worker utilization",
      "B": "Rapid solution delivery using existing APIs",
      "C": "Large number of APIs",
      "D": "Minimal documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fast delivery through reuse reflects API-led maturity.",
      "incorrect": {
        "A": "Utilization is operational.",
        "C": "Quantity does not equal maturity.",
        "D": "Documentation is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0041",
    "component": "Creating Application Networks – Experience API Scope",
    "difficulty": "Extreme",
    "question": "An Experience API begins to cache backend responses aggressively. What risk does this introduce if not coordinated with lower layers?",
    "options": {
      "A": "Reduced throughput",
      "B": "Serving stale business data",
      "C": "Increased payload size",
      "D": "Policy violations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Caching at the Experience layer can serve stale data if backend change semantics are ignored.",
      "incorrect": {
        "A": "Caching usually improves throughput.",
        "C": "Payload size is unaffected.",
        "D": "Policies do not manage data freshness."
      }
    }
  },
  {
    "id": "EXP-MS-0042",
    "component": "Creating Application Networks – Process API Ownership",
    "difficulty": "Extreme",
    "question": "A Process API serves multiple business domains and no team wants to own changes. What is the most likely root cause?",
    "options": {
      "A": "Overuse of Experience APIs",
      "B": "Incorrect domain boundaries",
      "C": "Lack of System APIs",
      "D": "Policy misconfiguration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Poorly defined domain boundaries lead to unclear ownership and responsibility.",
      "incorrect": {
        "A": "Experience APIs are not the issue.",
        "C": "System APIs may exist.",
        "D": "Policies do not define ownership."
      }
    }
  },
  {
    "id": "EXP-MS-0043",
    "component": "Creating Application Networks – API Domain Modeling",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates incorrect API domain modeling?",
    "options": {
      "A": "High reuse",
      "B": "Frequent cross-team conflicts",
      "C": "Stable contracts",
      "D": "Clear ownership"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Frequent conflicts indicate overlapping or unclear domain boundaries.",
      "incorrect": {
        "A": "High reuse is positive.",
        "C": "Stability is desired.",
        "D": "Clear ownership indicates good modeling."
      }
    }
  },
  {
    "id": "EXP-MS-0044",
    "component": "Creating Application Networks – API Change Management",
    "difficulty": "Extreme",
    "question": "Why should Experience APIs avoid embedding backend retry logic?",
    "options": {
      "A": "It increases latency",
      "B": "It duplicates resilience concerns",
      "C": "It breaks REST constraints",
      "D": "It violates RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience strategies belong closer to System or Process APIs to avoid duplication.",
      "incorrect": {
        "A": "Latency impact is secondary.",
        "C": "REST constraints are unrelated.",
        "D": "RAML does not restrict retries."
      }
    }
  },
  {
    "id": "EXP-MS-0045",
    "component": "Creating Application Networks – API-led Governance",
    "difficulty": "Extreme",
    "question": "Which artifact best communicates API intent and boundaries across teams?",
    "options": {
      "A": "Runtime logs",
      "B": "RAML specification",
      "C": "CloudHub alerts",
      "D": "Deployment pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RAML defines contract, intent, and boundaries clearly.",
      "incorrect": {
        "A": "Logs are operational.",
        "C": "Alerts are reactive.",
        "D": "Pipelines are technical."
      }
    }
  },

  {
    "id": "EXP-MS-0046",
    "component": "Creating Application Networks – Process API Evolution",
    "difficulty": "Extreme",
    "question": "A Process API accumulates conditional logic for multiple channels. What corrective action is most appropriate?",
    "options": {
      "A": "Add more conditions",
      "B": "Move channel logic to Experience APIs",
      "C": "Expose Process API externally",
      "D": "Disable versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Channel-specific logic must live in Experience APIs.",
      "incorrect": {
        "A": "This worsens the problem.",
        "C": "Exposure does not solve design issues.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "EXP-MS-0047",
    "component": "Creating Application Networks – System API Contracts",
    "difficulty": "Extreme",
    "question": "Why should System API contracts avoid exposing optional fields driven by UI needs?",
    "options": {
      "A": "They increase payload size",
      "B": "They reduce reuse across domains",
      "C": "They slow down responses",
      "D": "They break policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "UI-driven fields reduce reusability of System APIs.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Performance impact is minimal.",
        "D": "Policies are unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0048",
    "component": "Creating Application Networks – API-led Scalability",
    "difficulty": "Extreme",
    "question": "Which architectural choice most improves scalability in an API-led network?",
    "options": {
      "A": "Synchronous orchestration everywhere",
      "B": "Layered APIs with clear responsibilities",
      "C": "Direct client-to-backend access",
      "D": "Single large Process API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered responsibilities reduce bottlenecks and coupling.",
      "incorrect": {
        "A": "Synchronous orchestration limits scalability.",
        "C": "Direct access increases fragility.",
        "D": "Large APIs become bottlenecks."
      }
    }
  },
  {
    "id": "EXP-MS-0049",
    "component": "Creating Application Networks – API Ownership Signals",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates unclear API ownership?",
    "options": {
      "A": "High reuse",
      "B": "Frequent uncoordinated changes",
      "C": "Stable contracts",
      "D": "Documented SLAs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Uncoordinated changes indicate missing ownership.",
      "incorrect": {
        "A": "Reuse is positive.",
        "C": "Stability implies control.",
        "D": "SLAs indicate ownership."
      }
    }
  },
  {
    "id": "EXP-MS-0050",
    "component": "Creating Application Networks – API-led Outcomes",
    "difficulty": "Extreme",
    "question": "Which outcome most directly validates API-led connectivity?",
    "options": {
      "A": "Lower CPU utilization",
      "B": "New solutions built using existing APIs",
      "C": "More APIs deployed",
      "D": "Shorter payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse of existing APIs demonstrates network effect.",
      "incorrect": {
        "A": "CPU is operational.",
        "C": "Quantity does not imply success.",
        "D": "Payload size is irrelevant."
      }
    }
  },

  {
    "id": "EXP-MS-0051",
    "component": "Creating Application Networks – Error Containment Strategy",
    "difficulty": "Extreme",
    "question": "A backend outage should not surface raw errors to clients. Which layer is primarily responsible for shielding clients?",
    "options": {
      "A": "Experience API",
      "B": "Process API",
      "C": "System API",
      "D": "Client application"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs contain and translate backend failures.",
      "incorrect": {
        "A": "Experience APIs are presentation-focused.",
        "C": "System APIs expose backend behavior.",
        "D": "Clients should not handle backend failures."
      }
    }
  },
  {
    "id": "EXP-MS-0052",
    "component": "Creating Application Networks – API Dependency Risk",
    "difficulty": "Extreme",
    "question": "What is the primary risk of chaining too many APIs synchronously?",
    "options": {
      "A": "Reduced documentation",
      "B": "Failure amplification",
      "C": "Lower payload size",
      "D": "Simpler monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Synchronous chains amplify failures and latency.",
      "incorrect": {
        "A": "Documentation is unaffected.",
        "C": "Payload size is unrelated.",
        "D": "Monitoring becomes harder."
      }
    }
  },
  {
    "id": "EXP-MS-0053",
    "component": "Creating Application Networks – API-led Anti-pattern",
    "difficulty": "Extreme",
    "question": "Which pattern most clearly violates API-led connectivity?",
    "options": {
      "A": "Experience → Process → System layering",
      "B": "Direct Experience-to-System integration",
      "C": "Process API reuse",
      "D": "Exchange-based discovery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bypassing Process APIs recreates point-to-point coupling.",
      "incorrect": {
        "A": "This is correct layering.",
        "C": "Reuse is encouraged.",
        "D": "Discovery reduces duplication."
      }
    }
  },
  {
    "id": "EXP-MS-0054",
    "component": "Creating Application Networks – API Strategy",
    "difficulty": "Extreme",
    "question": "Which decision most improves long-term enterprise agility?",
    "options": {
      "A": "Hard-coded integrations",
      "B": "Composable reusable APIs",
      "C": "Centralized monolithic integration",
      "D": "Client-side orchestration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composable APIs allow rapid adaptation to change.",
      "incorrect": {
        "A": "Hard-coding reduces agility.",
        "C": "Monoliths limit flexibility.",
        "D": "Client orchestration increases coupling."
      }
    }
  },
  {
    "id": "EXP-MS-0055",
    "component": "Creating Application Networks – API Lifecycle Management",
    "difficulty": "Extreme",
    "question": "Which action best supports safe API retirement?",
    "options": {
      "A": "Immediate shutdown",
      "B": "Silent removal",
      "C": "Deprecation with migration path",
      "D": "Removing from Exchange"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Deprecation with migration avoids breaking consumers.",
      "incorrect": {
        "A": "Immediate shutdown causes outages.",
        "B": "Silent removal breaks contracts.",
        "D": "Exchange removal does not stop usage."
      }
    }
  },

  {
    "id": "EXP-MS-0056",
    "component": "Creating Application Networks – API-led Metrics",
    "difficulty": "Extreme",
    "question": "Which metric best measures API-led maturity?",
    "options": {
      "A": "Worker count",
      "B": "Cross-team API reuse",
      "C": "Deployment frequency",
      "D": "Average latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse across teams reflects maturity.",
      "incorrect": {
        "A": "Worker count is infrastructure.",
        "C": "Frequency is delivery-focused.",
        "D": "Latency is operational."
      }
    }
  },
  {
    "id": "EXP-MS-0057",
    "component": "Creating Application Networks – API Boundaries",
    "difficulty": "Extreme",
    "question": "Which change should never be introduced without versioning?",
    "options": {
      "A": "Adding optional fields",
      "B": "Removing response attributes",
      "C": "Improving performance",
      "D": "Refactoring internal code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing response attributes breaks existing consumers.",
      "incorrect": {
        "A": "Optional additions are safe.",
        "C": "Performance is non-breaking.",
        "D": "Internal refactoring is safe."
      }
    }
  },
  {
    "id": "EXP-MS-0058",
    "component": "Creating Application Networks – API Documentation",
    "difficulty": "Extreme",
    "question": "Why is accurate API documentation critical in an API-led organization?",
    "options": {
      "A": "To improve runtime performance",
      "B": "To enable independent team development",
      "C": "To reduce payload size",
      "D": "To enforce policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear documentation enables teams to consume APIs independently.",
      "incorrect": {
        "A": "Documentation is not runtime.",
        "C": "Payload size is unaffected.",
        "D": "Policies are enforced separately."
      }
    }
  },
  {
    "id": "EXP-MS-0059",
    "component": "Creating Application Networks – API-led Governance",
    "difficulty": "Extreme",
    "question": "Which governance control is most effective at preventing breaking changes?",
    "options": {
      "A": "Runtime alerts",
      "B": "Design-time contract reviews",
      "C": "Autoscaling rules",
      "D": "Error logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-time reviews catch issues before deployment.",
      "incorrect": {
        "A": "Alerts are reactive.",
        "C": "Scaling does not affect contracts.",
        "D": "Logging is diagnostic."
      }
    }
  },
  {
    "id": "EXP-MS-0060",
    "component": "Creating Application Networks – API-led Closure",
    "difficulty": "Extreme",
    "question": "Which statement best summarizes API-led connectivity?",
    "options": {
      "A": "Expose all systems directly",
      "B": "Layered reuse through clear API responsibilities",
      "C": "Centralize all logic",
      "D": "Minimize number of APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led connectivity is about layered reuse and abstraction.",
      "incorrect": {
        "A": "Direct exposure increases coupling.",
        "C": "Centralization reduces flexibility.",
        "D": "Quantity is not the goal."
      }
    }
  },

  {
    "id": "EXP-MS-0061",
    "component": "Creating Application Networks – Completion",
    "difficulty": "Extreme",
    "question": "Which condition must be true for an application network to scale sustainably?",
    "options": {
      "A": "All APIs owned by one team",
      "B": "Clear API ownership and boundaries",
      "C": "Minimal governance",
      "D": "Direct system access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership and boundaries enable parallel development.",
      "incorrect": {
        "A": "Single ownership does not scale.",
        "C": "Governance is required.",
        "D": "Direct access increases risk."
      }
    }
  },
  {
    "id": "EXP-MS-0062",
    "component": "Creating Application Networks – API Reuse Validation",
    "difficulty": "Extreme",
    "question": "Which scenario best validates effective API reuse?",
    "options": {
      "A": "Same team calls the API repeatedly",
      "B": "Multiple unrelated teams adopt the same API",
      "C": "API handles high traffic",
      "D": "API has many endpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cross-team adoption signals correct abstraction.",
      "incorrect": {
        "A": "Reuse across teams matters.",
        "C": "Traffic volume alone is insufficient.",
        "D": "Endpoint count is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0063",
    "component": "Creating Application Networks – API Boundaries Enforcement",
    "difficulty": "Extreme",
    "question": "Which practice most effectively preserves API boundaries over time?",
    "options": {
      "A": "Frequent refactoring",
      "B": "Strict contract ownership",
      "C": "Increasing worker size",
      "D": "Client-side validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership enforces boundary discipline.",
      "incorrect": {
        "A": "Refactoring does not ensure boundaries.",
        "C": "Worker size is irrelevant.",
        "D": "Clients should not enforce boundaries."
      }
    }
  },
  {
    "id": "EXP-MS-0064",
    "component": "Creating Application Networks – API-led Culture",
    "difficulty": "Extreme",
    "question": "Which cultural shift is required for successful API-led adoption?",
    "options": {
      "A": "Centralized development",
      "B": "Product-oriented API ownership",
      "C": "Minimal documentation",
      "D": "Ad-hoc integration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs must be treated as products with ownership.",
      "incorrect": {
        "A": "Centralization limits agility.",
        "C": "Documentation is essential.",
        "D": "Ad-hoc integration increases chaos."
      }
    }
  },
  {
    "id": "EXP-MS-0065",
    "component": "Creating Application Networks – API Change Signals",
    "difficulty": "Extreme",
    "question": "Which signal indicates a breaking change has likely occurred?",
    "options": {
      "A": "Increased latency",
      "B": "Sudden consumer failures",
      "C": "Higher throughput",
      "D": "More documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumer failures indicate contract incompatibility.",
      "incorrect": {
        "A": "Latency may fluctuate for other reasons.",
        "C": "Throughput is unrelated.",
        "D": "Documentation does not cause failures."
      }
    }
  },
  {
    "id": "EXP-MS-0066",
    "component": "Creating Application Networks – API-led Architecture",
    "difficulty": "Extreme",
    "question": "Why is strict layering critical in large API networks?",
    "options": {
      "A": "To reduce payload size",
      "B": "To limit change impact",
      "C": "To improve UI performance",
      "D": "To simplify logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layering confines changes and reduces blast radius.",
      "incorrect": {
        "A": "Payload size is incidental.",
        "C": "UI performance is channel-specific.",
        "D": "Logging is orthogonal."
      }
    }
  },
  {
    "id": "EXP-MS-0067",
    "component": "Creating Application Networks – API-led Failure Handling",
    "difficulty": "Extreme",
    "question": "Which approach best limits cascading failures across APIs?",
    "options": {
      "A": "Long synchronous chains",
      "B": "Circuit breakers at Process APIs",
      "C": "Client-side retries",
      "D": "Direct backend exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers contain failures and protect downstream systems.",
      "incorrect": {
        "A": "Chains amplify failures.",
        "C": "Client retries increase load.",
        "D": "Exposure increases fragility."
      }
    }
  },
  {
    "id": "EXP-MS-0068",
    "component": "Creating Application Networks – API Network Health",
    "difficulty": "Extreme",
    "question": "Which indicator best reflects a resilient application network?",
    "options": {
      "A": "High CPU usage",
      "B": "Graceful degradation during failures",
      "C": "Large API count",
      "D": "Minimal governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Graceful degradation indicates proper abstraction and resilience.",
      "incorrect": {
        "A": "CPU is operational.",
        "C": "Quantity is not health.",
        "D": "Governance is required."
      }
    }
  },
  {
    "id": "EXP-MS-0069",
    "component": "Creating Application Networks – API-led Maturity",
    "difficulty": "Extreme",
    "question": "What distinguishes a mature API-led organization from an early-stage one?",
    "options": {
      "A": "More APIs",
      "B": "Reusable APIs driving multiple initiatives",
      "C": "Higher latency tolerance",
      "D": "Less documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is demonstrated by reuse across initiatives.",
      "incorrect": {
        "A": "Quantity does not equal maturity.",
        "C": "Latency tolerance is irrelevant.",
        "D": "Documentation remains critical."
      }
    }
  },
  {
    "id": "EXP-MS-0070",
    "component": "Creating Application Networks – Section Completion",
    "difficulty": "Extreme",
    "question": "Which principle underpins all API-led connectivity decisions?",
    "options": {
      "A": "Centralization",
      "B": "Reuse through abstraction",
      "C": "Direct integration",
      "D": "Minimal APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Abstraction and reuse are the foundation of API-led connectivity.",
      "incorrect": {
        "A": "Centralization reduces agility.",
        "C": "Direct integration increases coupling.",
        "D": "Minimal APIs is not the goal."
      }
    }
  },
  {
    "id": "EXP-MS-0071",
    "component": "Designing APIs – Resource Modeling",
    "difficulty": "Extreme",
    "question": "An API exposes `/createOrder`, `/updateOrder`, and `/deleteOrder`. What is the primary REST design flaw?",
    "options": {
      "A": "Missing versioning",
      "B": "Verb-based resource naming",
      "C": "Incorrect HTTP status codes",
      "D": "Lack of pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RESTful APIs model resources as nouns and rely on HTTP methods for actions.",
      "incorrect": {
        "A": "Versioning is orthogonal.",
        "C": "Status codes are not shown.",
        "D": "Pagination is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0072",
    "component": "Designing APIs – HTTP Method Semantics",
    "difficulty": "Extreme",
    "question": "Which HTTP method must be safe and free of side effects by definition?",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "GET"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "GET must not modify server state and is safe by REST definition.",
      "incorrect": {
        "A": "POST is non-idempotent.",
        "B": "PUT modifies state.",
        "C": "PATCH modifies state."
      }
    }
  },
  {
    "id": "EXP-MS-0073",
    "component": "Designing APIs – Idempotency",
    "difficulty": "Extreme",
    "question": "A client retries a request due to network timeout. Which operation is safest to retry automatically?",
    "options": {
      "A": "POST /payments",
      "B": "PUT /customers/123",
      "C": "PATCH /orders/456",
      "D": "POST /orders"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PUT is idempotent; repeating it yields the same result.",
      "incorrect": {
        "A": "Payment creation is non-idempotent.",
        "C": "PATCH is not guaranteed idempotent.",
        "D": "Order creation is non-idempotent."
      }
    }
  },
  {
    "id": "EXP-MS-0074",
    "component": "Designing APIs – URI Design",
    "difficulty": "Extreme",
    "question": "Which URI best represents a sub-resource relationship?",
    "options": {
      "A": "/getOrdersByCustomer",
      "B": "/orders?customerId=123",
      "C": "/customers/123/orders",
      "D": "/orders/customer/123"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Hierarchical URIs express clear parent–child relationships.",
      "incorrect": {
        "A": "Verb-based naming breaks REST.",
        "B": "Query parameters do not model hierarchy.",
        "D": "Ambiguous and less RESTful."
      }
    }
  },
  {
    "id": "EXP-MS-0075",
    "component": "Designing APIs – Status Codes",
    "difficulty": "Extreme",
    "question": "Which status code best represents a request accepted for asynchronous processing?",
    "options": {
      "A": "200",
      "B": "201",
      "C": "202",
      "D": "204"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "202 indicates the request is accepted but not yet processed.",
      "incorrect": {
        "A": "200 implies immediate success.",
        "B": "201 implies creation completed.",
        "D": "204 returns no content."
      }
    }
  },

  {
    "id": "EXP-MS-0076",
    "component": "Designing APIs – Query vs URI Parameters",
    "difficulty": "Extreme",
    "question": "Which parameter should always be modeled as a URI parameter?",
    "options": {
      "A": "sortOrder",
      "B": "pageSize",
      "C": "resourceId",
      "D": "filter"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "URI parameters uniquely identify resources.",
      "incorrect": {
        "A": "Sorting modifies representation.",
        "B": "Pagination is a query concern.",
        "D": "Filtering belongs in query parameters."
      }
    }
  },
  {
    "id": "EXP-MS-0077",
    "component": "Designing APIs – Content Negotiation",
    "difficulty": "Extreme",
    "question": "Which mechanism allows clients to request a specific response media type?",
    "options": {
      "A": "Content-Type header",
      "B": "Accept header",
      "C": "Custom query parameter",
      "D": "HTTP method"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accept header is the standard for content negotiation.",
      "incorrect": {
        "A": "Content-Type describes request payload.",
        "C": "Query parameters are non-standard.",
        "D": "Methods do not control media type."
      }
    }
  },
  {
    "id": "EXP-MS-0078",
    "component": "Designing APIs – RAML Contracts",
    "difficulty": "Extreme",
    "question": "A RAML spec marks a field as required. The implementation omits it in responses. What is the primary consequence?",
    "options": {
      "A": "Automatic retry",
      "B": "Contract violation for consumers",
      "C": "Policy enforcement failure",
      "D": "Lower throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumers rely on RAML contracts; missing required fields break them.",
      "incorrect": {
        "A": "Retries are not automatic.",
        "C": "Policies do not validate payload shape.",
        "D": "Throughput is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0079",
    "component": "Designing APIs – Backward Compatibility",
    "difficulty": "Extreme",
    "question": "Which change is backward-compatible without versioning?",
    "options": {
      "A": "Removing a response field",
      "B": "Changing a field data type",
      "C": "Adding an optional response field",
      "D": "Renaming an endpoint"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Optional additions do not break existing consumers.",
      "incorrect": {
        "A": "Removal breaks consumers.",
        "B": "Type change is breaking.",
        "D": "Renaming endpoints is breaking."
      }
    }
  },
  {
    "id": "EXP-MS-0080",
    "component": "Designing APIs – Error Modeling",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid returning HTTP 200 for business errors?",
    "options": {
      "A": "It increases payload size",
      "B": "It breaks client error handling logic",
      "C": "It reduces performance",
      "D": "It violates JSON schema"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients depend on status codes to detect errors reliably.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Performance is unaffected.",
        "D": "Schema validation is independent."
      }
    }
  },

  {
    "id": "EXP-MS-0081",
    "component": "Designing APIs – APIkit Routing",
    "difficulty": "Extreme",
    "question": "How does APIkit determine which flow to invoke?",
    "options": {
      "A": "Payload structure",
      "B": "HTTP headers",
      "C": "RAML resource and method",
      "D": "Policy configuration"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit routes requests strictly based on RAML resource and HTTP method.",
      "incorrect": {
        "A": "Payload is irrelevant to routing.",
        "B": "Headers alone do not route.",
        "D": "Policies do not select flows."
      }
    }
  },
  {
    "id": "EXP-MS-0082",
    "component": "Designing APIs – Pagination Strategy",
    "difficulty": "Extreme",
    "question": "Which pagination strategy scales best for very large datasets?",
    "options": {
      "A": "Offset-based pagination",
      "B": "Page-number pagination",
      "C": "Cursor-based pagination",
      "D": "Client-side pagination"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Cursor-based pagination avoids performance issues with large offsets.",
      "incorrect": {
        "A": "Offsets degrade at scale.",
        "B": "Page numbers are fragile.",
        "D": "Client-side requires full dataset."
      }
    }
  },
  {
    "id": "EXP-MS-0083",
    "component": "Designing APIs – HTTP Semantics",
    "difficulty": "Extreme",
    "question": "Which HTTP status code best represents semantic validation failure?",
    "options": {
      "A": "400",
      "B": "401",
      "C": "403",
      "D": "422"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "422 Unprocessable Entity indicates semantically invalid input.",
      "incorrect": {
        "A": "400 is syntactic error.",
        "B": "401 is authentication-related.",
        "C": "403 is authorization-related."
      }
    }
  },
  {
    "id": "EXP-MS-0084",
    "component": "Designing APIs – Versioning Strategy",
    "difficulty": "Extreme",
    "question": "Which versioning approach minimizes consumer disruption?",
    "options": {
      "A": "Frequent breaking releases",
      "B": "Backward-compatible evolution",
      "C": "Immediate deprecation",
      "D": "Query-parameter-only versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward-compatible changes allow consumers to upgrade safely.",
      "incorrect": {
        "A": "Breaking releases disrupt consumers.",
        "C": "Immediate deprecation causes outages.",
        "D": "Query-based versioning is fragile."
      }
    }
  },
  {
    "id": "EXP-MS-0085",
    "component": "Designing APIs – Resource Granularity",
    "difficulty": "Extreme",
    "question": "Which design most improves API reuse?",
    "options": {
      "A": "Highly specific endpoints per client",
      "B": "Coarse-grained, business-oriented resources",
      "C": "Client-side orchestration",
      "D": "Direct database exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business-oriented resources are reusable across consumers.",
      "incorrect": {
        "A": "Client-specific endpoints reduce reuse.",
        "C": "Client orchestration increases coupling.",
        "D": "Database exposure leaks internals."
      }
    }
  },

  {
    "id": "EXP-MS-0086",
    "component": "Designing APIs – RAML Reuse",
    "difficulty": "Extreme",
    "question": "What is the primary purpose of RAML resourceTypes?",
    "options": {
      "A": "Runtime validation",
      "B": "Reuse of common resource patterns",
      "C": "Policy enforcement",
      "D": "Payload compression"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "resourceTypes reduce duplication across similar resources.",
      "incorrect": {
        "A": "Validation is separate.",
        "C": "Policies are runtime.",
        "D": "Compression is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0087",
    "component": "Designing APIs – Contract Evolution",
    "difficulty": "Extreme",
    "question": "Which change must always trigger a major version?",
    "options": {
      "A": "Adding examples",
      "B": "Removing an endpoint",
      "C": "Improving performance",
      "D": "Adding optional headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing endpoints breaks existing consumers.",
      "incorrect": {
        "A": "Examples are documentation.",
        "C": "Performance is non-breaking.",
        "D": "Optional headers are safe."
      }
    }
  },
  {
    "id": "EXP-MS-0088",
    "component": "Designing APIs – API Documentation",
    "difficulty": "Extreme",
    "question": "Why should API documentation avoid implementation details?",
    "options": {
      "A": "They increase payload size",
      "B": "They couple consumers to internals",
      "C": "They reduce throughput",
      "D": "They break policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Leaking internals reduces flexibility and abstraction.",
      "incorrect": {
        "A": "Payload size is unaffected.",
        "C": "Throughput is unrelated.",
        "D": "Policies are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0089",
    "component": "Designing APIs – REST Constraints",
    "difficulty": "Extreme",
    "question": "Which REST constraint most directly enables horizontal scalability?",
    "options": {
      "A": "Uniform interface",
      "B": "Statelessness",
      "C": "Layered system",
      "D": "Cacheability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Statelessness allows servers to scale horizontally.",
      "incorrect": {
        "A": "Uniform interface aids consistency.",
        "C": "Layering aids abstraction.",
        "D": "Caching improves performance."
      }
    }
  },
  {
    "id": "EXP-MS-0090",
    "component": "Designing APIs – API Quality Signals",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates poor API design?",
    "options": {
      "A": "High reuse",
      "B": "Frequent consumer workarounds",
      "C": "Stable contracts",
      "D": "Clear error models"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Workarounds indicate gaps or inconsistencies in design.",
      "incorrect": {
        "A": "High reuse is positive.",
        "C": "Stability is desired.",
        "D": "Clear errors improve quality."
      }
    }
  },

  {
    "id": "EXP-MS-0091",
    "component": "Designing APIs – API Boundaries",
    "difficulty": "Extreme",
    "question": "Which responsibility should never be part of API design?",
    "options": {
      "A": "Business semantics",
      "B": "Error modeling",
      "C": "UI presentation logic",
      "D": "Versioning strategy"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "UI concerns must not leak into API contracts.",
      "incorrect": {
        "A": "Business semantics are core.",
        "B": "Error modeling is essential.",
        "D": "Versioning is required."
      }
    }
  },
  {
    "id": "EXP-MS-0092",
    "component": "Designing APIs – Hypermedia",
    "difficulty": "Extreme",
    "question": "What is the primary benefit of HATEOAS?",
    "options": {
      "A": "Smaller payloads",
      "B": "Reduced client–server coupling",
      "C": "Higher throughput",
      "D": "Simpler RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hypermedia enables clients to discover actions dynamically.",
      "incorrect": {
        "A": "Payloads may increase.",
        "C": "Throughput is unrelated.",
        "D": "RAML may become more complex."
      }
    }
  },
  {
    "id": "EXP-MS-0093",
    "component": "Designing APIs – API Governance",
    "difficulty": "Extreme",
    "question": "Which design-time control most effectively enforces API standards?",
    "options": {
      "A": "Runtime alerts",
      "B": "Contract-first design reviews",
      "C": "Higher worker sizing",
      "D": "Client-side validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-time reviews prevent violations before implementation.",
      "incorrect": {
        "A": "Alerts are reactive.",
        "C": "Workers do not enforce standards.",
        "D": "Clients should not enforce standards."
      }
    }
  },
  {
    "id": "EXP-MS-0094",
    "component": "Designing APIs – API Evolution",
    "difficulty": "Extreme",
    "question": "Why should deprecated endpoints remain available temporarily?",
    "options": {
      "A": "To increase traffic",
      "B": "To allow consumer migration",
      "C": "To reduce costs",
      "D": "To avoid documentation updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumers need time to migrate safely.",
      "incorrect": {
        "A": "Traffic is not the goal.",
        "C": "Costs may increase temporarily.",
        "D": "Documentation must still be updated."
      }
    }
  },
  {
    "id": "EXP-MS-0095",
    "component": "Designing APIs – Section Continuation",
    "difficulty": "Extreme",
    "question": "Which outcome best indicates a well-designed API?",
    "options": {
      "A": "High server utilization",
      "B": "Low need for consumer clarification",
      "C": "Large payloads",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear APIs reduce consumer confusion and support.",
      "incorrect": {
        "A": "Utilization is operational.",
        "C": "Payload size is not quality.",
        "D": "Breaking changes indicate poor design."
      }
    }
  },
  {
    "id": "EXP-MS-0096",
    "component": "Designing APIs – HTTP Semantics",
    "difficulty": "Extreme",
    "question": "Which HTTP method is explicitly defined as idempotent but not safe?",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "CONNECT"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "PUT is idempotent but modifies server state.",
      "incorrect": {
        "A": "GET is safe and idempotent.",
        "B": "POST is not idempotent.",
        "D": "CONNECT semantics differ."
      }
    }
  },
  {
    "id": "EXP-MS-0097",
    "component": "Designing APIs – RAML Validation",
    "difficulty": "Extreme",
    "question": "What is the primary benefit of enforcing RAML request validation at runtime?",
    "options": {
      "A": "Lower latency",
      "B": "Early rejection of invalid consumer requests",
      "C": "Automatic retries",
      "D": "Payload compression"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runtime validation prevents invalid requests from reaching business logic.",
      "incorrect": {
        "A": "Validation may increase latency.",
        "C": "Retries are not automatic.",
        "D": "Compression is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0098",
    "component": "Designing APIs – APIkit Behavior",
    "difficulty": "Extreme",
    "question": "If an APIkit flow does not explicitly set a response payload matching RAML, what occurs?",
    "options": {
      "A": "Payload is returned as-is",
      "B": "APIkit throws a contract violation error",
      "C": "Gateway policies override response",
      "D": "Response is silently dropped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit enforces response contracts defined in RAML.",
      "incorrect": {
        "A": "Mismatches are not ignored.",
        "C": "Policies do not reshape payloads.",
        "D": "Responses are not dropped silently."
      }
    }
  },
  {
    "id": "EXP-MS-0099",
    "component": "Designing APIs – Status Codes",
    "difficulty": "Extreme",
    "question": "Which status code best represents authorization failure for an authenticated client?",
    "options": {
      "A": "400",
      "B": "401",
      "C": "403",
      "D": "500"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "403 indicates the client is authenticated but not authorized.",
      "incorrect": {
        "A": "400 is client input error.",
        "B": "401 indicates authentication failure.",
        "D": "500 is server error."
      }
    }
  },
  {
    "id": "EXP-MS-0100",
    "component": "Designing APIs – REST Constraints",
    "difficulty": "Extreme",
    "question": "Which REST constraint allows intermediaries such as gateways and proxies?",
    "options": {
      "A": "Statelessness",
      "B": "Layered system",
      "C": "Uniform interface",
      "D": "Cacheability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered systems enable intermediaries between client and server.",
      "incorrect": {
        "A": "Statelessness affects scaling.",
        "C": "Uniform interface affects consistency.",
        "D": "Cacheability affects performance."
      }
    }
  },

  {
    "id": "EXP-MS-0101",
    "component": "Designing APIs – API Evolution",
    "difficulty": "Extreme",
    "question": "Which change is most dangerous without versioning?",
    "options": {
      "A": "Adding optional headers",
      "B": "Removing response fields",
      "C": "Improving performance",
      "D": "Adding examples"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing fields breaks existing consumer parsing logic.",
      "incorrect": {
        "A": "Optional headers are safe.",
        "C": "Performance changes are transparent.",
        "D": "Examples are documentation only."
      }
    }
  },
  {
    "id": "EXP-MS-0102",
    "component": "Designing APIs – Pagination",
    "difficulty": "Extreme",
    "question": "Why is offset-based pagination problematic at scale?",
    "options": {
      "A": "It increases payload size",
      "B": "Database scans become increasingly expensive",
      "C": "Clients cannot navigate pages",
      "D": "It violates REST"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Large offsets force databases to scan and discard rows.",
      "incorrect": {
        "A": "Payload size is unchanged.",
        "C": "Clients can still paginate.",
        "D": "REST does not prohibit offsets."
      }
    }
  },
  {
    "id": "EXP-MS-0103",
    "component": "Designing APIs – Error Consistency",
    "difficulty": "Extreme",
    "question": "Why should APIs standardize error response structures?",
    "options": {
      "A": "To reduce payload size",
      "B": "To simplify client-side error handling",
      "C": "To improve throughput",
      "D": "To enforce policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent error structures reduce client complexity.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Throughput is unaffected.",
        "D": "Policies do not shape payloads."
      }
    }
  },
  {
    "id": "EXP-MS-0104",
    "component": "Designing APIs – Security Boundaries",
    "difficulty": "Extreme",
    "question": "Why should authentication logic not be embedded directly into API implementations?",
    "options": {
      "A": "It increases latency",
      "B": "It prevents centralized enforcement",
      "C": "It breaks RAML",
      "D": "It reduces caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Centralized enforcement via gateways ensures consistency.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "RAML supports security schemes.",
        "D": "Caching is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0105",
    "component": "Designing APIs – API Boundaries",
    "difficulty": "Extreme",
    "question": "Which responsibility belongs least in an API contract?",
    "options": {
      "A": "Business semantics",
      "B": "Error codes",
      "C": "UI formatting rules",
      "D": "Versioning"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "UI formatting must not leak into API contracts.",
      "incorrect": {
        "A": "Business semantics are core.",
        "B": "Error modeling is essential.",
        "D": "Versioning is required."
      }
    }
  },

  {
    "id": "EXP-MS-0106",
    "component": "Designing APIs – API-led Thinking",
    "difficulty": "Extreme",
    "question": "Why is design-first API development critical in large organizations?",
    "options": {
      "A": "It speeds up coding",
      "B": "It aligns teams on contracts before implementation",
      "C": "It reduces runtime errors",
      "D": "It simplifies deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-first ensures alignment and prevents costly rework.",
      "incorrect": {
        "A": "Coding speed is not guaranteed.",
        "C": "Runtime errors still occur.",
        "D": "Deployment complexity remains."
      }
    }
  },
  {
    "id": "EXP-MS-0107",
    "component": "Designing APIs – Media Types",
    "difficulty": "Extreme",
    "question": "Why should custom media types be used sparingly?",
    "options": {
      "A": "They increase payload size",
      "B": "They reduce interoperability",
      "C": "They slow parsing",
      "D": "They break gateways"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom media types may not be widely supported.",
      "incorrect": {
        "A": "Payload size is unaffected.",
        "C": "Parsing cost is minimal.",
        "D": "Gateways support custom types."
      }
    }
  },
  {
    "id": "EXP-MS-0108",
    "component": "Designing APIs – API Governance",
    "difficulty": "Extreme",
    "question": "Which practice best prevents undocumented breaking changes?",
    "options": {
      "A": "Runtime monitoring",
      "B": "Contract-first reviews",
      "C": "Autoscaling",
      "D": "Client retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-time contract reviews prevent undocumented changes.",
      "incorrect": {
        "A": "Monitoring is reactive.",
        "C": "Autoscaling is unrelated.",
        "D": "Retries worsen load."
      }
    }
  },
  {
    "id": "EXP-MS-0109",
    "component": "Designing APIs – Completion",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates a successful API design?",
    "options": {
      "A": "High CPU usage",
      "B": "Minimal consumer clarification requests",
      "C": "Large payloads",
      "D": "Frequent version bumps"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear APIs reduce consumer confusion.",
      "incorrect": {
        "A": "CPU is operational.",
        "C": "Payload size is irrelevant.",
        "D": "Frequent versioning indicates instability."
      }
    }
  },

  {
    "id": "EXP-MS-0110",
    "component": "Designing APIs – Section End",
    "difficulty": "Extreme",
    "question": "What is the ultimate goal of good API design?",
    "options": {
      "A": "Expose backend systems",
      "B": "Enable reuse with minimal coupling",
      "C": "Reduce code size",
      "D": "Increase API count"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Good APIs enable reuse while minimizing coupling.",
      "incorrect": {
        "A": "Direct exposure increases fragility.",
        "C": "Code size is secondary.",
        "D": "Quantity is not quality."
      }
    }
  },

  {
    "id": "EXP-MS-0111",
    "component": "Designing APIs – Final Closure",
    "difficulty": "Extreme",
    "question": "Which principle ensures APIs remain consumable over long periods?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Backward-compatible evolution",
      "C": "Minimal documentation",
      "D": "Direct system exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward compatibility preserves consumer trust and stability.",
      "incorrect": {
        "A": "Breaking changes erode trust.",
        "C": "Documentation is essential.",
        "D": "Exposure increases risk."
      }
    }
  },
  {
    "id": "EXP-MS-0112",
    "component": "Designing APIs – HTTP Safety",
    "difficulty": "Extreme",
    "question": "Which HTTP method violates REST constraints if it causes state change?",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "POST",
      "D": "PATCH"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "GET must be safe and must not change server state.",
      "incorrect": {
        "B": "PUT is allowed to modify state.",
        "C": "POST is non-safe.",
        "D": "PATCH modifies state."
      }
    }
  },
  {
    "id": "EXP-MS-0113",
    "component": "Designing APIs – Idempotency Guarantees",
    "difficulty": "Extreme",
    "question": "Why is PATCH considered risky for automated retries?",
    "options": {
      "A": "It is unsafe",
      "B": "It is not guaranteed idempotent",
      "C": "It breaks caching",
      "D": "It requires a body"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PATCH does not guarantee idempotency, retries may corrupt state.",
      "incorrect": {
        "A": "Safety is not the core issue.",
        "C": "Caching is unrelated.",
        "D": "Body requirement is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0114",
    "component": "Designing APIs – URI Semantics",
    "difficulty": "Extreme",
    "question": "Which URI change is a breaking change?",
    "options": {
      "A": "Adding optional query parameters",
      "B": "Reordering query parameters",
      "C": "Renaming a path segment",
      "D": "Adding headers"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Renaming a path segment changes the resource identity.",
      "incorrect": {
        "A": "Optional params are safe.",
        "B": "Order does not matter.",
        "D": "Headers do not change URI."
      }
    }
  },
  {
    "id": "EXP-MS-0115",
    "component": "Designing APIs – Status Code Semantics",
    "difficulty": "Extreme",
    "question": "Which status code indicates that the server understood the request but refuses to authorize it?",
    "options": {
      "A": "401",
      "B": "403",
      "C": "404",
      "D": "409"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "403 indicates authorization failure after authentication.",
      "incorrect": {
        "A": "401 is authentication failure.",
        "C": "404 is not found.",
        "D": "409 is conflict."
      }
    }
  },

  {
    "id": "EXP-MS-0116",
    "component": "Designing APIs – RAML Types",
    "difficulty": "Extreme",
    "question": "Why should RAML data types be reused across resources?",
    "options": {
      "A": "To improve runtime speed",
      "B": "To ensure schema consistency",
      "C": "To enforce policies",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared types ensure consistent contracts.",
      "incorrect": {
        "A": "Design-time only.",
        "C": "Policies are separate.",
        "D": "Payload size unchanged."
      }
    }
  },

  {
    "id": "EXP-MS-0117",
    "component": "Designing APIs – RAML Optionality",
    "difficulty": "Extreme",
    "question": "What is the primary risk of incorrectly marking a field as optional in RAML?",
    "options": {
      "A": "Higher latency",
      "B": "Client-side null handling failures",
      "C": "Policy misconfiguration",
      "D": "Lower throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients may assume presence and fail at runtime.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Policies ignore schema optionality.",
        "D": "Throughput is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0118",
    "component": "Designing APIs – Pagination Contracts",
    "difficulty": "Extreme",
    "question": "Why must pagination parameters be part of the API contract?",
    "options": {
      "A": "To improve performance",
      "B": "To guarantee consistent client behavior",
      "C": "To enforce policies",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients depend on stable pagination semantics.",
      "incorrect": {
        "A": "Performance varies by backend.",
        "C": "Policies do not paginate.",
        "D": "Payload size is secondary."
      }
    }
  },

  {
    "id": "EXP-MS-0119",
    "component": "Designing APIs – Error Modeling",
    "difficulty": "Extreme",
    "question": "Which design choice most improves client-side resiliency?",
    "options": {
      "A": "Verbose stack traces",
      "B": "Consistent error schemas",
      "C": "Returning HTTP 200 always",
      "D": "Dynamic field names"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent error schemas allow predictable handling.",
      "incorrect": {
        "A": "Stack traces leak internals.",
        "C": "Breaks error detection.",
        "D": "Dynamic fields break parsers."
      }
    }
  },

  {
    "id": "EXP-MS-0120",
    "component": "Designing APIs – Content Negotiation",
    "difficulty": "Extreme",
    "question": "Why should APIs rely on headers instead of query params for format selection?",
    "options": {
      "A": "Headers are faster",
      "B": "They follow HTTP standards",
      "C": "Gateways require it",
      "D": "RAML enforces it"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP defines headers for content negotiation.",
      "incorrect": {
        "A": "Speed is negligible.",
        "C": "Gateways support both.",
        "D": "RAML does not enforce this."
      }
    }
  },
  {
    "id": "EXP-MS-0121",
    "component": "Designing APIs – Contract Rigidity",
    "difficulty": "Extreme",
    "question": "Which change is most likely to break strongly typed API consumers?",
    "options": {
      "A": "Adding optional response fields",
      "B": "Changing field order in JSON",
      "C": "Changing a field data type",
      "D": "Adding documentation examples"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Data type changes break deserialization in strongly typed clients.",
      "incorrect": {
        "A": "Optional fields are backward-compatible.",
        "B": "JSON field order is insignificant.",
        "D": "Examples do not affect runtime."
      }
    }
  },
  {
    "id": "EXP-MS-0122",
    "component": "Designing APIs – APIkit Enforcement",
    "difficulty": "Extreme",
    "question": "What happens when APIkit receives a request that does not match any RAML resource?",
    "options": {
      "A": "Flow continues with default routing",
      "B": "APIkit returns a 404 error",
      "C": "Gateway policy intercepts",
      "D": "Payload is passed through"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit enforces RAML and returns 404 for unmatched resources.",
      "incorrect": {
        "A": "No default routing exists.",
        "C": "Policies do not create resources.",
        "D": "Payload is not passed blindly."
      }
    }
  },
  {
    "id": "EXP-MS-0123",
    "component": "Designing APIs – HTTP Method Constraints",
    "difficulty": "Extreme",
    "question": "Which HTTP method must NOT be cached by intermediaries by default?",
    "options": {
      "A": "GET",
      "B": "HEAD",
      "C": "POST",
      "D": "OPTIONS"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "POST responses are not cacheable by default.",
      "incorrect": {
        "A": "GET is cacheable.",
        "B": "HEAD follows GET semantics.",
        "D": "OPTIONS may be cached."
      }
    }
  },
  {
    "id": "EXP-MS-0124",
    "component": "Designing APIs – Versioning Discipline",
    "difficulty": "Extreme",
    "question": "Which practice most reduces the need for frequent API versioning?",
    "options": {
      "A": "Large monolithic APIs",
      "B": "Backward-compatible contract evolution",
      "C": "Client-specific endpoints",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward-compatible changes preserve existing consumers.",
      "incorrect": {
        "A": "Monoliths increase breakage.",
        "C": "Client-specific endpoints increase churn.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "EXP-MS-0125",
    "component": "Designing APIs – Error Semantics",
    "difficulty": "Extreme",
    "question": "Which status code best represents a business rule conflict?",
    "options": {
      "A": "400",
      "B": "404",
      "C": "409",
      "D": "422"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "409 Conflict represents valid requests that conflict with current state.",
      "incorrect": {
        "A": "400 is syntactic error.",
        "B": "404 is resource missing.",
        "D": "422 is semantic validation."
      }
    }
  },

  {
    "id": "EXP-MS-0126",
    "component": "Designing APIs – Resource Ownership",
    "difficulty": "Extreme",
    "question": "Why should a single API avoid representing multiple business domains?",
    "options": {
      "A": "It increases payload size",
      "B": "It blurs ownership and lifecycle management",
      "C": "It reduces throughput",
      "D": "It breaks REST constraints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mixed domains cause unclear ownership and uncontrolled evolution.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Throughput is unrelated.",
        "D": "REST allows multiple resources."
      }
    }
  },
  {
    "id": "EXP-MS-0127",
    "component": "Designing APIs – HTTP Semantics",
    "difficulty": "Extreme",
    "question": "Which method is idempotent but not cacheable by default?",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "DELETE",
      "D": "HEAD"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PUT is idempotent but responses are not cacheable by default.",
      "incorrect": {
        "A": "GET is cacheable.",
        "C": "DELETE responses are typically not cacheable.",
        "D": "HEAD follows GET semantics."
      }
    }
  },
  {
    "id": "EXP-MS-0128",
    "component": "Designing APIs – API-led Governance",
    "difficulty": "Extreme",
    "question": "Which design-time artifact most effectively enforces consistency across APIs?",
    "options": {
      "A": "Runtime dashboards",
      "B": "Reusable RAML libraries",
      "C": "Autoscaling policies",
      "D": "Log aggregations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RAML libraries enforce shared patterns and standards.",
      "incorrect": {
        "A": "Dashboards are operational.",
        "C": "Scaling is infrastructural.",
        "D": "Logs are diagnostic."
      }
    }
  },
  {
    "id": "EXP-MS-0129",
    "component": "Designing APIs – Response Design",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid returning null instead of omitting optional fields?",
    "options": {
      "A": "Null increases payload size",
      "B": "Null creates ambiguity for consumers",
      "C": "Null violates JSON spec",
      "D": "Null breaks caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Null vs absence has different semantic meanings for consumers.",
      "incorrect": {
        "A": "Size difference is negligible.",
        "C": "Null is valid JSON.",
        "D": "Caching is unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0130",
    "component": "Designing APIs – API Boundaries",
    "difficulty": "Extreme",
    "question": "Which change should always trigger consumer notification?",
    "options": {
      "A": "Internal refactoring",
      "B": "Removing response attributes",
      "C": "Performance tuning",
      "D": "Logging enhancement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing response attributes breaks contracts.",
      "incorrect": {
        "A": "Internal refactoring is transparent.",
        "C": "Performance tuning is non-breaking.",
        "D": "Logging is internal."
      }
    }
  },

  {
    "id": "EXP-MS-0131",
    "component": "Designing APIs – Pagination Semantics",
    "difficulty": "Extreme",
    "question": "Why is cursor-based pagination safer for mutable datasets?",
    "options": {
      "A": "It reduces payload size",
      "B": "It avoids inconsistent page results",
      "C": "It simplifies client code",
      "D": "It enforces ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cursors prevent missing or duplicated records during data changes.",
      "incorrect": {
        "A": "Payload size may increase.",
        "C": "Client code is often more complex.",
        "D": "Ordering is independent."
      }
    }
  },
  {
    "id": "EXP-MS-0132",
    "component": "Designing APIs – API Evolution Strategy",
    "difficulty": "Extreme",
    "question": "Which strategy best supports long-lived API consumers?",
    "options": {
      "A": "Frequent breaking releases",
      "B": "Parallel major versions",
      "C": "Silent changes",
      "D": "Immediate deprecation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parallel versions allow safe consumer migration.",
      "incorrect": {
        "A": "Breaking releases cause outages.",
        "C": "Silent changes break trust.",
        "D": "Immediate deprecation is unsafe."
      }
    }
  },
  {
    "id": "EXP-MS-0133",
    "component": "Designing APIs – API Quality Signals",
    "difficulty": "Extreme",
    "question": "Which signal most strongly indicates API misuse?",
    "options": {
      "A": "High traffic volume",
      "B": "Consumers parsing error messages as strings",
      "C": "Stable contracts",
      "D": "Consistent status codes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "String parsing errors indicate poor or inconsistent error modeling.",
      "incorrect": {
        "A": "Traffic volume is not misuse.",
        "C": "Stability is positive.",
        "D": "Consistency is good design."
      }
    }
  },
  {
    "id": "EXP-MS-0134",
    "component": "Designing APIs – API-led Contracts",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid exposing database-generated IDs?",
    "options": {
      "A": "They increase payload size",
      "B": "They tightly couple consumers to backend implementation",
      "C": "They reduce performance",
      "D": "They break caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exposing internal IDs leaks implementation details.",
      "incorrect": {
        "A": "Size is negligible.",
        "C": "Performance is unaffected.",
        "D": "Caching is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0135",
    "component": "Designing APIs – HTTP Semantics",
    "difficulty": "Extreme",
    "question": "Which HTTP method is both unsafe and non-idempotent?",
    "options": {
      "A": "GET",
      "B": "PUT",
      "C": "POST",
      "D": "DELETE"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "POST is unsafe and non-idempotent.",
      "incorrect": {
        "A": "GET is safe.",
        "B": "PUT is idempotent.",
        "D": "DELETE is idempotent."
      }
    }
  },

  {
    "id": "EXP-MS-0136",
    "component": "Designing APIs – API Design Anti-patterns",
    "difficulty": "Extreme",
    "question": "Which pattern most strongly indicates client-driven API design?",
    "options": {
      "A": "Business-oriented resources",
      "B": "Endpoints tailored per client",
      "C": "Reusable Process APIs",
      "D": "Layered abstraction"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client-specific endpoints reduce reuse and increase coupling.",
      "incorrect": {
        "A": "Business resources increase reuse.",
        "C": "Process APIs are reusable.",
        "D": "Layering is good design."
      }
    }
  },
  {
    "id": "EXP-MS-0137",
    "component": "Designing APIs – Contract Consistency",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid overloading field meanings?",
    "options": {
      "A": "It increases payload size",
      "B": "It creates ambiguous client interpretation",
      "C": "It reduces throughput",
      "D": "It violates REST"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ambiguous semantics lead to inconsistent client behavior.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Throughput is unrelated.",
        "D": "REST does not forbid overloading."
      }
    }
  },
  {
    "id": "EXP-MS-0138",
    "component": "Designing APIs – API Governance",
    "difficulty": "Extreme",
    "question": "Which practice best enforces API consistency across teams?",
    "options": {
      "A": "Post-deployment audits",
      "B": "Reusable design standards and templates",
      "C": "Runtime alerts",
      "D": "Manual code reviews only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable standards enforce consistency before implementation.",
      "incorrect": {
        "A": "Audits are reactive.",
        "C": "Alerts are runtime-focused.",
        "D": "Manual reviews do not scale."
      }
    }
  },
  {
    "id": "EXP-MS-0139",
    "component": "Designing APIs – API Documentation",
    "difficulty": "Extreme",
    "question": "Which documentation omission most increases consumer support load?",
    "options": {
      "A": "Missing examples",
      "B": "Missing error descriptions",
      "C": "Missing changelog",
      "D": "Missing performance metrics"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lack of error documentation forces consumers to guess failure handling.",
      "incorrect": {
        "A": "Examples help but are secondary.",
        "C": "Changelog is important but not runtime-critical.",
        "D": "Performance metrics are operational."
      }
    }
  },
  {
    "id": "EXP-MS-0140",
    "component": "Designing APIs – API-led Maturity",
    "difficulty": "Extreme",
    "question": "Which outcome best demonstrates mature API design?",
    "options": {
      "A": "High server utilization",
      "B": "Multiple teams consuming APIs independently",
      "C": "Frequent major versions",
      "D": "Large payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Independent consumption reflects clear contracts and reuse.",
      "incorrect": {
        "A": "Utilization is operational.",
        "C": "Frequent versions indicate instability.",
        "D": "Payload size is irrelevant."
      }
    }
  },

  {
    "id": "EXP-MS-0141",
    "component": "Designing APIs – Finalization",
    "difficulty": "Extreme",
    "question": "Which principle most directly protects API consumers over time?",
    "options": {
      "A": "Frequent enhancements",
      "B": "Backward compatibility",
      "C": "Minimal endpoints",
      "D": "Direct backend exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward compatibility preserves consumer stability.",
      "incorrect": {
        "A": "Enhancements may still break contracts.",
        "C": "Minimal endpoints is not sufficient.",
        "D": "Exposure increases risk."
      }
    }
  },
  {
    "id": "EXP-MS-0142",
    "component": "Designing APIs – Change Management",
    "difficulty": "Extreme",
    "question": "Which change requires the most careful consumer communication?",
    "options": {
      "A": "Logging changes",
      "B": "Removing response attributes",
      "C": "Performance tuning",
      "D": "Internal refactoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing attributes breaks contracts.",
      "incorrect": {
        "A": "Logging is internal.",
        "C": "Performance tuning is transparent.",
        "D": "Refactoring is internal."
      }
    }
  },
  {
    "id": "EXP-MS-0143",
    "component": "Designing APIs – API Boundaries",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid embedding client-specific defaults?",
    "options": {
      "A": "They increase latency",
      "B": "They reduce reuse across consumers",
      "C": "They violate HTTP",
      "D": "They break caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client-specific defaults reduce generality and reuse.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "HTTP allows defaults.",
        "D": "Caching is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0144",
    "component": "Designing APIs – API Stability",
    "difficulty": "Extreme",
    "question": "Which API layer should change least over time?",
    "options": {
      "A": "Experience APIs",
      "B": "Process APIs",
      "C": "System APIs",
      "D": "All equally"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "System APIs abstract backend systems and should be most stable.",
      "incorrect": {
        "A": "Experience APIs evolve with channels.",
        "B": "Process APIs evolve with business.",
        "D": "Stability differs by layer."
      }
    }
  },
  {
    "id": "EXP-MS-0145",
    "component": "Designing APIs – API-led Thinking",
    "difficulty": "Extreme",
    "question": "Why should APIs be designed before implementation?",
    "options": {
      "A": "To speed up coding",
      "B": "To align teams on contracts",
      "C": "To reduce runtime errors",
      "D": "To simplify deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-first ensures shared understanding before building.",
      "incorrect": {
        "A": "Speed is not guaranteed.",
        "C": "Runtime errors still occur.",
        "D": "Deployment remains complex."
      }
    }
  },

  {
    "id": "EXP-MS-0146",
    "component": "Designing APIs – REST Purity",
    "difficulty": "Extreme",
    "question": "Which practice most violates REST principles?",
    "options": {
      "A": "Using HTTP status codes",
      "B": "Verb-based endpoint naming",
      "C": "Stateless requests",
      "D": "Layered architecture"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "REST relies on nouns for resources, not verbs.",
      "incorrect": {
        "A": "Status codes are required.",
        "C": "Statelessness is core REST.",
        "D": "Layering is allowed."
      }
    }
  },
  {
    "id": "EXP-MS-0147",
    "component": "Designing APIs – Error Transparency",
    "difficulty": "Extreme",
    "question": "Why should APIs avoid returning stack traces to clients?",
    "options": {
      "A": "They increase payload size",
      "B": "They leak internal implementation details",
      "C": "They reduce performance",
      "D": "They break RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stack traces expose internals and security risks.",
      "incorrect": {
        "A": "Size is not primary.",
        "C": "Performance impact is minimal.",
        "D": "RAML does not restrict stack traces."
      }
    }
  },
  {
    "id": "EXP-MS-0148",
    "component": "Designing APIs – API-led Quality",
    "difficulty": "Extreme",
    "question": "Which metric best reflects API consumer satisfaction?",
    "options": {
      "A": "Average latency",
      "B": "Reduction in support tickets",
      "C": "Worker utilization",
      "D": "Deployment frequency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fewer support tickets indicate clear and usable APIs.",
      "incorrect": {
        "A": "Latency is operational.",
        "C": "Utilization is infrastructural.",
        "D": "Deployment frequency is delivery-focused."
      }
    }
  },
  {
    "id": "EXP-MS-0149",
    "component": "Designing APIs – Section Integrity",
    "difficulty": "Extreme",
    "question": "Which decision most directly affects API longevity?",
    "options": {
      "A": "Worker sizing",
      "B": "Contract stability",
      "C": "Logging framework",
      "D": "Deployment region"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts preserve long-term consumer compatibility.",
      "incorrect": {
        "A": "Worker sizing is operational.",
        "C": "Logging is internal.",
        "D": "Region does not affect contracts."
      }
    }
  },
  {
    "id": "EXP-MS-0150",
    "component": "Designing APIs – Section Completion",
    "difficulty": "Extreme",
    "question": "What ultimately defines a successful API contract?",
    "options": {
      "A": "Minimal fields",
      "B": "Clear, stable, and reusable semantics",
      "C": "High throughput",
      "D": "Large response payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear, stable semantics enable long-term reuse.",
      "incorrect": {
        "A": "Minimal fields alone are insufficient.",
        "C": "Throughput is operational.",
        "D": "Payload size is not quality."
      }
    }
  },
  {
    "id": "EXP-MS-0151",
    "component": "Accessing Mule Event – Payload Mutation",
    "difficulty": "Extreme",
    "question": "What is the final payload?",
    "code": "<set-payload value=\"{a:1,b:2}\"/>\n<set-payload value=\"payload.a\"/>",
    "options": {
      "A": "{a:1,b:2}",
      "B": "1",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Second set-payload replaces payload with value of key 'a'.",
      "incorrect": {
        "A": "Original payload is overwritten.",
        "C": "Key exists.",
        "D": "Expression is valid."
      }
    }
  },
  {
    "id": "EXP-MS-0152",
    "component": "Accessing Mule Event – Attributes Scope",
    "difficulty": "Extreme",
    "question": "What does this expression return in an HTTP Listener flow?",
    "code": "#[attributes.method]",
    "options": {
      "A": "HTTP verb string",
      "B": "Request URI",
      "C": "Payload",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "attributes.method contains the HTTP method (GET, POST, etc.).",
      "incorrect": {
        "B": "URI is attributes.requestPath.",
        "C": "Payload is accessed via payload.",
        "D": "Expression is valid."
      }
    }
  },
  {
    "id": "EXP-MS-0153",
    "component": "Accessing Mule Event – Variable Shadowing",
    "difficulty": "Extreme",
    "question": "What is logged?",
    "code": "<set-variable variableName=\"x\" value=\"1\"/>\n<foreach collection=\"[10,20]\">\n  <set-variable variableName=\"x\" value=\"payload\"/>\n</foreach>\n<logger message=\"#[vars.x]\"/>",
    "options": {
      "A": "1",
      "B": "10",
      "C": "20",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "foreach has its own event scope; outer variable remains unchanged.",
      "incorrect": {
        "B": "Inner variable does not escape foreach.",
        "C": "Same reason.",
        "D": "Variable exists."
      }
    }
  },
  {
    "id": "EXP-MS-0154",
    "component": "Accessing Mule Event – Variable Lifecycle",
    "difficulty": "Extreme",
    "question": "When is a variable destroyed?",
    "options": {
      "A": "After flow ends",
      "B": "After scope ends",
      "C": "After processor execution",
      "D": "Only on error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Variables live for the entire Mule event lifecycle.",
      "incorrect": {
        "B": "Scopes do not destroy variables.",
        "C": "Processor execution does not affect lifecycle.",
        "D": "Errors do not auto-clear variables."
      }
    }
  },
  {
    "id": "EXP-MS-0155",
    "component": "Accessing Mule Event – Attributes Mutation",
    "difficulty": "Extreme",
    "question": "Can Mule attributes be modified directly?",
    "options": {
      "A": "Yes, using set-attributes",
      "B": "Yes, using DataWeave",
      "C": "No, attributes are immutable",
      "D": "Only inside listeners"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Attributes are immutable in Mule 4.",
      "incorrect": {
        "A": "No such processor exists.",
        "B": "DW cannot mutate attributes.",
        "D": "Immutability applies everywhere."
      }
    }
  },

  {
    "id": "EXP-MS-0156",
    "component": "Accessing Mule Event – Target Variable",
    "difficulty": "Extreme",
    "question": "What is stored in vars.result?",
    "code": "<db:select target=\"result\"/>",
    "options": {
      "A": "Payload",
      "B": "DB result only",
      "C": "Attributes",
      "D": "Entire Mule event"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Target captures the operation output without altering payload.",
      "incorrect": {
        "A": "Payload remains unchanged.",
        "C": "Attributes are separate.",
        "D": "Only operation output is stored."
      }
    }
  },
  {
    "id": "EXP-MS-0157",
    "component": "Accessing Mule Event – Payload Replacement",
    "difficulty": "Extreme",
    "question": "What happens if a connector has no target attribute?",
    "options": {
      "A": "Payload is preserved",
      "B": "Payload is replaced",
      "C": "Error is thrown",
      "D": "Result is ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connector output replaces payload by default.",
      "incorrect": {
        "A": "Preservation requires target.",
        "C": "No error occurs.",
        "D": "Result is not ignored."
      }
    }
  },
  {
    "id": "EXP-MS-0158",
    "component": "Accessing Mule Event – DataWeave Context",
    "difficulty": "Extreme",
    "question": "What does #[payload ++ vars.x] require?",
    "options": {
      "A": "Both must be arrays or strings",
      "B": "vars.x must be numeric",
      "C": "payload must be object",
      "D": "Implicit casting"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "++ concatenates compatible types only.",
      "incorrect": {
        "B": "Numeric addition uses +.",
        "C": "Objects require merge operator.",
        "D": "No implicit casting."
      }
    }
  },
  {
    "id": "EXP-MS-0159",
    "component": "Accessing Mule Event – Event Isolation",
    "difficulty": "Extreme",
    "question": "Which scope creates a new Mule event copy?",
    "options": {
      "A": "Flow-ref",
      "B": "Try",
      "C": "Async",
      "D": "Choice"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async processes a copy of the Mule event.",
      "incorrect": {
        "A": "flow-ref passes same event.",
        "B": "Try shares event.",
        "D": "Choice branches same event."
      }
    }
  },
  {
    "id": "EXP-MS-0160",
    "component": "Accessing Mule Event – FlowRef Behavior",
    "difficulty": "Extreme",
    "question": "What does a flow-ref return?",
    "options": {
      "A": "Original payload",
      "B": "Modified event from referenced flow",
      "C": "Only attributes",
      "D": "Nothing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref returns the modified Mule event.",
      "incorrect": {
        "A": "Payload may change.",
        "C": "Attributes are part of event.",
        "D": "It always returns."
      }
    }
  },

  {
    "id": "EXP-MS-0161",
    "component": "Accessing Mule Event – Variable Access",
    "difficulty": "Extreme",
    "question": "Which expression safely accesses a missing variable?",
    "options": {
      "A": "vars.x",
      "B": "vars.x!",
      "C": "vars.x default 0",
      "D": "vars['x']!"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "default prevents null dereference.",
      "incorrect": {
        "A": "Returns null.",
        "B": "Throws error.",
        "D": "Still throws error."
      }
    }
  },
  {
    "id": "EXP-MS-0162",
    "component": "Accessing Mule Event – Payload Streaming",
    "difficulty": "Extreme",
    "question": "What happens if a streaming payload is read twice?",
    "options": {
      "A": "Both reads succeed",
      "B": "Second read is empty",
      "C": "Automatic rewind",
      "D": "Implicit caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming payloads are consumable once unless cached.",
      "incorrect": {
        "A": "Only one read allowed.",
        "C": "No rewind.",
        "D": "Caching must be explicit."
      }
    }
  },
  {
    "id": "EXP-MS-0163",
    "component": "Accessing Mule Event – Target + Foreach",
    "difficulty": "Extreme",
    "question": "Where is target variable stored inside foreach?",
    "options": {
      "A": "Shared scope",
      "B": "Iteration event only",
      "C": "Flow scope",
      "D": "Global scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each foreach iteration has its own event.",
      "incorrect": {
        "A": "No shared mutation.",
        "C": "Flow scope is outer.",
        "D": "No global scope exists."
      }
    }
  },
  {
    "id": "EXP-MS-0164",
    "component": "Accessing Mule Event – Event Mutation Order",
    "difficulty": "Extreme",
    "question": "Which is evaluated first in a processor?",
    "options": {
      "A": "Target",
      "B": "Attributes",
      "C": "Payload",
      "D": "Configuration"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Configuration is resolved before execution.",
      "incorrect": {
        "A": "Target is post-execution.",
        "B": "Attributes are output.",
        "C": "Payload is output."
      }
    }
  },
  {
    "id": "EXP-MS-0165",
    "component": "Accessing Mule Event – DW Output Directive",
    "difficulty": "Extreme",
    "question": "What happens if DW output type mismatches connector expectation?",
    "options": {
      "A": "Implicit conversion",
      "B": "Runtime error",
      "C": "Payload ignored",
      "D": "Warning only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Type mismatch causes runtime failure.",
      "incorrect": {
        "A": "No implicit conversion.",
        "C": "Payload is not ignored.",
        "D": "Warnings are insufficient."
      }
    }
  },

  {
    "id": "EXP-MS-0166",
    "component": "Accessing Mule Event – Immutable Event Model",
    "difficulty": "Extreme",
    "question": "Why does Mule create a new event on mutation?",
    "options": {
      "A": "Performance",
      "B": "Thread safety",
      "C": "Backward compatibility",
      "D": "Logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures thread safety.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Not related.",
        "D": "Logging is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0167",
    "component": "Accessing Mule Event – Variable Overwrite",
    "difficulty": "Extreme",
    "question": "What happens when set-variable is called twice with same name?",
    "options": {
      "A": "Error",
      "B": "Merge values",
      "C": "Overwrite previous value",
      "D": "Ignore second"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Variables are overwritten by name.",
      "incorrect": {
        "A": "No error.",
        "B": "No merge occurs.",
        "D": "Second always applies."
      }
    }
  },
  {
    "id": "EXP-MS-0168",
    "component": "Accessing Mule Event – DW Context Objects",
    "difficulty": "Extreme",
    "question": "Which context object exposes inbound headers?",
    "options": {
      "A": "payload",
      "B": "vars",
      "C": "attributes.headers",
      "D": "flowVars"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Inbound headers are in attributes.headers.",
      "incorrect": {
        "A": "Payload is body.",
        "B": "vars are user-defined.",
        "D": "flowVars is Mule 3."
      }
    }
  },
  {
    "id": "EXP-MS-0169",
    "component": "Accessing Mule Event – DW Null Handling",
    "difficulty": "Extreme",
    "question": "What does payload.foo return if foo does not exist?",
    "options": {
      "A": "Error",
      "B": "null",
      "C": "Empty string",
      "D": "false"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Missing keys return null in DW.",
      "incorrect": {
        "A": "No error thrown.",
        "C": "Not coerced.",
        "D": "Boolean not inferred."
      }
    }
  },
  {
    "id": "EXP-MS-0170",
    "component": "Accessing Mule Event – End of Chunk",
    "difficulty": "Extreme",
    "question": "Which construct guarantees payload preservation?",
    "options": {
      "A": "Using target attribute",
      "B": "Using set-payload",
      "C": "Using foreach",
      "D": "Using async"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Target prevents payload overwrite.",
      "incorrect": {
        "B": "set-payload replaces payload.",
        "C": "foreach mutates event.",
        "D": "async copies event."
      }
    }
  },
  {
    "id": "EXP-MS-0171",
    "component": "Accessing Mule Event – Attributes vs Payload",
    "difficulty": "Extreme",
    "question": "What is the result of the logger?",
    "code": "<http:listener />\n<set-payload value=\"attributes.method\"/>\n<logger message=\"#[payload]\"/>",
    "options": {
      "A": "Original request body",
      "B": "HTTP method string",
      "C": "Null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "attributes.method is resolved and becomes the new payload.",
      "incorrect": {
        "A": "Payload is overwritten.",
        "C": "Attribute exists.",
        "D": "Expression is valid."
      }
    }
  },
  {
    "id": "EXP-MS-0172",
    "component": "Accessing Mule Event – Variable vs Payload",
    "difficulty": "Extreme",
    "question": "What is the final payload?",
    "code": "<set-variable variableName=\"x\" value=\"payload\"/>\n<set-payload value=\"vars.x\"/>",
    "options": {
      "A": "Original payload",
      "B": "null",
      "C": "Variable name",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "vars.x stores original payload and is restored.",
      "incorrect": {
        "B": "Variable exists.",
        "C": "Variable value is payload.",
        "D": "Valid expressions."
      }
    }
  },
  {
    "id": "EXP-MS-0173",
    "component": "Accessing Mule Event – Foreach Payload",
    "difficulty": "Extreme",
    "question": "What is logged?",
    "code": "<set-payload value=\"[1,2,3]\"/>\n<foreach>\n  <logger message=\"#[payload]\"/>\n</foreach>",
    "options": {
      "A": "[1,2,3]",
      "B": "1,2,3",
      "C": "Each element separately",
      "D": "Error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "foreach iterates and payload becomes each element.",
      "incorrect": {
        "A": "Collection is split.",
        "B": "Not concatenated.",
        "D": "Valid behavior."
      }
    }
  },
  {
    "id": "EXP-MS-0174",
    "component": "Accessing Mule Event – Variable Scope",
    "difficulty": "Extreme",
    "question": "What is vars.sum after foreach?",
    "code": "<set-variable variableName=\"sum\" value=\"0\"/>\n<foreach collection=\"[1,2]\">\n  <set-variable variableName=\"sum\" value=\"vars.sum + payload\"/>\n</foreach>",
    "options": {
      "A": "0",
      "B": "1",
      "C": "3",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "foreach uses child event; outer variable is unchanged.",
      "incorrect": {
        "B": "Inner mutation does not propagate.",
        "C": "Same reason.",
        "D": "Expressions are valid."
      }
    }
  },
  {
    "id": "EXP-MS-0175",
    "component": "Accessing Mule Event – DW Variable Default",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nvars.missing default 5",
    "options": {
      "A": "null",
      "B": "0",
      "C": "5",
      "D": "Error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "default operator supplies fallback value.",
      "incorrect": {
        "A": "default overrides null.",
        "B": "No numeric coercion.",
        "D": "Expression is valid."
      }
    }
  },

  {
    "id": "EXP-MS-0176",
    "component": "Accessing Mule Event – Target + Async",
    "difficulty": "Extreme",
    "question": "What happens to vars.outside?",
    "code": "<set-variable variableName=\"outside\" value=\"1\"/>\n<async>\n  <set-variable variableName=\"outside\" value=\"2\"/>\n</async>",
    "options": {
      "A": "Becomes 2",
      "B": "Remains 1",
      "C": "Null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "async uses a copy of the Mule event.",
      "incorrect": {
        "A": "Changes do not propagate.",
        "C": "Variable exists.",
        "D": "No error."
      }
    }
  },
  {
    "id": "EXP-MS-0177",
    "component": "Accessing Mule Event – Choice Scope",
    "difficulty": "Extreme",
    "question": "Which payload is returned?",
    "code": "<choice>\n  <when expression=\"true\">\n    <set-payload value=\"1\"/>\n  </when>\n  <otherwise>\n    <set-payload value=\"2\"/>\n  </otherwise>\n</choice>",
    "options": {
      "A": "1",
      "B": "2",
      "C": "Original payload",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "when condition evaluates true.",
      "incorrect": {
        "B": "Otherwise is skipped.",
        "C": "Payload is overwritten.",
        "D": "Valid flow."
      }
    }
  },
  {
    "id": "EXP-MS-0178",
    "component": "Accessing Mule Event – FlowRef Mutation",
    "difficulty": "Extreme",
    "question": "What payload is returned from flow-ref?",
    "code": "<flow-ref name=\"childFlow\"/>\n\n<flow name=\"childFlow\">\n  <set-payload value=\"'child'\"/>\n</flow>",
    "options": {
      "A": "Original payload",
      "B": "child",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref returns modified event.",
      "incorrect": {
        "A": "Payload is overwritten.",
        "C": "Payload exists.",
        "D": "Valid flow."
      }
    }
  },
  {
    "id": "EXP-MS-0179",
    "component": "Accessing Mule Event – DW Object Merge",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n{a:1} ++ {b:2}",
    "options": {
      "A": "{a:1,b:2}",
      "B": "{b:2}",
      "C": "Error",
      "D": "[1,2]"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "++ merges objects.",
      "incorrect": {
        "B": "No overwrite occurs.",
        "C": "Valid operation.",
        "D": "Not arrays."
      }
    }
  },
  {
    "id": "EXP-MS-0180",
    "component": "Accessing Mule Event – DW Array Flatten",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nflatten([[1],[2,3]])",
    "options": {
      "A": "[[1],[2,3]]",
      "B": "[1,2,3]",
      "C": "[1,[2,3]]",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flatten removes nested arrays.",
      "incorrect": {
        "A": "Flatten changes structure.",
        "C": "Fully flattened.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0181",
    "component": "Accessing Mule Event – DW Coercion",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n\"5\" as Number",
    "options": {
      "A": "5",
      "B": "\"5\"",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "String is coerced to number.",
      "incorrect": {
        "B": "Type changed.",
        "C": "Valid coercion.",
        "D": "No error."
      }
    }
  },
  {
    "id": "EXP-MS-0182",
    "component": "Accessing Mule Event – DW Failures",
    "difficulty": "Extreme",
    "question": "What happens?",
    "code": "%dw 2.0\noutput application/json\n---\n\"abc\" as Number",
    "options": {
      "A": "0",
      "B": "null",
      "C": "Error",
      "D": "NaN"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Invalid coercion throws runtime error.",
      "incorrect": {
        "A": "No implicit default.",
        "B": "Not null-safe.",
        "D": "NaN is not returned."
      }
    }
  },
  {
    "id": "EXP-MS-0183",
    "component": "Accessing Mule Event – DW Call Flow",
    "difficulty": "Extreme",
    "question": "What is required to call a flow from DW?",
    "options": {
      "A": "flow-ref only",
      "B": "lookup() function",
      "C": "External module import",
      "D": "Direct invocation unsupported"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "lookup() enables calling flows from DW.",
      "incorrect": {
        "A": "flow-ref is outside DW.",
        "C": "Modules are optional.",
        "D": "DW supports lookup."
      }
    }
  },
  {
    "id": "EXP-MS-0184",
    "component": "Accessing Mule Event – Event Propagation",
    "difficulty": "Extreme",
    "question": "Which scope preserves event changes downstream?",
    "options": {
      "A": "Async",
      "B": "Scatter-Gather",
      "C": "Flow-ref",
      "D": "Parallel For Each"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "flow-ref propagates the same event.",
      "incorrect": {
        "A": "Async isolates event.",
        "B": "Routes copy events.",
        "D": "Parallel foreach copies."
      }
    }
  },
  {
    "id": "EXP-MS-0185",
    "component": "Accessing Mule Event – Payload Reset",
    "difficulty": "Extreme",
    "question": "How do you restore original payload after connector execution?",
    "options": {
      "A": "set-payload",
      "B": "target attribute",
      "C": "try scope",
      "D": "choice scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Target preserves payload.",
      "incorrect": {
        "A": "set-payload overwrites.",
        "C": "try does not restore.",
        "D": "choice is conditional."
      }
    }
  },

  {
    "id": "EXP-MS-0186",
    "component": "Accessing Mule Event – DW Lazy Eval",
    "difficulty": "Extreme",
    "question": "Why are DW expressions lazily evaluated?",
    "options": {
      "A": "To improve performance",
      "B": "To reduce memory",
      "C": "To avoid unnecessary computation",
      "D": "All of the above"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Lazy evaluation improves performance and resource usage.",
      "incorrect": {
        "A": "Partial reason.",
        "B": "Partial reason.",
        "C": "Partial reason."
      }
    }
  },
  {
    "id": "EXP-MS-0187",
    "component": "Accessing Mule Event – DW Short Circuit",
    "difficulty": "Extreme",
    "question": "What happens?",
    "code": "%dw 2.0\noutput application/json\n---\nfalse and (1/0)",
    "options": {
      "A": "Error",
      "B": "false",
      "C": "null",
      "D": "true"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short-circuit prevents division execution.",
      "incorrect": {
        "A": "Expression not evaluated.",
        "C": "Boolean result.",
        "D": "Incorrect logic."
      }
    }
  },
  {
    "id": "EXP-MS-0188",
    "component": "Accessing Mule Event – DW Filter",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[1,2,3] filter ($ > 1)",
    "options": {
      "A": "[1]",
      "B": "[2,3]",
      "C": "[1,2,3]",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filter keeps values > 1.",
      "incorrect": {
        "A": "1 is excluded.",
        "C": "Filter applied.",
        "D": "Valid expression."
      }
    }
  },
  {
    "id": "EXP-MS-0189",
    "component": "Accessing Mule Event – End Scope",
    "difficulty": "Extreme",
    "question": "Which processor finalizes the Mule event?",
    "options": {
      "A": "Logger",
      "B": "Last processor in flow",
      "C": "Flow-ref",
      "D": "Choice"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The last processor defines final event state.",
      "incorrect": {
        "A": "Logger is passive.",
        "C": "Flow-ref continues flow.",
        "D": "Choice branches."
      }
    }
  },
  {
    "id": "EXP-MS-0190",
    "component": "Accessing Mule Event – Chunk Completion",
    "difficulty": "Extreme",
    "question": "What guarantees immutability in Mule 4 events?",
    "options": {
      "A": "Thread pools",
      "B": "Copy-on-write event model",
      "C": "Flow scopes",
      "D": "Streaming payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mule 4 uses copy-on-write for immutability.",
      "incorrect": {
        "A": "Thread pools are unrelated.",
        "C": "Scopes do not guarantee immutability.",
        "D": "Streaming affects payload only."
      }
    }
  },
  {
    "id": "EXP-MS-0191",
    "component": "Accessing Mule Event – DW Object Access",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n({a:{b:2}}).a.b",
    "options": {
      "A": "2",
      "B": "{b:2}",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Nested object access resolves correctly.",
      "incorrect": {
        "B": "b is dereferenced.",
        "C": "Key exists.",
        "D": "Valid access."
      }
    }
  },
  {
    "id": "EXP-MS-0192",
    "component": "Accessing Mule Event – DW Safe Navigation",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n({}).a?.b default 9",
    "options": {
      "A": "null",
      "B": "9",
      "C": "Error",
      "D": "{}"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation prevents error; default applies.",
      "incorrect": {
        "A": "default overrides null.",
        "C": "Safe operator prevents error.",
        "D": "Incorrect type."
      }
    }
  },
  {
    "id": "EXP-MS-0193",
    "component": "Accessing Mule Event – Attributes Headers",
    "difficulty": "Extreme",
    "question": "Which expression retrieves a header named X-ID?",
    "options": {
      "A": "payload.headers.X-ID",
      "B": "vars.headers.'X-ID'",
      "C": "attributes.headers.'X-ID'",
      "D": "attributes.X-ID"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Inbound headers live under attributes.headers.",
      "incorrect": {
        "A": "Payload does not contain headers.",
        "B": "vars are user-defined.",
        "D": "Invalid syntax."
      }
    }
  },
  {
    "id": "EXP-MS-0194",
    "component": "Accessing Mule Event – DW map",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[1,2,3] map ($ * 2)",
    "options": {
      "A": "[1,2,3]",
      "B": "[2,4,6]",
      "C": "[2,3,4]",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "map transforms each element.",
      "incorrect": {
        "A": "No transformation.",
        "C": "Incorrect arithmetic.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0195",
    "component": "Accessing Mule Event – DW reduce",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[1,2,3] reduce ($$ + $)",
    "options": {
      "A": "6",
      "B": "[6]",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "reduce aggregates values.",
      "incorrect": {
        "B": "Scalar result.",
        "C": "Valid function.",
        "D": "No null."
      }
    }
  },

  {
    "id": "EXP-MS-0196",
    "component": "Accessing Mule Event – Variable Mutation Order",
    "difficulty": "Extreme",
    "question": "What is vars.x?",
    "code": "<set-variable variableName=\"x\" value=\"1\"/>\n<set-variable variableName=\"x\" value=\"vars.x + 1\"/>",
    "options": {
      "A": "1",
      "B": "2",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Second set-variable overwrites using previous value.",
      "incorrect": {
        "A": "Overwritten.",
        "C": "Variable exists.",
        "D": "Valid expressions."
      }
    }
  },
  {
    "id": "EXP-MS-0197",
    "component": "Accessing Mule Event – Choice Fallthrough",
    "difficulty": "Extreme",
    "question": "What happens if no when matches and no otherwise exists?",
    "options": {
      "A": "Error",
      "B": "Payload cleared",
      "C": "Event continues unchanged",
      "D": "Flow stops"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Choice does nothing if no branch matches.",
      "incorrect": {
        "A": "No error.",
        "B": "Payload preserved.",
        "D": "Flow continues."
      }
    }
  },
  {
    "id": "EXP-MS-0198",
    "component": "Accessing Mule Event – Foreach Return",
    "difficulty": "Extreme",
    "question": "What is the payload after foreach?",
    "code": "<set-payload value=\"[1,2]\"/>\n<foreach>\n  <set-payload value=\"payload * 2\"/>\n</foreach>",
    "options": {
      "A": "[1,2]",
      "B": "[2,4]",
      "C": "2",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "foreach restores original payload.",
      "incorrect": {
        "B": "foreach does not aggregate.",
        "C": "Iteration payload not returned.",
        "D": "Valid flow."
      }
    }
  },
  {
    "id": "EXP-MS-0199",
    "component": "Accessing Mule Event – Scatter-Gather",
    "difficulty": "Extreme",
    "question": "What is the payload after scatter-gather?",
    "options": {
      "A": "Single object",
      "B": "Last route payload",
      "C": "Array of route results",
      "D": "Original payload"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "scatter-gather aggregates results.",
      "incorrect": {
        "A": "Multiple routes.",
        "B": "All results returned.",
        "D": "Payload replaced."
      }
    }
  },
  {
    "id": "EXP-MS-0200",
    "component": "Accessing Mule Event – Parallel For Each",
    "difficulty": "Extreme",
    "question": "Why is variable mutation unsafe in parallel foreach?",
    "options": {
      "A": "Variables are immutable",
      "B": "Race conditions",
      "C": "Variables are shared",
      "D": "Compilation error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parallel execution causes race conditions.",
      "incorrect": {
        "A": "Variables are mutable.",
        "C": "Events are copied.",
        "D": "No compilation error."
      }
    }
  },

  {
    "id": "EXP-MS-0201",
    "component": "Accessing Mule Event – Streaming Strategy",
    "difficulty": "Extreme",
    "question": "Which processor forces stream caching?",
    "options": {
      "A": "Logger",
      "B": "Object Store",
      "C": "Transform Message",
      "D": "Set Payload"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Transform Message consumes and caches streams.",
      "incorrect": {
        "A": "Logger may not consume.",
        "B": "Not automatic.",
        "D": "May not consume."
      }
    }
  },
  {
    "id": "EXP-MS-0202",
    "component": "Accessing Mule Event – DW sizeOf",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nsizeOf({a:1,b:2})",
    "options": {
      "A": "1",
      "B": "2",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf counts object keys.",
      "incorrect": {
        "A": "Two keys exist.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0203",
    "component": "Accessing Mule Event – DW distinctBy",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[{a:1},{a:1},{a:2}] distinctBy $.a",
    "options": {
      "A": "[{a:1},{a:2}]",
      "B": "[{a:1},{a:1},{a:2}]",
      "C": "Error",
      "D": "[1,2]"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "distinctBy removes duplicates by key.",
      "incorrect": {
        "B": "Duplicates removed.",
        "C": "Valid function.",
        "D": "Returns objects."
      }
    }
  },
  {
    "id": "EXP-MS-0204",
    "component": "Accessing Mule Event – DW orderBy",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[3,1,2] orderBy $",
    "options": {
      "A": "[3,1,2]",
      "B": "[1,2,3]",
      "C": "Error",
      "D": "[2,1,3]"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "orderBy sorts ascending by default.",
      "incorrect": {
        "A": "Sorting applied.",
        "C": "Valid function.",
        "D": "Incorrect order."
      }
    }
  },
  {
    "id": "EXP-MS-0205",
    "component": "Accessing Mule Event – DW keysOf",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nkeysOf({x:1,y:2})",
    "options": {
      "A": "[1,2]",
      "B": "[\"x\",\"y\"]",
      "C": "{x,y}",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "keysOf returns object keys.",
      "incorrect": {
        "A": "Values are not returned.",
        "C": "Invalid format.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0206",
    "component": "Accessing Mule Event – Event Completion",
    "difficulty": "Extreme",
    "question": "Which element determines final HTTP response?",
    "options": {
      "A": "First processor",
      "B": "Last processor",
      "C": "Listener config",
      "D": "Global error handler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Last processor defines response payload.",
      "incorrect": {
        "A": "Initial only.",
        "C": "Listener initializes.",
        "D": "Only on error."
      }
    }
  },
  {
    "id": "EXP-MS-0207",
    "component": "Accessing Mule Event – Variable Nullability",
    "difficulty": "Extreme",
    "question": "What is vars.x if never set?",
    "options": {
      "A": "0",
      "B": "null",
      "C": "Error",
      "D": "undefined"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unset variables resolve to null.",
      "incorrect": {
        "A": "No default.",
        "C": "No error.",
        "D": "Not JavaScript."
      }
    }
  },
  {
    "id": "EXP-MS-0208",
    "component": "Accessing Mule Event – DW isEmpty",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nisEmpty([])",
    "options": {
      "A": "true",
      "B": "false",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Empty array returns true.",
      "incorrect": {
        "B": "Array has no elements.",
        "C": "Boolean returned.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0209",
    "component": "Accessing Mule Event – DW contains",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[1,2,3] contains 2",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "contains checks membership.",
      "incorrect": {
        "B": "2 exists.",
        "C": "Valid expression.",
        "D": "Boolean returned."
      }
    }
  },
  {
    "id": "EXP-MS-0210",
    "component": "Accessing Mule Event – Chunk Progress",
    "difficulty": "Extreme",
    "question": "Why does Mule discourage mutable shared state?",
    "options": {
      "A": "Memory usage",
      "B": "Thread safety",
      "C": "Performance",
      "D": "Serialization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Concurrency requires immutability for safety.",
      "incorrect": {
        "A": "Secondary concern.",
        "C": "Indirect.",
        "D": "Not primary."
      }
    }
  },

  {
    "id": "EXP-MS-0211",
    "component": "Accessing Mule Event – DW trim",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\ntrim(\" a \")",
    "options": {
      "A": "\" a \"",
      "B": "\"a\"",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "trim removes leading/trailing whitespace.",
      "incorrect": {
        "A": "Whitespace removed.",
        "C": "String exists.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0212",
    "component": "Accessing Mule Event – DW upper",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nupper(\"mule\")",
    "options": {
      "A": "\"mule\"",
      "B": "\"MULE\"",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "upper converts string to uppercase.",
      "incorrect": {
        "A": "Case changed.",
        "C": "String exists.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0213",
    "component": "Accessing Mule Event – DW split",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nsplit(\"a,b\", \",\")",
    "options": {
      "A": "[\"a,b\"]",
      "B": "[\"a\",\"b\"]",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "split tokenizes string.",
      "incorrect": {
        "A": "Delimiter applied.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0214",
    "component": "Accessing Mule Event – DW joinBy",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n[\"a\",\"b\"] joinBy \",\"",
    "options": {
      "A": "\"a,b\"",
      "B": "[\"a,b\"]",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "joinBy concatenates array into string.",
      "incorrect": {
        "B": "Returns string.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0215",
    "component": "Accessing Mule Event – DW now()",
    "difficulty": "Extreme",
    "question": "What type does now() return?",
    "options": {
      "A": "String",
      "B": "DateTime",
      "C": "Number",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "now() returns DateTime.",
      "incorrect": {
        "A": "Not string.",
        "C": "Not numeric.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0216",
    "component": "Accessing Mule Event – DW typeOf",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\ntypeOf(1)",
    "options": {
      "A": "\"Number\"",
      "B": "Number",
      "C": "1",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "typeOf returns type name as string.",
      "incorrect": {
        "B": "String returned.",
        "C": "Not value.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0217",
    "component": "Accessing Mule Event – DW sizeOf String",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nsizeOf(\"abc\")",
    "options": {
      "A": "3",
      "B": "\"3\"",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "sizeOf returns length.",
      "incorrect": {
        "B": "Returns number.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0218",
    "component": "Accessing Mule Event – DW substring",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nsubstring(\"abcd\",1,2)",
    "options": {
      "A": "\"ab\"",
      "B": "\"bc\"",
      "C": "\"cd\"",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Substring starts at index 1.",
      "incorrect": {
        "A": "Index incorrect.",
        "C": "Length incorrect.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0219",
    "component": "Accessing Mule Event – DW abs",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nabs(-5)",
    "options": {
      "A": "-5",
      "B": "5",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "abs returns absolute value.",
      "incorrect": {
        "A": "Negation applied.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0220",
    "component": "Accessing Mule Event – DW avg",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\navg([2,4])",
    "options": {
      "A": "2",
      "B": "3",
      "C": "4",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Average of 2 and 4 is 3.",
      "incorrect": {
        "A": "Incorrect calculation.",
        "C": "Incorrect.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0221",
    "component": "Accessing Mule Event – DW ceil",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nceil(2.1)",
    "options": {
      "A": "2",
      "B": "3",
      "C": "2.1",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ceil rounds up.",
      "incorrect": {
        "A": "Floor rounds down.",
        "C": "Rounded.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0222",
    "component": "Accessing Mule Event – DW floor",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nfloor(2.9)",
    "options": {
      "A": "2",
      "B": "3",
      "C": "2.9",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "floor rounds down.",
      "incorrect": {
        "B": "ceil rounds up.",
        "C": "Rounded.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0223",
    "component": "Accessing Mule Event – DW round",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nround(2.5)",
    "options": {
      "A": "2",
      "B": "3",
      "C": "2.5",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "round rounds to nearest integer.",
      "incorrect": {
        "A": "Rounded up.",
        "C": "Rounded.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0224",
    "component": "Accessing Mule Event – DW min",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nmin([3,1,2])",
    "options": {
      "A": "1",
      "B": "2",
      "C": "3",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "min returns smallest value.",
      "incorrect": {
        "B": "Incorrect.",
        "C": "Incorrect.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0225",
    "component": "Accessing Mule Event – DW max",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nmax([3,1,2])",
    "options": {
      "A": "1",
      "B": "2",
      "C": "3",
      "D": "Error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "max returns largest value.",
      "incorrect": {
        "A": "Incorrect.",
        "B": "Incorrect.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0226",
    "component": "Accessing Mule Event – DW sum",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nsum([1,2,3])",
    "options": {
      "A": "6",
      "B": "[6]",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "sum adds values.",
      "incorrect": {
        "B": "Scalar result.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0227",
    "component": "Accessing Mule Event – DW contains Object",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\n{a:1} contains \"a\"",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "contains checks key presence in object.",
      "incorrect": {
        "B": "Key exists.",
        "C": "Valid function.",
        "D": "Boolean returned."
      }
    }
  },
  {
    "id": "EXP-MS-0228",
    "component": "Accessing Mule Event – DW startsWith",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nstartsWith(\"mule\",\"mu\")",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "String starts with prefix.",
      "incorrect": {
        "B": "Prefix exists.",
        "C": "Valid function.",
        "D": "Boolean returned."
      }
    }
  },
  {
    "id": "EXP-MS-0229",
    "component": "Accessing Mule Event – DW endsWith",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nendsWith(\"mule\",\"le\")",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "String ends with suffix.",
      "incorrect": {
        "B": "Suffix exists.",
        "C": "Valid function.",
        "D": "Boolean returned."
      }
    }
  },
  {
    "id": "EXP-MS-0230",
    "component": "Accessing Mule Event – DW replace",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nreplace(\"abc\",\"b\",\"x\")",
    "options": {
      "A": "\"axc\"",
      "B": "\"abc\"",
      "C": "Error",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "replace substitutes matching substring.",
      "incorrect": {
        "B": "Replacement occurred.",
        "C": "Valid function.",
        "D": "Not null."
      }
    }
  },

  {
    "id": "EXP-MS-0231",
    "component": "Accessing Mule Event – DW scan",
    "difficulty": "Extreme",
    "question": "What does scan primarily do?",
    "options": {
      "A": "Filter elements",
      "B": "Accumulate intermediate results",
      "C": "Sort collection",
      "D": "Flatten arrays"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "scan returns intermediate accumulations.",
      "incorrect": {
        "A": "filter removes elements.",
        "C": "orderBy sorts.",
        "D": "flatten flattens."
      }
    }
  },
  {
    "id": "EXP-MS-0232",
    "component": "Accessing Mule Event – DW groupBy",
    "difficulty": "Extreme",
    "question": "What does groupBy return?",
    "options": {
      "A": "Array",
      "B": "Object",
      "C": "String",
      "D": "Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "groupBy produces an object keyed by grouping.",
      "incorrect": {
        "A": "Array not returned.",
        "C": "Not string.",
        "D": "Not boolean."
      }
    }
  },
  {
    "id": "EXP-MS-0233",
    "component": "Accessing Mule Event – DW entriesOf",
    "difficulty": "Extreme",
    "question": "What does entriesOf return?",
    "options": {
      "A": "Array of values",
      "B": "Array of key-value pairs",
      "C": "Object",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "entriesOf converts object to array entries.",
      "incorrect": {
        "A": "Keys included.",
        "C": "Array returned.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0234",
    "component": "Accessing Mule Event – DW valuesOf",
    "difficulty": "Extreme",
    "question": "What does valuesOf return?",
    "options": {
      "A": "Keys",
      "B": "Values",
      "C": "Entries",
      "D": "Object"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "valuesOf extracts object values.",
      "incorrect": {
        "A": "keysOf extracts keys.",
        "C": "entriesOf returns entries.",
        "D": "Array returned."
      }
    }
  },
  {
    "id": "EXP-MS-0235",
    "component": "Accessing Mule Event – DW zip",
    "difficulty": "Extreme",
    "question": "What does zip do?",
    "options": {
      "A": "Merge objects",
      "B": "Combine arrays by index",
      "C": "Flatten arrays",
      "D": "Sort arrays"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "zip pairs array elements by index.",
      "incorrect": {
        "A": "Object merge uses ++.",
        "C": "flatten flattens.",
        "D": "orderBy sorts."
      }
    }
  },

  {
    "id": "EXP-MS-0236",
    "component": "Accessing Mule Event – DW indexOf",
    "difficulty": "Extreme",
    "question": "What is returned if value is not found?",
    "options": {
      "A": "-1",
      "B": "null",
      "C": "Error",
      "D": "false"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "indexOf returns null if not found.",
      "incorrect": {
        "A": "JavaScript behavior, not DW.",
        "C": "No error.",
        "D": "Boolean not returned."
      }
    }
  },
  {
    "id": "EXP-MS-0237",
    "component": "Accessing Mule Event – DW find",
    "difficulty": "Extreme",
    "question": "What does find return?",
    "options": {
      "A": "Boolean",
      "B": "First matching element",
      "C": "All matching elements",
      "D": "Index"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "find returns first match.",
      "incorrect": {
        "A": "contains returns boolean.",
        "C": "filter returns all.",
        "D": "indexOf returns index."
      }
    }
  },
  {
    "id": "EXP-MS-0238",
    "component": "Accessing Mule Event – DW some",
    "difficulty": "Extreme",
    "question": "What does some return?",
    "options": {
      "A": "All elements",
      "B": "Boolean if any match",
      "C": "First element",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "some checks if any element matches.",
      "incorrect": {
        "A": "every checks all.",
        "C": "find returns element.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0239",
    "component": "Accessing Mule Event – DW every",
    "difficulty": "Extreme",
    "question": "What does every return?",
    "options": {
      "A": "Boolean if all match",
      "B": "First element",
      "C": "Index",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "every checks all elements.",
      "incorrect": {
        "B": "find returns element.",
        "C": "indexOf returns index.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0240",
    "component": "Accessing Mule Event – DW flatten Deep",
    "difficulty": "Extreme",
    "question": "flatten([[1,[2]]]) returns?",
    "options": {
      "A": "[1,[2]]",
      "B": "[1,2]",
      "C": "[[1,2]]",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flatten removes nested arrays recursively.",
      "incorrect": {
        "A": "Fully flattened.",
        "C": "Incorrect nesting.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0241",
    "component": "Accessing Mule Event – DW default chaining",
    "difficulty": "Extreme",
    "question": "What is the output?",
    "code": "%dw 2.0\noutput application/json\n---\nvars.x default vars.y default 7",
    "options": {
      "A": "null",
      "B": "vars.y",
      "C": "7",
      "D": "Error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Defaults evaluated left to right.",
      "incorrect": {
        "A": "Fallback exists.",
        "B": "vars.y is null.",
        "D": "Valid expression."
      }
    }
  },
  {
    "id": "EXP-MS-0242",
    "component": "Accessing Mule Event – DW coercion failure",
    "difficulty": "Extreme",
    "question": "Which operator prevents coercion error?",
    "options": {
      "A": "as",
      "B": "default",
      "C": "++",
      "D": "map"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "default provides fallback on failure.",
      "incorrect": {
        "A": "as throws error.",
        "C": "Concatenation only.",
        "D": "Iteration only."
      }
    }
  },
  {
    "id": "EXP-MS-0243",
    "component": "Accessing Mule Event – Event Completion Rule",
    "difficulty": "Extreme",
    "question": "What defines HTTP response attributes?",
    "options": {
      "A": "Listener config",
      "B": "Last processor output",
      "C": "Global variables",
      "D": "Object store"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Final event determines response.",
      "incorrect": {
        "A": "Only initial.",
        "C": "Not used.",
        "D": "Not applicable."
      }
    }
  },
  {
    "id": "EXP-MS-0244",
    "component": "Accessing Mule Event – DW regex",
    "difficulty": "Extreme",
    "question": "What does matches return?",
    "options": {
      "A": "Matched string",
      "B": "Boolean",
      "C": "Index",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "matches evaluates regex match.",
      "incorrect": {
        "A": "replace returns string.",
        "C": "indexOf returns index.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0245",
    "component": "Accessing Mule Event – DW isBlank",
    "difficulty": "Extreme",
    "question": "isBlank(\" \") returns?",
    "options": {
      "A": "true",
      "B": "false",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Whitespace-only string is blank.",
      "incorrect": {
        "B": "Blank includes whitespace.",
        "C": "Boolean returned.",
        "D": "Valid function."
      }
    }
  },

  {
    "id": "EXP-MS-0246",
    "component": "Accessing Mule Event – DW substringAfter",
    "difficulty": "Extreme",
    "question": "substringAfter(\"a:b\",\":\") returns?",
    "options": {
      "A": "\"a\"",
      "B": "\"b\"",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Returns substring after delimiter.",
      "incorrect": {
        "A": "Before delimiter.",
        "C": "Delimiter exists.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0247",
    "component": "Accessing Mule Event – DW substringBefore",
    "difficulty": "Extreme",
    "question": "substringBefore(\"a:b\",\":\") returns?",
    "options": {
      "A": "\"a\"",
      "B": "\"b\"",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Returns substring before delimiter.",
      "incorrect": {
        "B": "After delimiter.",
        "C": "Delimiter exists.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0248",
    "component": "Accessing Mule Event – DW charAt",
    "difficulty": "Extreme",
    "question": "charAt(\"abc\",1) returns?",
    "options": {
      "A": "\"a\"",
      "B": "\"b\"",
      "C": "\"c\"",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Index starts at 0.",
      "incorrect": {
        "A": "Index 0.",
        "C": "Index 2.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0249",
    "component": "Accessing Mule Event – DW repeat",
    "difficulty": "Extreme",
    "question": "repeat(\"a\",3) returns?",
    "options": {
      "A": "\"aaa\"",
      "B": "\"a,a,a\"",
      "C": "[\"a\",\"a\",\"a\"]",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "repeat concatenates string.",
      "incorrect": {
        "B": "No delimiter.",
        "C": "String returned.",
        "D": "Valid function."
      }
    }
  },
  {
    "id": "EXP-MS-0250",
    "component": "Accessing Mule Event – Section Completion",
    "difficulty": "Extreme",
    "question": "What is the core principle behind Mule 4 event handling?",
    "options": {
      "A": "Mutable shared state",
      "B": "Copy-on-write immutability",
      "C": "Global variables",
      "D": "Sequential execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mule 4 uses immutable, copy-on-write events.",
      "incorrect": {
        "A": "Discouraged.",
        "C": "Not supported.",
        "D": "Parallel execution exists."
      }
    }
  },
  {
    "id": "EXP-MS-0251",
    "component": "Structuring Mule Apps – Config Separation",
    "difficulty": "Extreme",
    "question": "What happens if two configuration XML files define the same global HTTP listener config name?",
    "options": {
      "A": "Last loaded overrides silently",
      "B": "Application fails at startup",
      "C": "Random one is picked",
      "D": "Both are merged"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Duplicate global element names cause startup failure.",
      "incorrect": {
        "A": "No override occurs.",
        "C": "No randomness.",
        "D": "Globals are not merged."
      }
    }
  },
  {
    "id": "EXP-MS-0252",
    "component": "Structuring Mule Apps – Properties Resolution",
    "difficulty": "Extreme",
    "question": "Which source has highest precedence when resolving properties?",
    "options": {
      "A": "config.yaml",
      "B": "mule-artifact.json",
      "C": "System properties",
      "D": "Global properties file"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "System properties override all other property sources.",
      "incorrect": {
        "A": "Lower priority.",
        "B": "Does not override runtime properties.",
        "D": "Lowest priority."
      }
    }
  },
  {
    "id": "EXP-MS-0253",
    "component": "Structuring Mule Apps – Flow vs Subflow",
    "difficulty": "Extreme",
    "question": "Which characteristic is unique to a flow and not a subflow?",
    "options": {
      "A": "Can be referenced",
      "B": "Can have an error handler",
      "C": "Can have an event source",
      "D": "Can mutate payload"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Only flows can have event sources.",
      "incorrect": {
        "A": "Both can be referenced.",
        "B": "Both support error handling.",
        "D": "Both can mutate payload."
      }
    }
  },
  {
    "id": "EXP-MS-0254",
    "component": "Structuring Mule Apps – FlowRef Behavior",
    "difficulty": "Extreme",
    "question": "What happens if a flow-ref references a flow with its own listener?",
    "options": {
      "A": "Listener is executed",
      "B": "Listener is ignored",
      "C": "Runtime error occurs",
      "D": "Payload is reset"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Event sources are ignored when invoking via flow-ref.",
      "incorrect": {
        "A": "Listeners are not executed.",
        "C": "No error occurs.",
        "D": "Payload unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0255",
    "component": "Structuring Mule Apps – Multiple Flows",
    "difficulty": "Extreme",
    "question": "How are multiple flows initialized at startup?",
    "options": {
      "A": "Sequential order in XML",
      "B": "Alphabetical order",
      "C": "Independently and concurrently",
      "D": "Only when referenced"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Flows are initialized independently.",
      "incorrect": {
        "A": "Order is not guaranteed.",
        "B": "Not alphabetical.",
        "D": "Listeners initialize flows."
      }
    }
  },

  {
    "id": "EXP-MS-0256",
    "component": "Structuring Mule Apps – Global Elements",
    "difficulty": "Extreme",
    "question": "Why should connectors be defined as global elements?",
    "options": {
      "A": "To improve performance",
      "B": "To allow reuse and central configuration",
      "C": "To reduce memory",
      "D": "To avoid errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Globals enable reuse and centralized config.",
      "incorrect": {
        "A": "Performance impact is secondary.",
        "C": "Memory unaffected.",
        "D": "Errors not automatically avoided."
      }
    }
  },
  {
    "id": "EXP-MS-0257",
    "component": "Structuring Mule Apps – mule-artifact.json",
    "difficulty": "Extreme",
    "question": "Which value in mule-artifact.json controls classloader behavior?",
    "options": {
      "A": "minMuleVersion",
      "B": "exportedResources",
      "C": "secureProperties",
      "D": "configs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "exportedResources affect classloader visibility.",
      "incorrect": {
        "A": "Version control only.",
        "C": "Security only.",
        "D": "Configuration files list."
      }
    }
  },
  {
    "id": "EXP-MS-0258",
    "component": "Structuring Mule Apps – Properties Placeholder",
    "difficulty": "Extreme",
    "question": "What happens if a required property placeholder is missing at startup?",
    "options": {
      "A": "Application starts with null",
      "B": "Default value is assumed",
      "C": "Startup fails",
      "D": "Warning is logged"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Unresolved placeholders cause startup failure.",
      "incorrect": {
        "A": "Null not allowed.",
        "B": "No implicit default.",
        "D": "Failure is fatal."
      }
    }
  },
  {
    "id": "EXP-MS-0259",
    "component": "Structuring Mule Apps – Domain Project",
    "difficulty": "Extreme",
    "question": "What is the primary purpose of a Mule domain project?",
    "options": {
      "A": "Share flows",
      "B": "Share global resources across apps",
      "C": "Deploy APIs",
      "D": "Version RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Domains share listeners, connectors, TLS configs.",
      "incorrect": {
        "A": "Flows cannot be shared.",
        "C": "Deployment is separate.",
        "D": "RAML is not versioned here."
      }
    }
  },
  {
    "id": "EXP-MS-0260",
    "component": "Structuring Mule Apps – Error Handler Scope",
    "difficulty": "Extreme",
    "question": "Which error handler has the highest priority?",
    "options": {
      "A": "Global error handler",
      "B": "Flow error handler",
      "C": "Try scope error handler",
      "D": "Default handler"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Try scope handlers override all others.",
      "incorrect": {
        "A": "Lowest precedence.",
        "B": "Overrides global only.",
        "D": "Fallback only."
      }
    }
  },

  {
    "id": "EXP-MS-0261",
    "component": "Structuring Mule Apps – Config Modularity",
    "difficulty": "Extreme",
    "question": "What is the main benefit of splitting configs by layer?",
    "options": {
      "A": "Faster runtime",
      "B": "Improved maintainability",
      "C": "Lower memory usage",
      "D": "Better error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered configs improve readability and maintenance.",
      "incorrect": {
        "A": "Runtime unaffected.",
        "C": "Memory unaffected.",
        "D": "Error handling unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0262",
    "component": "Structuring Mule Apps – Flow Ref Cycles",
    "difficulty": "Extreme",
    "question": "What happens if two flows reference each other recursively?",
    "options": {
      "A": "Stack overflow at runtime",
      "B": "Compile-time error",
      "C": "Automatic loop detection",
      "D": "Ignored"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Recursive flow-refs cause stack overflow.",
      "incorrect": {
        "B": "No compile-time detection.",
        "C": "No automatic prevention.",
        "D": "References are executed."
      }
    }
  },
  {
    "id": "EXP-MS-0263",
    "component": "Structuring Mule Apps – Subflow Reuse",
    "difficulty": "Extreme",
    "question": "Why are subflows preferred for reusable logic?",
    "options": {
      "A": "They are faster",
      "B": "They cannot have listeners",
      "C": "They avoid event source conflicts",
      "D": "They persist state"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Subflows avoid listener duplication.",
      "incorrect": {
        "A": "Performance is same.",
        "B": "True but not main reason.",
        "D": "They do not persist state."
      }
    }
  },
  {
    "id": "EXP-MS-0264",
    "component": "Structuring Mule Apps – Secure Properties",
    "difficulty": "Extreme",
    "question": "Which module is required to decrypt secure properties?",
    "options": {
      "A": "TLS",
      "B": "Crypto",
      "C": "Secure Properties",
      "D": "Vault"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Secure Properties module handles encrypted values.",
      "incorrect": {
        "A": "TLS is transport security.",
        "B": "Crypto is not used directly.",
        "D": "Vault is external."
      }
    }
  },
  {
    "id": "EXP-MS-0265",
    "component": "Structuring Mule Apps – Property Reload",
    "difficulty": "Extreme",
    "question": "When are property files loaded?",
    "options": {
      "A": "Per request",
      "B": "On startup only",
      "C": "On each flow execution",
      "D": "On error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Properties are resolved at startup.",
      "incorrect": {
        "A": "Not dynamic.",
        "C": "No reload per flow.",
        "D": "Errors do not reload."
      }
    }
  },

  {
    "id": "EXP-MS-0266",
    "component": "Structuring Mule Apps – Application Scope",
    "difficulty": "Extreme",
    "question": "Which element is shared across all flows?",
    "options": {
      "A": "Variables",
      "B": "Payload",
      "C": "Object Store",
      "D": "Attributes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object stores can be shared application-wide.",
      "incorrect": {
        "A": "Variables are event-scoped.",
        "B": "Payload is per event.",
        "D": "Attributes are per event."
      }
    }
  },
  {
    "id": "EXP-MS-0267",
    "component": "Structuring Mule Apps – Config Import",
    "difficulty": "Extreme",
    "question": "How are multiple config XMLs combined?",
    "options": {
      "A": "Merged into one runtime model",
      "B": "Executed sequentially",
      "C": "Only main XML used",
      "D": "Alphabetical load"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "All configs form a single application model.",
      "incorrect": {
        "B": "Not execution order.",
        "C": "All configs are used.",
        "D": "Order not guaranteed."
      }
    }
  },
  {
    "id": "EXP-MS-0268",
    "component": "Structuring Mule Apps – Flow Isolation",
    "difficulty": "Extreme",
    "question": "Do variables leak between parallel flows?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only with async",
      "D": "Only with flow-ref"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each flow has isolated events.",
      "incorrect": {
        "A": "Isolation enforced.",
        "C": "Async copies event.",
        "D": "flow-ref shares same event only."
      }
    }
  },
  {
    "id": "EXP-MS-0269",
    "component": "Structuring Mule Apps – Startup Failure",
    "difficulty": "Extreme",
    "question": "Which issue always prevents application startup?",
    "options": {
      "A": "Unused flow",
      "B": "Missing property",
      "C": "Slow connector",
      "D": "Empty subflow"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Missing required properties cause startup failure.",
      "incorrect": {
        "A": "Unused flows allowed.",
        "C": "Performance issue only.",
        "D": "Empty subflow is valid."
      }
    }
  },
  {
    "id": "EXP-MS-0270",
    "component": "Structuring Mule Apps – End Chunk",
    "difficulty": "Extreme",
    "question": "Which file defines application entry points?",
    "options": {
      "A": "pom.xml",
      "B": "mule-artifact.json",
      "C": "Flow XMLs",
      "D": "settings.xml"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Entry points are flows with listeners.",
      "incorrect": {
        "A": "Build config only.",
        "B": "Metadata only.",
        "D": "Maven config."
      }
    }
  },
  {
    "id": "EXP-MS-0271",
    "component": "Structuring Mule Apps – Flow Startup",
    "difficulty": "Extreme",
    "question": "Which flows are started automatically at application startup?",
    "options": {
      "A": "All flows",
      "B": "Only flows referenced by flow-ref",
      "C": "Only flows with event sources",
      "D": "Only subflows"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Only flows with event sources are started.",
      "incorrect": {
        "A": "Flows without listeners are idle.",
        "B": "flow-ref does not auto-start flows.",
        "D": "Subflows cannot start."
      }
    }
  },
  {
    "id": "EXP-MS-0272",
    "component": "Structuring Mule Apps – Subflow Invocation",
    "difficulty": "Extreme",
    "question": "How is a subflow executed?",
    "options": {
      "A": "Automatically at startup",
      "B": "Via flow-ref only",
      "C": "Via listener",
      "D": "Via scheduler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflows can only be invoked via flow-ref.",
      "incorrect": {
        "A": "No event source allowed.",
        "C": "Listeners are not allowed.",
        "D": "Schedulers require flows."
      }
    }
  },
  {
    "id": "EXP-MS-0273",
    "component": "Structuring Mule Apps – XML Ordering",
    "difficulty": "Extreme",
    "question": "Does the order of flows in XML affect execution?",
    "options": {
      "A": "Yes, first flow executes first",
      "B": "Yes, alphabetical",
      "C": "No, execution is event-driven",
      "D": "Only for subflows"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Flow execution is event-driven, not XML order based.",
      "incorrect": {
        "A": "No sequential execution.",
        "B": "Alphabetical order is irrelevant.",
        "D": "Same rule applies."
      }
    }
  },
  {
    "id": "EXP-MS-0274",
    "component": "Structuring Mule Apps – Multiple Config Files",
    "difficulty": "Extreme",
    "question": "What happens if two config files define the same flow name?",
    "options": {
      "A": "Last one wins",
      "B": "Random selection",
      "C": "Startup failure",
      "D": "Flows are merged"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Duplicate flow names cause deployment failure.",
      "incorrect": {
        "A": "No override behavior.",
        "B": "No randomness.",
        "D": "Flows are not merged."
      }
    }
  },
  {
    "id": "EXP-MS-0275",
    "component": "Structuring Mule Apps – Scheduler Scope",
    "difficulty": "Extreme",
    "question": "Which element allows time-based triggering?",
    "options": {
      "A": "Flow-ref",
      "B": "Listener",
      "C": "Scheduler",
      "D": "Async"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Scheduler triggers flows based on time.",
      "incorrect": {
        "A": "Invocation only.",
        "B": "Inbound request only.",
        "D": "Concurrency only."
      }
    }
  },

  {
    "id": "EXP-MS-0276",
    "component": "Structuring Mule Apps – Global Config Scope",
    "difficulty": "Extreme",
    "question": "Where must a global connector configuration be declared?",
    "options": {
      "A": "Inside a flow",
      "B": "Inside a subflow",
      "C": "At application root level",
      "D": "Inside try scope"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Global configs must be defined at the root level.",
      "incorrect": {
        "A": "Flows cannot define globals.",
        "B": "Subflows cannot define globals.",
        "D": "Scopes cannot define globals."
      }
    }
  },
  {
    "id": "EXP-MS-0277",
    "component": "Structuring Mule Apps – Error Propagation",
    "difficulty": "Extreme",
    "question": "If a subflow throws an error, where is it handled first?",
    "options": {
      "A": "Global error handler",
      "B": "Calling flow error handler",
      "C": "Subflow error handler",
      "D": "Runtime engine"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflows do not have their own error handlers.",
      "incorrect": {
        "A": "Only if not handled in flow.",
        "C": "Subflows cannot define handlers.",
        "D": "Engine only routes error."
      }
    }
  },
  {
    "id": "EXP-MS-0278",
    "component": "Structuring Mule Apps – Configuration Reload",
    "difficulty": "Extreme",
    "question": "Can Mule reload XML config files without redeployment?",
    "options": {
      "A": "Yes, always",
      "B": "Only in Dev mode",
      "C": "No",
      "D": "Only on CloudHub"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Config reload requires redeployment.",
      "incorrect": {
        "A": "Not supported.",
        "B": "Dev mode does not hot-reload XML.",
        "D": "CloudHub does not support hot reload."
      }
    }
  },
  {
    "id": "EXP-MS-0279",
    "component": "Structuring Mule Apps – Secure Properties Resolution",
    "difficulty": "Extreme",
    "question": "When are secure properties decrypted?",
    "options": {
      "A": "At build time",
      "B": "At startup",
      "C": "Per request",
      "D": "On first access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure properties are decrypted during startup.",
      "incorrect": {
        "A": "Build has no secrets.",
        "C": "Not per request.",
        "D": "Not lazy-loaded."
      }
    }
  },
  {
    "id": "EXP-MS-0280",
    "component": "Structuring Mule Apps – Shared Resources",
    "difficulty": "Extreme",
    "question": "Which resource can be shared using a domain project?",
    "options": {
      "A": "Flows",
      "B": "Subflows",
      "C": "HTTP Listener configuration",
      "D": "Variables"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Domains share listeners, TLS, connectors.",
      "incorrect": {
        "A": "Flows cannot be shared.",
        "B": "Subflows cannot be shared.",
        "D": "Variables are event-scoped."
      }
    }
  },

  {
    "id": "EXP-MS-0281",
    "component": "Structuring Mule Apps – Event Isolation",
    "difficulty": "Extreme",
    "question": "What ensures that one request does not affect another?",
    "options": {
      "A": "Flow design",
      "B": "Event immutability",
      "C": "Thread pools",
      "D": "Schedulers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutable events ensure isolation.",
      "incorrect": {
        "A": "Design alone is insufficient.",
        "C": "Thread pools do not isolate state.",
        "D": "Schedulers are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0282",
    "component": "Structuring Mule Apps – Listener Binding",
    "difficulty": "Extreme",
    "question": "What happens if two flows bind to the same host/port/path?",
    "options": {
      "A": "First one wins",
      "B": "Round-robin routing",
      "C": "Startup failure",
      "D": "Requests are duplicated"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Port/path conflicts cause startup failure.",
      "incorrect": {
        "A": "No override allowed.",
        "B": "No routing exists.",
        "D": "No duplication."
      }
    }
  },
  {
    "id": "EXP-MS-0283",
    "component": "Structuring Mule Apps – Scheduler Concurrency",
    "difficulty": "Extreme",
    "question": "What controls parallel executions of a scheduler?",
    "options": {
      "A": "maxConcurrency",
      "B": "poolSize",
      "C": "frequency",
      "D": "delay"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "maxConcurrency limits parallel executions.",
      "incorrect": {
        "B": "Not a scheduler property.",
        "C": "Controls timing only.",
        "D": "Controls initial delay."
      }
    }
  },
  {
    "id": "EXP-MS-0284",
    "component": "Structuring Mule Apps – Subflow Return",
    "difficulty": "Extreme",
    "question": "How does a subflow return data?",
    "options": {
      "A": "Explicit return statement",
      "B": "Last processor output",
      "C": "Global variable",
      "D": "Object store"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflow returns modified event from last processor.",
      "incorrect": {
        "A": "No return keyword.",
        "C": "Globals not used.",
        "D": "Not automatic."
      }
    }
  },
  {
    "id": "EXP-MS-0285",
    "component": "Structuring Mule Apps – Application Classloader",
    "difficulty": "Extreme",
    "question": "Why is classloader isolation important?",
    "options": {
      "A": "Performance",
      "B": "Security",
      "C": "Dependency conflict avoidance",
      "D": "Logging"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Isolation prevents dependency clashes.",
      "incorrect": {
        "A": "Secondary benefit.",
        "B": "Indirect benefit.",
        "D": "Not relevant."
      }
    }
  },

  {
    "id": "EXP-MS-0286",
    "component": "Structuring Mule Apps – App Restart",
    "difficulty": "Extreme",
    "question": "Which change requires full redeployment?",
    "options": {
      "A": "Property value change",
      "B": "Flow logic change",
      "C": "Secure property key rotation",
      "D": "All of the above"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Any config or logic change requires redeployment.",
      "incorrect": {
        "A": "Requires restart.",
        "B": "Requires restart.",
        "C": "Requires restart."
      }
    }
  },
  {
    "id": "EXP-MS-0287",
    "component": "Structuring Mule Apps – Deployment Descriptor",
    "difficulty": "Extreme",
    "question": "Which file defines minimum Mule runtime version?",
    "options": {
      "A": "pom.xml",
      "B": "mule-artifact.json",
      "C": "settings.xml",
      "D": "mule-deploy.properties"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "minMuleVersion is defined in mule-artifact.json.",
      "incorrect": {
        "A": "Build file.",
        "C": "Maven config.",
        "D": "Not used in Mule 4."
      }
    }
  },
  {
    "id": "EXP-MS-0288",
    "component": "Structuring Mule Apps – Property Placeholder Syntax",
    "difficulty": "Extreme",
    "question": "Which syntax resolves a property?",
    "options": {
      "A": "${prop}",
      "B": "#{prop}",
      "C": "#[prop]",
      "D": "@{prop}"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Properties use ${} syntax.",
      "incorrect": {
        "B": "EL syntax.",
        "C": "DW expression.",
        "D": "Invalid."
      }
    }
  },
  {
    "id": "EXP-MS-0289",
    "component": "Structuring Mule Apps – Application State",
    "difficulty": "Extreme",
    "question": "Where should application state be stored safely?",
    "options": {
      "A": "Variables",
      "B": "Payload",
      "C": "Object Store",
      "D": "Attributes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object Store persists state safely.",
      "incorrect": {
        "A": "Event-scoped.",
        "B": "Transient.",
        "D": "Read-only."
      }
    }
  },
  {
    "id": "EXP-MS-0290",
    "component": "Structuring Mule Apps – Flow Execution Model",
    "difficulty": "Extreme",
    "question": "How does Mule handle concurrent requests?",
    "options": {
      "A": "Single-threaded",
      "B": "Thread-per-flow",
      "C": "Non-blocking event-driven",
      "D": "Sequential queue"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Mule uses a non-blocking reactive model.",
      "incorrect": {
        "A": "Not single-threaded.",
        "B": "Not thread-per-flow.",
        "D": "Not sequential."
      }
    }
  },

  {
    "id": "EXP-MS-0291",
    "component": "Structuring Mule Apps – Error Scope Placement",
    "difficulty": "Extreme",
    "question": "Where should global error handlers be defined?",
    "options": {
      "A": "Inside flows",
      "B": "Inside subflows",
      "C": "At application root",
      "D": "Inside try scope"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Global handlers are defined at root level.",
      "incorrect": {
        "A": "Flow-level handlers differ.",
        "B": "Subflows cannot define handlers.",
        "D": "Try handlers are local."
      }
    }
  },
  {
    "id": "EXP-MS-0292",
    "component": "Structuring Mule Apps – Config Validation",
    "difficulty": "Extreme",
    "question": "When is XML schema validation performed?",
    "options": {
      "A": "At runtime per request",
      "B": "At build time",
      "C": "At startup",
      "D": "Never"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "XML validation occurs during startup.",
      "incorrect": {
        "A": "Not per request.",
        "B": "Build does not validate runtime XML.",
        "D": "Always validated."
      }
    }
  },
  {
    "id": "EXP-MS-0293",
    "component": "Structuring Mule Apps – FlowRef Performance",
    "difficulty": "Extreme",
    "question": "What is the performance cost of flow-ref?",
    "options": {
      "A": "High network latency",
      "B": "Context switch only",
      "C": "Thread creation",
      "D": "Serialization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref is an in-memory context switch.",
      "incorrect": {
        "A": "No network call.",
        "C": "No new thread.",
        "D": "No serialization."
      }
    }
  },
  {
    "id": "EXP-MS-0294",
    "component": "Structuring Mule Apps – Parallelism Safety",
    "difficulty": "Extreme",
    "question": "What must be avoided in parallel flows?",
    "options": {
      "A": "Flow-ref",
      "B": "Object Store",
      "C": "Shared mutable state",
      "D": "Listeners"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Shared mutable state causes race conditions.",
      "incorrect": {
        "A": "Safe usage.",
        "B": "Designed for concurrency.",
        "D": "Not shared."
      }
    }
  },
  {
    "id": "EXP-MS-0295",
    "component": "Structuring Mule Apps – Deployment Failure",
    "difficulty": "Extreme",
    "question": "Which issue is detected only at startup?",
    "options": {
      "A": "Syntax error in XML",
      "B": "Missing property",
      "C": "Logic bug",
      "D": "Performance issue"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Missing properties are resolved at startup.",
      "incorrect": {
        "A": "Caught earlier.",
        "C": "Runtime issue.",
        "D": "Observed at runtime."
      }
    }
  },

  {
    "id": "EXP-MS-0296",
    "component": "Structuring Mule Apps – App Boundary",
    "difficulty": "Extreme",
    "question": "What enforces isolation between Mule applications?",
    "options": {
      "A": "Object Store",
      "B": "Classloader",
      "C": "Thread pool",
      "D": "Scheduler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Classloader isolation separates apps.",
      "incorrect": {
        "A": "Can be shared.",
        "C": "Threads are pooled.",
        "D": "Not isolating."
      }
    }
  },
  {
    "id": "EXP-MS-0297",
    "component": "Structuring Mule Apps – Domain Limitation",
    "difficulty": "Extreme",
    "question": "What cannot be shared using a domain?",
    "options": {
      "A": "TLS configuration",
      "B": "HTTP Listener",
      "C": "Flows",
      "D": "Connector configuration"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Flows cannot be shared across apps.",
      "incorrect": {
        "A": "TLS can be shared.",
        "B": "Listeners can be shared.",
        "D": "Connectors can be shared."
      }
    }
  },
  {
    "id": "EXP-MS-0298",
    "component": "Structuring Mule Apps – Hot Restart",
    "difficulty": "Extreme",
    "question": "Does Mule support hot restart without downtime?",
    "options": {
      "A": "Yes",
      "B": "Only on CloudHub",
      "C": "No",
      "D": "Only for properties"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Restart causes downtime.",
      "incorrect": {
        "A": "Not supported.",
        "B": "CloudHub redeploys.",
        "D": "Properties also require restart."
      }
    }
  },
  {
    "id": "EXP-MS-0299",
    "component": "Structuring Mule Apps – Flow Completion",
    "difficulty": "Extreme",
    "question": "When is a Mule event considered complete?",
    "options": {
      "A": "After listener",
      "B": "After last processor",
      "C": "After response sent",
      "D": "After logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Event completes after last processor.",
      "incorrect": {
        "A": "Listener only starts event.",
        "C": "Response is derived from event.",
        "D": "Logging is passive."
      }
    }
  },
  {
    "id": "EXP-MS-0300",
    "component": "Structuring Mule Apps – Section Integrity",
    "difficulty": "Extreme",
    "question": "What is the safest way to share configuration across environments?",
    "options": {
      "A": "Hardcoding values",
      "B": "Separate XML per environment",
      "C": "Externalized properties",
      "D": "Multiple applications"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Externalized properties allow environment-specific values.",
      "incorrect": {
        "A": "Hardcoding is unsafe.",
        "B": "Duplication risk.",
        "D": "Overengineering."
      }
    }
  },

  {
    "id": "EXP-MS-0301",
    "component": "Structuring Mule Apps – Continuation Marker",
    "difficulty": "Extreme",
    "question": "Why are flows stateless by design?",
    "options": {
      "A": "Ease of coding",
      "B": "Horizontal scalability",
      "C": "Security",
      "D": "Logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Statelessness enables horizontal scaling.",
      "incorrect": {
        "A": "Not primary reason.",
        "C": "Indirect benefit.",
        "D": "Unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0302",
    "component": "Structuring Mule Apps – Event Source Restriction",
    "difficulty": "Extreme",
    "question": "Why can a subflow not contain an event source?",
    "options": {
      "A": "Performance",
      "B": "Design consistency",
      "C": "Ambiguous event ownership",
      "D": "Syntax limitation"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Subflows rely on parent event context.",
      "incorrect": {
        "A": "Performance is not reason.",
        "B": "Design follows event model.",
        "D": "Not syntax-based."
      }
    }
  },
  {
    "id": "EXP-MS-0302",
    "component": "Structuring Mule Apps – Event Source Restriction",
    "difficulty": "Extreme",
    "question": "Why can a subflow not contain an event source?",
    "options": {
      "A": "Performance limitation",
      "B": "Subflows share parent event",
      "C": "XML schema restriction only",
      "D": "Threading limitation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflows execute within the caller’s Mule event.",
      "incorrect": {
        "A": "Not performance-related.",
        "C": "Schema reflects event model.",
        "D": "Threading is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0303",
    "component": "Structuring Mule Apps – FlowRef Error Propagation",
    "difficulty": "Extreme",
    "question": "If a flow-ref throws an error and the child flow has no handler, where is it handled?",
    "options": {
      "A": "Child flow",
      "B": "Global error handler only",
      "C": "Calling flow error handler",
      "D": "Runtime engine"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Errors propagate back to the calling flow.",
      "incorrect": {
        "A": "No handler exists.",
        "B": "Only if not handled in flow.",
        "D": "Engine only routes errors."
      }
    }
  },
  {
    "id": "EXP-MS-0304",
    "component": "Structuring Mule Apps – Scheduler vs Listener",
    "difficulty": "Extreme",
    "question": "Which is a key structural difference between scheduler and listener?",
    "options": {
      "A": "Scheduler creates payload",
      "B": "Listener requires external trigger",
      "C": "Scheduler is synchronous",
      "D": "Listener cannot run in parallel"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Listeners depend on inbound events, schedulers do not.",
      "incorrect": {
        "A": "Both create events.",
        "C": "Schedulers are asynchronous.",
        "D": "Listeners support concurrency."
      }
    }
  },
  {
    "id": "EXP-MS-0305",
    "component": "Structuring Mule Apps – Flow Isolation",
    "difficulty": "Extreme",
    "question": "What prevents variable leakage between two independent flows?",
    "options": {
      "A": "Variable scoping",
      "B": "Event immutability",
      "C": "Thread pools",
      "D": "Schedulers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each flow execution has its own immutable event.",
      "incorrect": {
        "A": "Variables are part of the event.",
        "C": "Threads do not isolate data.",
        "D": "Schedulers are triggers."
      }
    }
  },
  {
    "id": "EXP-MS-0306",
    "component": "Structuring Mule Apps – Global Elements",
    "difficulty": "Extreme",
    "question": "Why must global elements be resolved before flows start?",
    "options": {
      "A": "considered runtime optimization",
      "B": "They provide shared dependencies",
      "C": "They generate payload",
      "D": "They start listeners"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flows depend on globals for configuration.",
      "incorrect": {
        "A": "Not optimization related.",
        "C": "Globals do not generate payload.",
        "D": "Listeners are separate."
      }
    }
  },

  {
    "id": "EXP-MS-0307",
    "component": "Structuring Mule Apps – Property Placeholder Failure",
    "difficulty": "Extreme",
    "question": "What happens if a placeholder resolves to an empty string?",
    "options": {
      "A": "Startup failure",
      "B": "Null value assigned",
      "C": "Empty value is used",
      "D": "Default value applied"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Empty string is a valid resolved value.",
      "incorrect": {
        "A": "Only unresolved placeholders fail.",
        "B": "Empty is not null.",
        "D": "Default applies only with default operator."
      }
    }
  },
  {
    "id": "EXP-MS-0308",
    "component": "Structuring Mule Apps – Config File Count",
    "difficulty": "Extreme",
    "question": "Is there a runtime limit on number of configuration XML files?",
    "options": {
      "A": "Yes, 10",
      "B": "Yes, 50",
      "C": "No",
      "D": "Depends on runtime"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Mule imposes no fixed limit.",
      "incorrect": {
        "A": "No such limit.",
        "B": "No such limit.",
        "D": "Runtime-independent."
      }
    }
  },
  {
    "id": "EXP-MS-0309",
    "component": "Structuring Mule Apps – Deployment Order",
    "difficulty": "Extreme",
    "question": "In which order are application elements initialized?",
    "options": {
      "A": "Flows → Globals",
      "B": "Globals → Flows",
      "C": "Listeners → Globals",
      "D": "Subflows → Flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Globals must be ready before flows.",
      "incorrect": {
        "A": "Reverse order invalid.",
        "C": "Listeners depend on globals.",
        "D": "Subflows are part of flows."
      }
    }
  },
  {
    "id": "EXP-MS-0310",
    "component": "Structuring Mule Apps – Parallel Deployment",
    "difficulty": "Extreme",
    "question": "Are multiple applications deployed in parallel on CloudHub?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only during restart",
      "D": "Only with workers >1"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "CloudHub supports parallel app deployments.",
      "incorrect": {
        "B": "Not sequential.",
        "C": "Not limited to restart.",
        "D": "Workers irrelevant."
      }
    }
  },

  {
    "id": "EXP-MS-0311",
    "component": "Structuring Mule Apps – Listener Lifecycle",
    "difficulty": "Extreme",
    "question": "When does an HTTP listener start accepting traffic?",
    "options": {
      "A": "After app deploy command",
      "B": "After global configs load",
      "C": "After flow initialization completes",
      "D": "After first request"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Listener starts only after flow is fully initialized.",
      "incorrect": {
        "A": "Deploy is asynchronous.",
        "B": "Flows still pending.",
        "D": "Requests come later."
      }
    }
  },
  {
    "id": "EXP-MS-0312",
    "component": "Structuring Mule Apps – Flow State",
    "difficulty": "Extreme",
    "question": "Are flows stateful across requests?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only with variables",
      "D": "Only with object store"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flows are stateless; state lives in event or external store.",
      "incorrect": {
        "A": "Incorrect.",
        "C": "Variables are per event.",
        "D": "Externalized state."
      }
    }
  },
  {
    "id": "EXP-MS-0313",
    "component": "Structuring Mule Apps – FlowRef Threading",
    "difficulty": "Extreme",
    "question": "Does flow-ref create a new thread?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only in async",
      "D": "Only with schedulers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref executes in the same thread.",
      "incorrect": {
        "A": "No thread spawn.",
        "C": "Async explicitly changes threading.",
        "D": "Schedulers are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0314",
    "component": "Structuring Mule Apps – Configuration Fail-Fast",
    "difficulty": "Extreme",
    "question": "Why does Mule fail fast on configuration errors?",
    "options": {
      "A": "Performance reasons",
      "B": "Early error visibility",
      "C": "Security enforcement",
      "D": "CloudHub requirement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fail-fast prevents running with invalid config.",
      "incorrect": {
        "A": "Secondary.",
        "C": "Not primary.",
        "D": "Not platform-specific."
      }
    }
  },
  {
    "id": "EXP-MS-0315",
    "component": "Structuring Mule Apps – Application Restart",
    "difficulty": "Extreme",
    "question": "What is preserved across application restarts?",
    "options": {
      "A": "Variables",
      "B": "Payload",
      "C": "Object Store (persistent)",
      "D": "Attributes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Persistent object stores survive restarts.",
      "incorrect": {
        "A": "Variables are ephemeral.",
        "B": "Payload is per request.",
        "D": "Attributes are per event."
      }
    }
  },

  {
    "id": "EXP-MS-0316",
    "component": "Structuring Mule Apps – XML Namespace",
    "difficulty": "Extreme",
    "question": "Why are XML namespaces mandatory in Mule config?",
    "options": {
      "A": "Performance",
      "B": "Schema validation and disambiguation",
      "C": "Runtime routing",
      "D": "Logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Namespaces map elements to correct schemas.",
      "incorrect": {
        "A": "Not performance-related.",
        "C": "Routing is separate.",
        "D": "Logging unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0317",
    "component": "Structuring Mule Apps – Config Packaging",
    "difficulty": "Extreme",
    "question": "Where are application configs packaged at build time?",
    "options": {
      "A": "JAR root",
      "B": "classes/",
      "C": "META-INF",
      "D": "apps/"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Configs are packaged under classes.",
      "incorrect": {
        "A": "Root contains metadata.",
        "C": "Reserved for descriptors.",
        "D": "Runtime directory."
      }
    }
  },
  {
    "id": "EXP-MS-0318",
    "component": "Structuring Mule Apps – Flow Availability",
    "difficulty": "Extreme",
    "question": "Can a flow without a listener be invoked externally?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only via scheduler",
      "D": "Only in CloudHub"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only flows with event sources accept external events.",
      "incorrect": {
        "A": "External calls require listener.",
        "C": "Scheduler is internal.",
        "D": "Platform-independent."
      }
    }
  },
  {
    "id": "EXP-MS-0319",
    "component": "Structuring Mule Apps – Application Boundary",
    "difficulty": "Extreme",
    "question": "What enforces strict isolation between applications?",
    "options": {
      "A": "Thread pools",
      "B": "Object Store",
      "C": "Classloader",
      "D": "Schedulers"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Each app has its own classloader.",
      "incorrect": {
        "A": "Shared.",
        "B": "Can be shared.",
        "D": "Triggers only."
      }
    }
  },
  {
    "id": "EXP-MS-0320",
    "component": "Structuring Mule Apps – Section Completion",
    "difficulty": "Extreme",
    "question": "What is the primary design goal of Mule application structure?",
    "options": {
      "A": "Minimize files",
      "B": "Enable scalability and maintainability",
      "C": "Reduce memory usage",
      "D": "Improve logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structure supports scalability and maintainability.",
      "incorrect": {
        "A": "File count is secondary.",
        "C": "Memory is secondary.",
        "D": "Logging is secondary."
      }
    }
  },

  {
    "id": "EXP-MS-0321",
    "component": "Structuring Mule Apps – Flow Chaining",
    "difficulty": "Extreme",
    "question": "Why is deep flow-ref chaining discouraged?",
    "options": {
      "A": "Memory leak",
      "B": "Reduced readability and traceability",
      "C": "Runtime crash",
      "D": "Thread starvation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep chaining complicates debugging and maintenance.",
      "incorrect": {
        "A": "No inherent leak.",
        "C": "No automatic crash.",
        "D": "Threads unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0322",
    "component": "Structuring Mule Apps – Error Visibility",
    "difficulty": "Extreme",
    "question": "Where should cross-cutting error logic live?",
    "options": {
      "A": "Each flow",
      "B": "Subflows",
      "C": "Global error handler",
      "D": "Object store"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Global handler centralizes cross-cutting concerns.",
      "incorrect": {
        "A": "Duplication risk.",
        "B": "Not supported.",
        "D": "Not for logic."
      }
    }
  },
  {
    "id": "EXP-MS-0323",
    "component": "Structuring Mule Apps – Deployment Validation",
    "difficulty": "Extreme",
    "question": "Which issue is detected only during deployment?",
    "options": {
      "A": "Invalid XML",
      "B": "Missing property",
      "C": "Incorrect business logic",
      "D": "Slow response"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Properties resolve at deployment/startup.",
      "incorrect": {
        "A": "Caught earlier.",
        "C": "Runtime issue.",
        "D": "Performance issue."
      }
    }
  },
  {
    "id": "EXP-MS-0324",
    "component": "Structuring Mule Apps – Environment Separation",
    "difficulty": "Extreme",
    "question": "What is the recommended way to separate environments?",
    "options": {
      "A": "Multiple codebases",
      "B": "Conditional flows",
      "C": "Externalized properties",
      "D": "Hardcoded switches"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "External properties cleanly separate environments.",
      "incorrect": {
        "A": "Duplication risk.",
        "B": "Logic pollution.",
        "D": "Unsafe practice."
      }
    }
  },
  {
    "id": "EXP-MS-0325",
    "component": "Structuring Mule Apps – Final Integrity",
    "difficulty": "Extreme",
    "question": "Which principle most influences Mule app structure?",
    "options": {
      "A": "Coupling",
      "B": "Separation of concerns",
      "C": "Code reuse",
      "D": "Performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Separation of concerns drives structure.",
      "incorrect": {
        "A": "Coupling is minimized.",
        "C": "Secondary benefit.",
        "D": "Not primary."
      }
    }
  },
  {
    "id": "EXP-MS-0326",
    "component": "Structuring Mule Apps – Flow Atomicity",
    "difficulty": "Extreme",
    "question": "Why should a flow represent a single business capability?",
    "options": {
      "A": "To reduce memory usage",
      "B": "To improve atomicity and reusability",
      "C": "To increase throughput",
      "D": "To simplify XML syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Single-responsibility flows are easier to reuse and maintain.",
      "incorrect": {
        "A": "Memory is unaffected.",
        "C": "Throughput is not the driver.",
        "D": "Syntax simplicity is secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0327",
    "component": "Structuring Mule Apps – Subflow Side Effects",
    "difficulty": "Extreme",
    "question": "What is the main risk of using subflows for state mutation?",
    "options": {
      "A": "Compilation failure",
      "B": "Hidden side effects in caller flows",
      "C": "Thread starvation",
      "D": "Connector leaks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflows can silently mutate the shared event.",
      "incorrect": {
        "A": "No compile-time issue.",
        "C": "Threads unaffected.",
        "D": "Connectors are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0328",
    "component": "Structuring Mule Apps – Listener Scalability",
    "difficulty": "Extreme",
    "question": "What limits HTTP listener scalability in a single application?",
    "options": {
      "A": "Number of flows",
      "B": "Worker CPU and memory",
      "C": "XML file count",
      "D": "Namespace declarations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scalability is constrained by worker resources.",
      "incorrect": {
        "A": "Flows are lightweight.",
        "C": "No such limit.",
        "D": "Namespaces do not affect runtime."
      }
    }
  },
  {
    "id": "EXP-MS-0329",
    "component": "Structuring Mule Apps – Global Config Reuse",
    "difficulty": "Extreme",
    "question": "What is the main drawback of defining duplicate global configs?",
    "options": {
      "A": "Lower performance",
      "B": "Configuration drift",
      "C": "Thread contention",
      "D": "Payload corruption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Duplicate globals increase inconsistency and maintenance risk.",
      "incorrect": {
        "A": "Performance impact is minimal.",
        "C": "Threads are unaffected.",
        "D": "Payload is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0330",
    "component": "Structuring Mule Apps – Application Modularity",
    "difficulty": "Extreme",
    "question": "What is the primary indicator that an application should be split?",
    "options": {
      "A": "High CPU usage",
      "B": "Multiple unrelated domains in one codebase",
      "C": "Large payload size",
      "D": "High request volume"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unrelated domains violate separation of concerns.",
      "incorrect": {
        "A": "Resource scaling can handle CPU.",
        "C": "Payload size is orthogonal.",
        "D": "Volume can be scaled horizontally."
      }
    }
  },

  {
    "id": "EXP-MS-0331",
    "component": "Structuring Mule Apps – Flow Dependency Direction",
    "difficulty": "Extreme",
    "question": "Which dependency direction is architecturally correct?",
    "options": {
      "A": "System API → Experience API",
      "B": "Process API → System API",
      "C": "Experience API → Process API",
      "D": "System API → Process API"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Experience APIs depend on Process APIs.",
      "incorrect": {
        "A": "Reverse dependency.",
        "B": "Process should not depend on System directly for orchestration.",
        "D": "Incorrect layering."
      }
    }
  },
  {
    "id": "EXP-MS-0332",
    "component": "Structuring Mule Apps – Flow Granularity",
    "difficulty": "Extreme",
    "question": "What is the risk of overly granular flows?",
    "options": {
      "A": "Lower throughput",
      "B": "Excessive flow-ref chaining",
      "C": "Memory leaks",
      "D": "Listener conflicts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too many small flows reduce readability and traceability.",
      "incorrect": {
        "A": "Throughput impact is minimal.",
        "C": "No inherent leaks.",
        "D": "Listeners are unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0333",
    "component": "Structuring Mule Apps – Configuration Ownership",
    "difficulty": "Extreme",
    "question": "Who should own shared global configurations in large teams?",
    "options": {
      "A": "Each developer",
      "B": "API consumers",
      "C": "Platform / C4E team",
      "D": "Runtime engine"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "C4E ensures consistency and governance.",
      "incorrect": {
        "A": "Leads to drift.",
        "B": "Consumers should not manage internals.",
        "D": "Engine does not own config."
      }
    }
  },
  {
    "id": "EXP-MS-0334",
    "component": "Structuring Mule Apps – Startup Determinism",
    "difficulty": "Extreme",
    "question": "Why must application startup be deterministic?",
    "options": {
      "A": "Performance benchmarking",
      "B": "Predictable behavior across environments",
      "C": "Reduced memory usage",
      "D": "Improved logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deterministic startup avoids environment-specific failures.",
      "incorrect": {
        "A": "Benchmarking is secondary.",
        "C": "Memory is unrelated.",
        "D": "Logging is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0335",
    "component": "Structuring Mule Apps – Application Coupling",
    "difficulty": "Extreme",
    "question": "What most strongly indicates tight coupling between Mule apps?",
    "options": {
      "A": "Shared RAML",
      "B": "Direct database sharing",
      "C": "Common error format",
      "D": "Shared logging framework"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sharing databases tightly couples applications.",
      "incorrect": {
        "A": "Shared contracts are acceptable.",
        "C": "Error format is fine.",
        "D": "Logging is infrastructural."
      }
    }
  },

  {
    "id": "EXP-MS-0336",
    "component": "Structuring Mule Apps – Lifecycle Boundaries",
    "difficulty": "Extreme",
    "question": "Which element defines application lifecycle boundaries?",
    "options": {
      "A": "Flows",
      "B": "Domains",
      "C": "Runtime",
      "D": "Workers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Domains define shared lifecycle resources.",
      "incorrect": {
        "A": "Flows are internal.",
        "C": "Runtime hosts apps.",
        "D": "Workers are execution units."
      }
    }
  },
  {
    "id": "EXP-MS-0337",
    "component": "Structuring Mule Apps – Deployment Independence",
    "difficulty": "Extreme",
    "question": "What enables independent deployment of applications?",
    "options": {
      "A": "Shared object stores",
      "B": "Loose coupling via APIs",
      "C": "Shared domains",
      "D": "Common XML configs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling allows independent lifecycle management.",
      "incorrect": {
        "A": "Creates dependency.",
        "C": "Still coupled.",
        "D": "Not independent."
      }
    }
  },
  {
    "id": "EXP-MS-0338",
    "component": "Structuring Mule Apps – Flow Testability",
    "difficulty": "Extreme",
    "question": "Which design choice most improves MUnit testability?",
    "options": {
      "A": "Deep flow-ref chains",
      "B": "Large monolithic flows",
      "C": "Small composable flows",
      "D": "Heavy use of async"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Composable flows are easier to mock and test.",
      "incorrect": {
        "A": "Hard to isolate.",
        "B": "Hard to test.",
        "D": "Async complicates testing."
      }
    }
  },
  {
    "id": "EXP-MS-0339",
    "component": "Structuring Mule Apps – Runtime Boundaries",
    "difficulty": "Extreme",
    "question": "What separates one Mule application from another at runtime?",
    "options": {
      "A": "Thread pool",
      "B": "Object store",
      "C": "Classloader",
      "D": "Scheduler"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Classloader enforces strict isolation.",
      "incorrect": {
        "A": "Shared.",
        "B": "Can be shared.",
        "D": "Execution trigger only."
      }
    }
  },
  {
    "id": "EXP-MS-0340",
    "component": "Structuring Mule Apps – Structural Smell",
    "difficulty": "Extreme",
    "question": "Which is a strong structural anti-pattern?",
    "options": {
      "A": "Using subflows",
      "B": "Hardcoding environment URLs",
      "C": "Externalized properties",
      "D": "Layered APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hardcoding breaks environment portability.",
      "incorrect": {
        "A": "Valid pattern.",
        "C": "Best practice.",
        "D": "Recommended."
      }
    }
  },

  {
    "id": "EXP-MS-0341",
    "component": "Structuring Mule Apps – Horizontal Scaling",
    "difficulty": "Extreme",
    "question": "What must be true for safe horizontal scaling?",
    "options": {
      "A": "Flows are stateful",
      "B": "State is externalized",
      "C": "Single worker only",
      "D": "Synchronous processing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Externalized state avoids node affinity.",
      "incorrect": {
        "A": "Stateful flows break scaling.",
        "C": "Scaling requires multiple workers.",
        "D": "Sync vs async irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0342",
    "component": "Structuring Mule Apps – Restart Safety",
    "difficulty": "Extreme",
    "question": "What design prevents data loss during restarts?",
    "options": {
      "A": "Variables",
      "B": "In-memory caching",
      "C": "Persistent object store",
      "D": "Flow-ref"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Persistent stores survive restarts.",
      "incorrect": {
        "A": "Variables are transient.",
        "B": "Memory is lost.",
        "D": "Flow-ref irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0343",
    "component": "Structuring Mule Apps – Code Ownership",
    "difficulty": "Extreme",
    "question": "Why is clear ownership per application important?",
    "options": {
      "A": "Faster builds",
      "B": "Clear accountability and evolution",
      "C": "Lower latency",
      "D": "Reduced XML size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ownership ensures controlled evolution.",
      "incorrect": {
        "A": "Build speed unrelated.",
        "C": "Latency unrelated.",
        "D": "Size unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0344",
    "component": "Structuring Mule Apps – Structural Completion",
    "difficulty": "Extreme",
    "question": "What signals completion of a well-structured Mule application?",
    "options": {
      "A": "Minimal files",
      "B": "Clear separation of concerns",
      "C": "Maximum reuse",
      "D": "Highest throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear separation is the primary indicator.",
      "incorrect": {
        "A": "File count is secondary.",
        "C": "Reuse is a benefit, not a signal.",
        "D": "Throughput is operational."
      }
    }
  },
  {
    "id": "EXP-MS-0345",
    "component": "Structuring Mule Apps – Boundary Definition",
    "difficulty": "Extreme",
    "question": "What defines the boundary of a Mule application?",
    "options": {
      "A": "Flows",
      "B": "RAML",
      "C": "Deployment unit",
      "D": "Object store"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The deployable artifact defines the boundary.",
      "incorrect": {
        "A": "Flows are internal.",
        "B": "RAML is a contract.",
        "D": "Storage is shared."
      }
    }
  },

  {
    "id": "EXP-MS-0346",
    "component": "Structuring Mule Apps – Evolution Strategy",
    "difficulty": "Extreme",
    "question": "What best supports long-term application evolution?",
    "options": {
      "A": "Hardcoded logic",
      "B": "Loose coupling and versioned APIs",
      "C": "Single large flow",
      "D": "Shared databases"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling enables independent evolution.",
      "incorrect": {
        "A": "Hard to change.",
        "C": "Rigid structure.",
        "D": "Tight coupling."
      }
    }
  },
  {
    "id": "EXP-MS-0347",
    "component": "Structuring Mule Apps – Operational Stability",
    "difficulty": "Extreme",
    "question": "Which structural choice most improves operational stability?",
    "options": {
      "A": "Complex flow logic",
      "B": "Clear layering and ownership",
      "C": "High concurrency",
      "D": "Large payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear structure reduces operational risk.",
      "incorrect": {
        "A": "Complexity increases risk.",
        "C": "Concurrency is orthogonal.",
        "D": "Payload size irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0348",
    "component": "Structuring Mule Apps – Final Anti-Pattern",
    "difficulty": "Extreme",
    "question": "Which choice is the strongest indicator of poor structure?",
    "options": {
      "A": "Reusable subflows",
      "B": "Externalized configuration",
      "C": "Business logic in System APIs",
      "D": "Versioned APIs"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Business logic must not live in System APIs.",
      "incorrect": {
        "A": "Best practice.",
        "B": "Best practice.",
        "D": "Best practice."
      }
    }
  },
  {
    "id": "EXP-MS-0349",
    "component": "Structuring Mule Apps – Structural Principle",
    "difficulty": "Extreme",
    "question": "Which principle most strongly governs Mule application structure?",
    "options": {
      "A": "DRY",
      "B": "Separation of concerns",
      "C": "YAGNI",
      "D": "Premature optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Separation of concerns is foundational.",
      "incorrect": {
        "A": "Secondary.",
        "C": "Design heuristic.",
        "D": "Anti-pattern."
      }
    }
  },
  {
    "id": "EXP-MS-0350",
    "component": "Structuring Mule Apps – Section Closure",
    "difficulty": "Extreme",
    "question": "What confirms readiness to move to API implementation?",
    "options": {
      "A": "All flows created",
      "B": "Stable structure with clear boundaries",
      "C": "Maximum test coverage",
      "D": "Production deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "A stable structure is prerequisite for implementation.",
      "incorrect": {
        "A": "Flows alone are insufficient.",
        "C": "Testing follows structure.",
        "D": "Deployment is later."
      }
    }
  },
  {
    "id": "EXP-MS-0351",
    "component": "API Implementation – APIkit Routing",
    "difficulty": "Extreme",
    "question": "Given a RAML with resource `/orders/{id}` and method `get`, what determines the APIkit flow name?",
    "options": {
      "A": "Resource displayName",
      "B": "HTTP method only",
      "C": "Resource path and method",
      "D": "Listener path"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit generates flows based on resource path + HTTP method.",
      "incorrect": {
        "A": "displayName is descriptive.",
        "B": "Method alone is insufficient.",
        "D": "Listener path does not define routing."
      }
    }
  },
  {
    "id": "EXP-MS-0352",
    "component": "API Implementation – APIkit Validation",
    "difficulty": "Extreme",
    "question": "What happens when an incoming request violates a RAML-required query parameter?",
    "options": {
      "A": "Flow executes with null",
      "B": "400 returned by APIkit",
      "C": "500 thrown",
      "D": "Validation skipped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit performs request validation and returns 400.",
      "incorrect": {
        "A": "Execution is blocked.",
        "C": "Not a server error.",
        "D": "Validation is enforced."
      }
    }
  },
  {
    "id": "EXP-MS-0353",
    "component": "API Implementation – Manual vs APIkit",
    "difficulty": "Extreme",
    "question": "What is the primary risk when manually implementing APIs without APIkit?",
    "options": {
      "A": "Lower performance",
      "B": "Contract drift from RAML",
      "C": "Policy incompatibility",
      "D": "Listener conflicts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Manual implementations risk deviating from the contract.",
      "incorrect": {
        "A": "Performance is similar.",
        "C": "Policies are independent.",
        "D": "Listeners are orthogonal."
      }
    }
  },
  {
    "id": "EXP-MS-0354",
    "component": "API Implementation – APIkit Error Mapping",
    "difficulty": "Extreme",
    "question": "Which error type does APIkit throw for an unsupported HTTP method?",
    "options": {
      "A": "APIKIT:NOT_FOUND",
      "B": "APIKIT:METHOD_NOT_ALLOWED",
      "C": "HTTP:BAD_REQUEST",
      "D": "MULE:UNKNOWN"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit maps unsupported methods to METHOD_NOT_ALLOWED.",
      "incorrect": {
        "A": "Path exists.",
        "C": "Request syntax is valid.",
        "D": "Not a generic error."
      }
    }
  },
  {
    "id": "EXP-MS-0355",
    "component": "API Implementation – Response Selection",
    "difficulty": "Extreme",
    "question": "How does APIkit select the response schema?",
    "options": {
      "A": "First defined in RAML",
      "B": "Based on HTTP status set by flow",
      "C": "Always 200",
      "D": "Randomly"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit selects response based on status code.",
      "incorrect": {
        "A": "Order is irrelevant.",
        "C": "Not always 200.",
        "D": "Never random."
      }
    }
  },

  {
    "id": "EXP-MS-0356",
    "component": "API Implementation – RAML Optional Body",
    "difficulty": "Extreme",
    "question": "If a RAML request body is optional and omitted, what does APIkit do?",
    "options": {
      "A": "Throws 400",
      "B": "Sets payload to null",
      "C": "Skips validation",
      "D": "Uses empty object"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Payload becomes null when optional body is missing.",
      "incorrect": {
        "A": "Optional means allowed.",
        "C": "Other validations still run.",
        "D": "No implicit object."
      }
    }
  },
  {
    "id": "EXP-MS-0357",
    "component": "API Implementation – APIkit Base URI",
    "difficulty": "Extreme",
    "question": "What is the effect of changing baseUri in RAML?",
    "options": {
      "A": "Flow names change",
      "B": "Listener path changes",
      "C": "No runtime effect",
      "D": "Policy behavior changes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "baseUri is descriptive and does not affect runtime routing.",
      "incorrect": {
        "A": "Flow names depend on resources.",
        "B": "Listener path is configured separately.",
        "D": "Policies are unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0358",
    "component": "API Implementation – APIkit Console",
    "difficulty": "Extreme",
    "question": "Why should API Console be disabled in production?",
    "options": {
      "A": "Performance impact",
      "B": "Security exposure",
      "C": "Memory leak",
      "D": "Policy conflict"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API Console exposes API structure publicly.",
      "incorrect": {
        "A": "Negligible.",
        "C": "No leak.",
        "D": "Policies unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0359",
    "component": "API Implementation – APIkit Router",
    "difficulty": "Extreme",
    "question": "Which component performs request dispatching in APIkit?",
    "options": {
      "A": "HTTP Listener",
      "B": "APIkit Router",
      "C": "Choice Router",
      "D": "Flow-ref"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit Router routes requests to resource flows.",
      "incorrect": {
        "A": "Listener receives only.",
        "C": "Choice is manual.",
        "D": "Flow-ref is internal."
      }
    }
  },
  {
    "id": "EXP-MS-0360",
    "component": "API Implementation – RAML Traits",
    "difficulty": "Extreme",
    "question": "How are RAML traits applied at runtime?",
    "options": {
      "A": "Automatically executed",
      "B": "Merged into resource definition",
      "C": "Ignored by Mule",
      "D": "Converted to policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traits are design-time merges into resources.",
      "incorrect": {
        "A": "No execution.",
        "C": "They influence validation.",
        "D": "Policies are separate."
      }
    }
  },

  {
    "id": "EXP-MS-0361",
    "component": "API Implementation – APIkit Error Flow",
    "difficulty": "Extreme",
    "question": "Which flow handles APIkit errors globally?",
    "options": {
      "A": "api-main",
      "B": "api-console",
      "C": "apiKitGlobalExceptionMapping",
      "D": "http-error-handler"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit provides a global exception mapping flow.",
      "incorrect": {
        "A": "Main routes requests.",
        "B": "Console is UI.",
        "D": "Generic."
      }
    }
  },
  {
    "id": "EXP-MS-0362",
    "component": "API Implementation – Multiple RAMLs",
    "difficulty": "Extreme",
    "question": "Can a single Mule app host multiple APIkit routers?",
    "options": {
      "A": "No",
      "B": "Yes, with separate listeners",
      "C": "Yes, with one listener",
      "D": "Only on CloudHub"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each APIkit router must be bound to a listener.",
      "incorrect": {
        "A": "Supported.",
        "C": "Ambiguous routing.",
        "D": "Platform-independent."
      }
    }
  },
  {
    "id": "EXP-MS-0363",
    "component": "API Implementation – Manual Status Codes",
    "difficulty": "Extreme",
    "question": "How do you return a non-200 response from an APIkit flow?",
    "options": {
      "A": "Throw error",
      "B": "Set payload only",
      "C": "Set attributes.statusCode",
      "D": "Use logger"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Status code must be set in attributes.",
      "incorrect": {
        "A": "Errors differ from responses.",
        "B": "Payload alone is insufficient.",
        "D": "Logger has no effect."
      }
    }
  },
  {
    "id": "EXP-MS-0364",
    "component": "API Implementation – RAML Examples",
    "difficulty": "Extreme",
    "question": "What is the runtime impact of RAML examples?",
    "options": {
      "A": "Used for validation",
      "B": "Used for mocking only",
      "C": "No runtime impact",
      "D": "Affects payload shape"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Examples are documentation-only.",
      "incorrect": {
        "A": "Schemas validate, not examples.",
        "B": "Mocking is optional tooling.",
        "D": "Payload unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0365",
    "component": "API Implementation – RAML Libraries",
    "difficulty": "Extreme",
    "question": "What is the primary benefit of RAML libraries?",
    "options": {
      "A": "Faster runtime",
      "B": "Reuse of types and traits",
      "C": "Policy enforcement",
      "D": "Flow generation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Libraries promote reuse and consistency.",
      "incorrect": {
        "A": "No runtime effect.",
        "C": "Policies are separate.",
        "D": "Flows depend on resources."
      }
    }
  },

  {
    "id": "EXP-MS-0366",
    "component": "API Implementation – APIkit Performance",
    "difficulty": "Extreme",
    "question": "What is the main performance overhead of APIkit?",
    "options": {
      "A": "Network latency",
      "B": "Request validation",
      "C": "Thread creation",
      "D": "Serialization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schema validation adds overhead.",
      "incorrect": {
        "A": "No extra network calls.",
        "C": "Threads are reused.",
        "D": "Serialization is unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0367",
    "component": "API Implementation – APIkit Disable Validation",
    "difficulty": "Extreme",
    "question": "Why is disabling APIkit validation risky?",
    "options": {
      "A": "Lower performance",
      "B": "Contract violations reach backend",
      "C": "Policies stop working",
      "D": "Flows stop routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Invalid requests can reach downstream systems.",
      "incorrect": {
        "A": "Performance improves.",
        "C": "Policies still apply.",
        "D": "Routing still works."
      }
    }
  },
  {
    "id": "EXP-MS-0368",
    "component": "API Implementation – RAML Versioning",
    "difficulty": "Extreme",
    "question": "What is the safest way to version breaking API changes?",
    "options": {
      "A": "New query parameter",
      "B": "New header",
      "C": "New base path",
      "D": "Same endpoint"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "New base path isolates breaking changes.",
      "incorrect": {
        "A": "Ambiguous.",
        "B": "Hard to enforce.",
        "D": "Breaks clients."
      }
    }
  },
  {
    "id": "EXP-MS-0369",
    "component": "API Implementation – APIkit Autodiscovery",
    "difficulty": "Extreme",
    "question": "What is required for API autodiscovery?",
    "options": {
      "A": "API Console",
      "B": "API Manager ID",
      "C": "RAML examples",
      "D": "TLS config"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Autodiscovery binds app to API Manager via ID.",
      "incorrect": {
        "A": "Console is optional.",
        "C": "Examples irrelevant.",
        "D": "TLS is optional."
      }
    }
  },
  {
    "id": "EXP-MS-0370",
    "component": "API Implementation – Flow Granularity",
    "difficulty": "Extreme",
    "question": "What is the best practice for APIkit resource flows?",
    "options": {
      "A": "Embed all logic",
      "B": "Delegate to process flows",
      "C": "Use subflows only",
      "D": "Use async always"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API layer should delegate business logic.",
      "incorrect": {
        "A": "Violates layering.",
        "C": "Subflows are internal.",
        "D": "Async is situational."
      }
    }
  },

  {
    "id": "EXP-MS-0371",
    "component": "API Implementation – RAML Nullable",
    "difficulty": "Extreme",
    "question": "How does APIkit treat nullable fields in RAML?",
    "options": {
      "A": "Always rejected",
      "B": "Allowed when null",
      "C": "Converted to empty",
      "D": "Ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Nullable fields accept null values.",
      "incorrect": {
        "A": "Contradicts RAML.",
        "C": "No conversion.",
        "D": "Still validated."
      }
    }
  },
  {
    "id": "EXP-MS-0372",
    "component": "API Implementation – Error vs Response",
    "difficulty": "Extreme",
    "question": "What distinguishes an error from a non-2xx response?",
    "options": {
      "A": "Status code only",
      "B": "Thrown exception",
      "C": "Payload structure",
      "D": "Listener type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors are thrown exceptions, not responses.",
      "incorrect": {
        "A": "Responses can be non-2xx.",
        "C": "Structure varies.",
        "D": "Listener irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0373",
    "component": "API Implementation – APIkit Mocking",
    "difficulty": "Extreme",
    "question": "What enables mocking without backend implementation?",
    "options": {
      "A": "Examples",
      "B": "Schemas",
      "C": "APIkit Console",
      "D": "Policies"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "API Console can mock using examples.",
      "incorrect": {
        "A": "Examples alone do not mock.",
        "B": "Schemas validate only.",
        "D": "Policies do not mock."
      }
    }
  },
  {
    "id": "EXP-MS-0374",
    "component": "API Implementation – Response Headers",
    "difficulty": "Extreme",
    "question": "How are response headers set in APIkit?",
    "options": {
      "A": "Payload",
      "B": "vars",
      "C": "attributes.headers",
      "D": "Listener config"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Headers are set via attributes.headers.",
      "incorrect": {
        "A": "Payload is body.",
        "B": "Vars are internal.",
        "D": "Listener is static."
      }
    }
  },
  {
    "id": "EXP-MS-0375",
    "component": "API Implementation – RAML Default Values",
    "difficulty": "Extreme",
    "question": "When does RAML default value apply?",
    "options": {
      "A": "Always",
      "B": "When field missing",
      "C": "When field null",
      "D": "Never"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defaults apply only when field is absent.",
      "incorrect": {
        "A": "Not unconditional.",
        "C": "Null is explicit.",
        "D": "Defaults are used."
      }
    }
  },

  {
    "id": "EXP-MS-0376",
    "component": "API Implementation – Content-Type Mismatch",
    "difficulty": "Extreme",
    "question": "What happens if Content-Type does not match RAML?",
    "options": {
      "A": "Payload coerced",
      "B": "400 returned",
      "C": "Flow executes",
      "D": "500 thrown"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit rejects unsupported media types.",
      "incorrect": {
        "A": "No coercion.",
        "C": "Execution blocked.",
        "D": "Not a server error."
      }
    }
  },
  {
    "id": "EXP-MS-0377",
    "component": "API Implementation – Multiple Responses",
    "difficulty": "Extreme",
    "question": "Can a single resource define multiple responses?",
    "options": {
      "A": "No",
      "B": "Yes, per status code",
      "C": "Only one allowed",
      "D": "Only 200 and 500"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RAML supports multiple responses per status code.",
      "incorrect": {
        "A": "Incorrect.",
        "C": "Not limited.",
        "D": "Not restricted."
      }
    }
  },
  {
    "id": "EXP-MS-0378",
    "component": "API Implementation – APIkit Router Placement",
    "difficulty": "Extreme",
    "question": "Where must APIkit Router be placed?",
    "options": {
      "A": "Inside subflow",
      "B": "Immediately after listener",
      "C": "At end of flow",
      "D": "Inside try scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Router must immediately follow listener.",
      "incorrect": {
        "A": "Subflows cannot receive requests.",
        "C": "Routing must occur early.",
        "D": "Not recommended."
      }
    }
  },
  {
    "id": "EXP-MS-0379",
    "component": "API Implementation – RAML Security Schemes",
    "difficulty": "Extreme",
    "question": "What is the runtime effect of RAML security schemes?",
    "options": {
      "A": "Automatically enforced",
      "B": "Converted to policies",
      "C": "Documentation-only unless enforced by policies",
      "D": "Ignored"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Security schemes require policies for enforcement.",
      "incorrect": {
        "A": "Not automatic.",
        "B": "Manual policy application needed.",
        "D": "They guide design."
      }
    }
  },
  {
    "id": "EXP-MS-0380",
    "component": "API Implementation – Section Progress",
    "difficulty": "Extreme",
    "question": "What confirms a correct API implementation layer?",
    "options": {
      "A": "No errors",
      "B": "Strict adherence to RAML contract",
      "C": "High throughput",
      "D": "Minimal code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract adherence is the defining criterion.",
      "incorrect": {
        "A": "Errors may still occur.",
        "C": "Performance is secondary.",
        "D": "Minimal code is not the goal."
      }
    }
  },
  {
    "id": "EXP-MS-0381",
    "component": "API Implementation – APIkit Flow Resolution",
    "difficulty": "Extreme",
    "question": "What happens if an APIkit-generated resource flow is missing?",
    "options": {
      "A": "Request is ignored",
      "B": "APIkit throws NOT_IMPLEMENTED",
      "C": "500 Internal Server Error",
      "D": "Fallback to default flow"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit returns NOT_IMPLEMENTED when the flow is absent.",
      "incorrect": {
        "A": "Requests are not ignored.",
        "C": "This is not a runtime failure.",
        "D": "No fallback exists."
      }
    }
  },
  {
    "id": "EXP-MS-0382",
    "component": "API Implementation – RAML Method Absence",
    "difficulty": "Extreme",
    "question": "If a RAML resource exists but method is undefined, what is returned?",
    "options": {
      "A": "404",
      "B": "400",
      "C": "405",
      "D": "500"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Undefined HTTP method results in 405 Method Not Allowed.",
      "incorrect": {
        "A": "Resource exists.",
        "B": "Request is syntactically valid.",
        "D": "Not a server error."
      }
    }
  },
  {
    "id": "EXP-MS-0383",
    "component": "API Implementation – RAML Resource Resolution",
    "difficulty": "Extreme",
    "question": "How does APIkit match URI parameters at runtime?",
    "options": {
      "A": "Regex evaluation",
      "B": "Exact string match",
      "C": "Template-based resolution",
      "D": "Hash lookup"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "URI parameters are resolved using RAML templates.",
      "incorrect": {
        "A": "Regex is not used directly.",
        "B": "Exact match is insufficient.",
        "D": "No hashing occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0384",
    "component": "API Implementation – APIkit Exception Strategy",
    "difficulty": "Extreme",
    "question": "Where should APIkit errors be transformed into custom responses?",
    "options": {
      "A": "Resource flow",
      "B": "Global error handler",
      "C": "Listener",
      "D": "Policy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Global error handlers centralize APIkit error mapping.",
      "incorrect": {
        "A": "Resource flows are bypassed.",
        "C": "Listeners do not handle errors.",
        "D": "Policies are external."
      }
    }
  },
  {
    "id": "EXP-MS-0385",
    "component": "API Implementation – RAML Type Enforcement",
    "difficulty": "Extreme",
    "question": "What enforces RAML data types at runtime?",
    "options": {
      "A": "DataWeave",
      "B": "APIkit validation",
      "C": "HTTP Listener",
      "D": "JSON parser"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit performs schema-based validation.",
      "incorrect": {
        "A": "DW transforms only.",
        "C": "Listener does not validate schema.",
        "D": "Parsing ≠ validation."
      }
    }
  },
  {
    "id": "EXP-MS-0386",
    "component": "API Implementation – RAML Union Types",
    "difficulty": "Extreme",
    "question": "How does APIkit validate RAML union types?",
    "options": {
      "A": "Must match all types",
      "B": "Must match at least one type",
      "C": "Skipped validation",
      "D": "Always rejected"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Union types validate if at least one type matches.",
      "incorrect": {
        "A": "That is intersection behavior.",
        "C": "Validation is enforced.",
        "D": "Untrue."
      }
    }
  },
  {
    "id": "EXP-MS-0387",
    "component": "API Implementation – Query Param Coercion",
    "difficulty": "Extreme",
    "question": "If a query parameter type is integer and value is '10', what occurs?",
    "options": {
      "A": "Rejected",
      "B": "Coerced to integer",
      "C": "Treated as string",
      "D": "Null assigned"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit coerces compatible scalar values.",
      "incorrect": {
        "A": "Value is valid.",
        "C": "Type is enforced.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0388",
    "component": "API Implementation – Header Validation",
    "difficulty": "Extreme",
    "question": "If a required header is missing, what is returned?",
    "options": {
      "A": "404",
      "B": "401",
      "C": "400",
      "D": "403"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Missing required headers cause a 400 Bad Request.",
      "incorrect": {
        "A": "Resource exists.",
        "B": "Auth is not implied.",
        "D": "Authorization not evaluated."
      }
    }
  },
  {
    "id": "EXP-MS-0389",
    "component": "API Implementation – APIkit Router Scope",
    "difficulty": "Extreme",
    "question": "What scope does APIkit Router operate in?",
    "options": {
      "A": "Request scope",
      "B": "Application scope",
      "C": "Flow scope",
      "D": "Session scope"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit Router is a flow-level routing component.",
      "incorrect": {
        "A": "Not request-scoped.",
        "B": "Not global.",
        "D": "Sessions are not used."
      }
    }
  },
  {
    "id": "EXP-MS-0390",
    "component": "API Implementation – RAML Multiple Media Types",
    "difficulty": "Extreme",
    "question": "If RAML defines JSON and XML, how does APIkit choose?",
    "options": {
      "A": "First defined",
      "B": "Randomly",
      "C": "Based on Content-Type",
      "D": "Always JSON"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Content-Type header determines media type.",
      "incorrect": {
        "A": "Order irrelevant.",
        "B": "Never random.",
        "D": "Not defaulted."
      }
    }
  },
  {
    "id": "EXP-MS-0391",
    "component": "API Implementation – APIkit and Policies",
    "difficulty": "Extreme",
    "question": "In what order are policies applied relative to APIkit?",
    "options": {
      "A": "After APIkit routing",
      "B": "Before APIkit routing",
      "C": "Only on resource flows",
      "D": "Only on responses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policies execute before APIkit routing.",
      "incorrect": {
        "A": "Routing happens later.",
        "C": "Policies apply globally.",
        "D": "They affect requests too."
      }
    }
  },
  {
    "id": "EXP-MS-0392",
    "component": "API Implementation – RAML Enum",
    "difficulty": "Extreme",
    "question": "If a value not in enum is passed, what happens?",
    "options": {
      "A": "Accepted",
      "B": "Coerced",
      "C": "400 returned",
      "D": "500 returned"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Enum violations cause validation failure.",
      "incorrect": {
        "A": "Invalid.",
        "B": "Enums are strict.",
        "D": "Not a server error."
      }
    }
  },
  {
    "id": "EXP-MS-0393",
    "component": "API Implementation – RAML Required False",
    "difficulty": "Extreme",
    "question": "If required:false field is omitted, what occurs?",
    "options": {
      "A": "Rejected",
      "B": "Null inserted",
      "C": "Field absent in payload",
      "D": "Default applied"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Optional fields may be absent.",
      "incorrect": {
        "A": "Allowed.",
        "B": "Not auto-inserted.",
        "D": "Only if default defined."
      }
    }
  },
  {
    "id": "EXP-MS-0394",
    "component": "API Implementation – RAML Example Mismatch",
    "difficulty": "Extreme",
    "question": "If example contradicts schema, what is enforced?",
    "options": {
      "A": "Example",
      "B": "Schema",
      "C": "First declared",
      "D": "Ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schema always takes precedence.",
      "incorrect": {
        "A": "Examples are informational.",
        "C": "Order irrelevant.",
        "D": "Validation still applies."
      }
    }
  },
  {
    "id": "EXP-MS-0395",
    "component": "API Implementation – Error vs Validation",
    "difficulty": "Extreme",
    "question": "Is a RAML validation failure an application error?",
    "options": {
      "A": "Yes",
      "B": "No, it is a client error",
      "C": "Sometimes",
      "D": "Only in production"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation failures are client-side errors.",
      "incorrect": {
        "A": "Application logic is not executed.",
        "C": "Deterministic.",
        "D": "Environment-independent."
      }
    }
  },
  {
    "id": "EXP-MS-0396",
    "component": "API Implementation – RAML Numeric Bounds",
    "difficulty": "Extreme",
    "question": "If value exceeds maximum, what happens?",
    "options": {
      "A": "Clamped",
      "B": "Coerced",
      "C": "Rejected",
      "D": "Rounded"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Bounds violations fail validation.",
      "incorrect": {
        "A": "No clamping.",
        "B": "No coercion.",
        "D": "No rounding."
      }
    }
  },
  {
    "id": "EXP-MS-0397",
    "component": "API Implementation – RAML Pattern",
    "difficulty": "Extreme",
    "question": "What enforces string pattern constraints?",
    "options": {
      "A": "Regex in DataWeave",
      "B": "APIkit validation",
      "C": "HTTP Listener",
      "D": "Custom code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIkit enforces RAML regex patterns.",
      "incorrect": {
        "A": "Manual alternative.",
        "C": "No validation.",
        "D": "Not automatic."
      }
    }
  },
  {
    "id": "EXP-MS-0398",
    "component": "API Implementation – RAML Additional Properties",
    "difficulty": "Extreme",
    "question": "If additionalProperties is false and extra field sent?",
    "options": {
      "A": "Ignored",
      "B": "Accepted",
      "C": "Rejected",
      "D": "Stored in vars"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Extra fields violate schema and are rejected.",
      "incorrect": {
        "A": "Not ignored.",
        "B": "Invalid.",
        "D": "No auto-storage."
      }
    }
  },
  {
    "id": "EXP-MS-0399",
    "component": "API Implementation – RAML Type Inheritance",
    "difficulty": "Extreme",
    "question": "Child type violates parent constraint. Outcome?",
    "options": {
      "A": "Accepted",
      "B": "Rejected",
      "C": "Parent ignored",
      "D": "Runtime error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Child must satisfy parent constraints.",
      "incorrect": {
        "A": "Invalid.",
        "C": "Inheritance enforced.",
        "D": "Validation error, not runtime."
      }
    }
  },
  {
    "id": "EXP-MS-0400",
    "component": "API Implementation – APIkit Router Failure",
    "difficulty": "Extreme",
    "question": "If router fails before resource resolution, what returns?",
    "options": {
      "A": "404",
      "B": "500",
      "C": "APIkit error response",
      "D": "No response"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit returns mapped router errors.",
      "incorrect": {
        "A": "Path may exist.",
        "B": "Not internal failure.",
        "D": "Response always returned."
      }
    }
  },
  {
    "id": "EXP-MS-0401",
    "component": "API Implementation – RAML Boolean Coercion",
    "difficulty": "Extreme",
    "question": "If boolean param is 'true' as string, what happens?",
    "options": {
      "A": "Rejected",
      "B": "Converted to boolean",
      "C": "Left as string",
      "D": "Null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scalar coercion is applied when compatible.",
      "incorrect": {
        "A": "Valid value.",
        "C": "Type enforced.",
        "D": "Not null."
      }
    }
  },
  {
    "id": "EXP-MS-0402",
    "component": "API Implementation – RAML Array Constraints",
    "difficulty": "Extreme",
    "question": "If minItems violated, what happens?",
    "options": {
      "A": "Padding applied",
      "B": "Ignored",
      "C": "Rejected",
      "D": "Null array"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Array constraints are strictly enforced.",
      "incorrect": {
        "A": "No padding.",
        "B": "Not ignored.",
        "D": "No nulling."
      }
    }
  },
  {
    "id": "EXP-MS-0403",
    "component": "API Implementation – APIkit and DW",
    "difficulty": "Extreme",
    "question": "Does DataWeave run before or after APIkit validation?",
    "options": {
      "A": "Before",
      "B": "After",
      "C": "In parallel",
      "D": "Never"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DW executes only after successful validation.",
      "incorrect": {
        "A": "Validation blocks execution.",
        "C": "No parallel execution.",
        "D": "DW is used."
      }
    }
  },
  {
    "id": "EXP-MS-0404",
    "component": "API Implementation – Contract-First Failure",
    "difficulty": "Extreme",
    "question": "What breaks contract-first approach?",
    "options": {
      "A": "Strict RAML",
      "B": "Manual undocumented changes",
      "C": "APIkit usage",
      "D": "Schema reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Undocumented changes violate contract-first.",
      "incorrect": {
        "A": "Encouraged.",
        "C": "Supports contract-first.",
        "D": "Promotes consistency."
      }
    }
  },
  {
    "id": "EXP-MS-0405",
    "component": "API Implementation – RAML Resource Nesting",
    "difficulty": "Extreme",
    "question": "Does nested resource affect flow naming?",
    "options": {
      "A": "No",
      "B": "Yes, full path used",
      "C": "Only parent used",
      "D": "Random"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Full resource path defines flow name.",
      "incorrect": {
        "A": "Incorrect.",
        "C": "Incomplete.",
        "D": "Never random."
      }
    }
  },
  {
    "id": "EXP-MS-0406",
    "component": "API Implementation – RAML Optional Query",
    "difficulty": "Extreme",
    "question": "Optional query param missing results in?",
    "options": {
      "A": "400",
      "B": "Null value",
      "C": "Absent param",
      "D": "Default only"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Optional params may be absent.",
      "incorrect": {
        "A": "Not required.",
        "B": "Not auto-null.",
        "D": "Only if default defined."
      }
    }
  },
  {
    "id": "EXP-MS-0407",
    "component": "API Implementation – RAML Object Required",
    "difficulty": "Extreme",
    "question": "If required object is missing entirely?",
    "options": {
      "A": "Accepted",
      "B": "Rejected",
      "C": "Empty object",
      "D": "Null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Required objects must be present.",
      "incorrect": {
        "A": "Invalid.",
        "C": "Not auto-created.",
        "D": "Null not allowed."
      }
    }
  },
  {
    "id": "EXP-MS-0408",
    "component": "API Implementation – RAML Type Facets",
    "difficulty": "Extreme",
    "question": "Which are enforced as facets?",
    "options": {
      "A": "description",
      "B": "example",
      "C": "minLength",
      "D": "displayName"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Facets like minLength enforce constraints.",
      "incorrect": {
        "A": "Documentation only.",
        "B": "Documentation only.",
        "D": "Documentation only."
      }
    }
  },
  {
    "id": "EXP-MS-0409",
    "component": "API Implementation – APIkit Error Type",
    "difficulty": "Extreme",
    "question": "Which error type indicates schema validation failure?",
    "options": {
      "A": "APIKIT:BAD_REQUEST",
      "B": "APIKIT:NOT_FOUND",
      "C": "MULE:EXPRESSION",
      "D": "HTTP:BAD_REQUEST"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "BAD_REQUEST is used for validation errors.",
      "incorrect": {
        "B": "Resource missing.",
        "C": "Expression failure.",
        "D": "Not APIkit-specific."
      }
    }
  },
  {
    "id": "EXP-MS-0410",
    "component": "API Implementation – APIkit Routing Completeness",
    "difficulty": "Extreme",
    "question": "What guarantees full API coverage?",
    "options": {
      "A": "All flows implemented",
      "B": "All RAML resources implemented",
      "C": "No errors at runtime",
      "D": "High test coverage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Every RAML resource must be implemented.",
      "incorrect": {
        "A": "Flows may exist but not mapped.",
        "C": "Errors may still occur.",
        "D": "Testing does not guarantee coverage."
      }
    }
  },
  {
    "id": "EXP-MS-0411",
    "component": "API Implementation – APIkit Finalization",
    "difficulty": "Extreme",
    "question": "When is API implementation considered complete?",
    "options": {
      "A": "When deployed",
      "B": "When contract and implementation align",
      "C": "When performance is optimal",
      "D": "When no warnings exist"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Completion means strict contract adherence.",
      "incorrect": {
        "A": "Deployment is not a quality measure.",
        "C": "Performance is secondary.",
        "D": "Warnings may remain."
      }
    }
  },
  {
    "id": "EXP-MS-0412",
    "component": "API Implementation – Section Closure",
    "difficulty": "Extreme",
    "question": "What is the primary goal of API implementation interfaces?",
    "options": {
      "A": "Expose backend logic",
      "B": "Enforce API contract correctly",
      "C": "Improve throughput",
      "D": "Reduce code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The goal is correct contract enforcement.",
      "incorrect": {
        "A": "Backend should be abstracted.",
        "C": "Performance is secondary.",
        "D": "Code size is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0413",
    "component": "API Implementation – RAML Response Headers Validation",
    "difficulty": "Extreme",
    "question": "If RAML defines a required response header and the flow does not set it, what happens?",
    "options": {
      "A": "Response is sent without header",
      "B": "APIkit adds header automatically",
      "C": "Validation error is thrown",
      "D": "Header is set to null"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "APIkit validates response headers defined as required.",
      "incorrect": {
        "A": "Missing required headers violate contract.",
        "B": "APIkit does not auto-generate headers.",
        "D": "Null is invalid."
      }
    }
  },
  {
    "id": "EXP-MS-0414",
    "component": "API Implementation – Multiple APIkit Routers",
    "difficulty": "Extreme",
    "question": "What happens if two APIkit routers listen on the same listener path?",
    "options": {
      "A": "Round-robin routing",
      "B": "First router wins",
      "C": "Application fails at startup",
      "D": "Last router overrides"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Multiple routers on the same path cause a startup failure.",
      "incorrect": {
        "A": "No routing strategy exists.",
        "B": "No precedence logic.",
        "D": "Overrides are not allowed."
      }
    }
  },
  {
    "id": "EXP-MS-0415",
    "component": "API Implementation – RAML Type Discriminator",
    "difficulty": "Extreme",
    "question": "What is the purpose of a RAML discriminator?",
    "options": {
      "A": "Enforce authorization",
      "B": "Select correct subtype at validation time",
      "C": "Generate multiple flows",
      "D": "Control routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Discriminator selects the correct subtype during validation.",
      "incorrect": {
        "A": "Authorization is policy-based.",
        "C": "Flows are not generated per subtype.",
        "D": "Routing is independent."
      }
    }
  },
  {
    "id": "EXP-MS-0416",
    "component": "API Implementation – RAML Polymorphism Failure",
    "difficulty": "Extreme",
    "question": "If discriminator value does not match any subtype, what occurs?",
    "options": {
      "A": "Fallback to base type",
      "B": "Payload accepted",
      "C": "Validation failure",
      "D": "Subtype ignored"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Invalid discriminator values fail schema validation.",
      "incorrect": {
        "A": "No fallback exists.",
        "B": "Contract violated.",
        "D": "Subtype selection is mandatory."
      }
    }
  },
  {
    "id": "EXP-MS-0417",
    "component": "API Implementation – RAML Response Body Optional",
    "difficulty": "Extreme",
    "question": "If a response body is optional and not set, what is returned?",
    "options": {
      "A": "Empty JSON object",
      "B": "Null payload",
      "C": "No response body",
      "D": "Validation error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Optional response bodies may be omitted entirely.",
      "incorrect": {
        "A": "No implicit object is created.",
        "B": "Null is not sent as body.",
        "D": "Optional means allowed."
      }
    }
  },
  {
    "id": "EXP-MS-0418",
    "component": "API Implementation – APIkit Response Validation Timing",
    "difficulty": "Extreme",
    "question": "When does APIkit validate responses?",
    "options": {
      "A": "Before flow execution",
      "B": "After payload is set but before sending",
      "C": "After response is sent",
      "D": "Only in debug mode"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Response validation occurs just before sending the response.",
      "incorrect": {
        "A": "Request validation happens before execution.",
        "C": "Too late for validation.",
        "D": "Validation is environment-independent."
      }
    }
  },
  {
    "id": "EXP-MS-0419",
    "component": "API Implementation – Contract Drift Detection",
    "difficulty": "Extreme",
    "question": "Which scenario causes silent contract drift?",
    "options": {
      "A": "APIkit validation enabled",
      "B": "Manual implementation without validation",
      "C": "Strict RAML schemas",
      "D": "Response validation enabled"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Manual implementations without validation allow drift.",
      "incorrect": {
        "A": "Prevents drift.",
        "C": "Prevents drift.",
        "D": "Prevents drift."
      }
    }
  },
  {
    "id": "EXP-MS-0420",
    "component": "API Implementation – Section Completion Marker",
    "difficulty": "Extreme",
    "question": "What definitively closes the API Implementation Interfaces section?",
    "options": {
      "A": "All endpoints return 200",
      "B": "Contract-first implementation fully validated",
      "C": "Policies applied",
      "D": "Application deployed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Strict contract-first validation defines completion.",
      "incorrect": {
        "A": "Status codes alone are insufficient.",
        "C": "Policies are orthogonal.",
        "D": "Deployment is not a quality indicator."
      }
    }
  },
  {
    "id": "EXP-MS-0421",
    "component": "Using Connectors – DB Connector Transaction",
    "difficulty": "Extreme",
    "question": "What happens if a DB insert fails inside a transactional scope?",
    "options": {
      "A": "Partial commit",
      "B": "Automatic rollback",
      "C": "Retry occurs",
      "D": "Flow continues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactional scope enforces rollback on failure.",
      "incorrect": {
        "A": "No partial commits allowed.",
        "C": "Retry is not implicit.",
        "D": "Error interrupts flow."
      }
    }
  },
  {
    "id": "EXP-MS-0422",
    "component": "Using Connectors – DB Listener Offset",
    "difficulty": "Extreme",
    "question": "How does DB Listener track processed records?",
    "options": {
      "A": "In memory",
      "B": "Using primary key offset",
      "C": "Using timestamps",
      "D": "Using Object Store"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "DB Listener persists offsets in Object Store.",
      "incorrect": {
        "A": "Not memory-based.",
        "B": "Depends on offset strategy.",
        "C": "Optional, not storage."
      }
    }
  },
  {
    "id": "EXP-MS-0423",
    "component": "Using Connectors – FTP Polling",
    "difficulty": "Extreme",
    "question": "What prevents reprocessing the same file in FTP connector?",
    "options": {
      "A": "File name check",
      "B": "Polling frequency",
      "C": "Watermark / file lock",
      "D": "Flow variables"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "FTP uses watermarks or file locks to prevent duplicates.",
      "incorrect": {
        "A": "Names may repeat.",
        "B": "Frequency does not prevent duplicates.",
        "D": "Vars are transient."
      }
    }
  },
  {
    "id": "EXP-MS-0424",
    "component": "Using Connectors – HTTP Request Timeout",
    "difficulty": "Extreme",
    "question": "If HTTP request times out, what error is thrown?",
    "options": {
      "A": "HTTP:TIMEOUT",
      "B": "HTTP:CONNECTIVITY",
      "C": "MULE:TIMEOUT",
      "D": "HTTP:BAD_RESPONSE"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeouts are reported as connectivity errors.",
      "incorrect": {
        "A": "No such type.",
        "C": "Not Mule core.",
        "D": "Response not received."
      }
    }
  },
  {
    "id": "EXP-MS-0425",
    "component": "Using Connectors – Target Variable",
    "difficulty": "Extreme",
    "question": "What is the effect of setting target on a connector operation?",
    "options": {
      "A": "Payload unchanged",
      "B": "Payload replaced",
      "C": "Result stored in variable",
      "D": "Event duplicated"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Target stores result without overwriting payload.",
      "incorrect": {
        "A": "Payload remains but result stored.",
        "B": "Only without target.",
        "D": "No duplication."
      }
    }
  },

  {
    "id": "EXP-MS-0426",
    "component": "Using Connectors – File Write Encoding",
    "difficulty": "Extreme",
    "question": "If encoding is not specified in File Write, what is used?",
    "options": {
      "A": "UTF-16",
      "B": "Platform default",
      "C": "ASCII",
      "D": "UTF-8 always"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "File connector uses platform default encoding.",
      "incorrect": {
        "A": "Not default.",
        "C": "Rarely default.",
        "D": "Not enforced."
      }
    }
  },
  {
    "id": "EXP-MS-0427",
    "component": "Using Connectors – DB Bulk Insert",
    "difficulty": "Extreme",
    "question": "Which operation is optimal for inserting large datasets?",
    "options": {
      "A": "Insert",
      "B": "Update",
      "C": "Bulk Insert",
      "D": "Select"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Bulk operations reduce round trips.",
      "incorrect": {
        "A": "Row-by-row.",
        "B": "Not insert.",
        "D": "Read only."
      }
    }
  },
  {
    "id": "EXP-MS-0428",
    "component": "Using Connectors – HTTP Request Streaming",
    "difficulty": "Extreme",
    "question": "What enables large payload streaming in HTTP Request?",
    "options": {
      "A": "Chunking",
      "B": "repeatable-in-memory",
      "C": "Streaming strategy",
      "D": "Object Store"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Streaming strategy enables non-blocking large payload handling.",
      "incorrect": {
        "A": "HTTP-level detail.",
        "B": "Opposite of streaming.",
        "D": "Persistence only."
      }
    }
  },
  {
    "id": "EXP-MS-0429",
    "component": "Using Connectors – Connector Lifecycle",
    "difficulty": "Extreme",
    "question": "When is a connector connection initialized?",
    "options": {
      "A": "At application startup",
      "B": "At first request",
      "C": "At compile time",
      "D": "Per operation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connections are lazily initialized.",
      "incorrect": {
        "A": "Not eagerly.",
        "C": "No runtime connection.",
        "D": "Connection reused."
      }
    }
  },
  {
    "id": "EXP-MS-0430",
    "component": "Using Connectors – Retry Scope",
    "difficulty": "Extreme",
    "question": "Which failures should typically be retried?",
    "options": {
      "A": "Validation errors",
      "B": "Business logic errors",
      "C": "Transient connectivity errors",
      "D": "Schema violations"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Retries apply to transient failures.",
      "incorrect": {
        "A": "Permanent.",
        "B": "Logical.",
        "D": "Client error."
      }
    }
  },

  {
    "id": "EXP-MS-0431",
    "component": "Using Connectors – DB Select Streaming",
    "difficulty": "Extreme",
    "question": "How does streaming DB select reduce memory usage?",
    "options": {
      "A": "Loads entire result",
      "B": "Uses pagination",
      "C": "Streams row by row",
      "D": "Caches results"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Rows are streamed incrementally.",
      "incorrect": {
        "A": "Opposite.",
        "B": "Different concept.",
        "D": "Increases memory."
      }
    }
  },
  {
    "id": "EXP-MS-0432",
    "component": "Using Connectors – HTTP TLS",
    "difficulty": "Extreme",
    "question": "Where is TLS configured for HTTP Request?",
    "options": {
      "A": "Listener only",
      "B": "Global TLS config",
      "C": "Per request",
      "D": "Policy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "TLS is defined via global configuration.",
      "incorrect": {
        "A": "Listener is server side.",
        "C": "Not per operation.",
        "D": "Policies are higher level."
      }
    }
  },
  {
    "id": "EXP-MS-0433",
    "component": "Using Connectors – Connector Pooling",
    "difficulty": "Extreme",
    "question": "What controls max concurrent DB connections?",
    "options": {
      "A": "maxConcurrency",
      "B": "poolingProfile",
      "C": "threadCount",
      "D": "scheduler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pooling profile manages connections.",
      "incorrect": {
        "A": "Controls execution.",
        "C": "Not DB related.",
        "D": "Triggers only."
      }
    }
  },
  {
    "id": "EXP-MS-0434",
    "component": "Using Connectors – FTP Rename Strategy",
    "difficulty": "Extreme",
    "question": "Why is rename strategy used after FTP read?",
    "options": {
      "A": "Performance",
      "B": "Security",
      "C": "Prevent reprocessing",
      "D": "Compression"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Renaming marks files as processed.",
      "incorrect": {
        "A": "Secondary.",
        "B": "Not primary.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0435",
    "component": "Using Connectors – HTTP Keep-Alive",
    "difficulty": "Extreme",
    "question": "What is the benefit of HTTP keep-alive?",
    "options": {
      "A": "Security",
      "B": "Reduced connection overhead",
      "C": "Payload compression",
      "D": "Better routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connection reuse reduces latency.",
      "incorrect": {
        "A": "No security gain.",
        "C": "Separate feature.",
        "D": "Routing unaffected."
      }
    }
  },

  {
    "id": "EXP-MS-0436",
    "component": "Using Connectors – DB Auto Commit",
    "difficulty": "Extreme",
    "question": "What happens when auto-commit is enabled?",
    "options": {
      "A": "Rollback always",
      "B": "Each operation commits immediately",
      "C": "Transaction ignored",
      "D": "Commit at flow end"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each DB operation commits immediately.",
      "incorrect": {
        "A": "Opposite.",
        "C": "Transactions still exist.",
        "D": "Not deferred."
      }
    }
  },
  {
    "id": "EXP-MS-0437",
    "component": "Using Connectors – Object Store Connector",
    "difficulty": "Extreme",
    "question": "What is Object Store connector primarily used for?",
    "options": {
      "A": "Logging",
      "B": "Temporary payload storage",
      "C": "State persistence",
      "D": "Thread control"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object Store persists state across events.",
      "incorrect": {
        "A": "Not logging.",
        "B": "More than temp.",
        "D": "No threading."
      }
    }
  },
  {
    "id": "EXP-MS-0438",
    "component": "Using Connectors – HTTP Redirects",
    "difficulty": "Extreme",
    "question": "If followRedirects=false, what happens?",
    "options": {
      "A": "Redirect followed",
      "B": "Error thrown",
      "C": "Redirect response returned",
      "D": "Request retried"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Redirect response is returned as-is.",
      "incorrect": {
        "A": "Disabled.",
        "B": "Not an error.",
        "D": "No retry."
      }
    }
  },
  {
    "id": "EXP-MS-0439",
    "component": "Using Connectors – DB Parameter Binding",
    "difficulty": "Extreme",
    "question": "Why use parameterized queries?",
    "options": {
      "A": "Performance",
      "B": "SQL injection prevention",
      "C": "Logging",
      "D": "Caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Prevents SQL injection.",
      "incorrect": {
        "A": "Secondary.",
        "C": "Not purpose.",
        "D": "Not caching."
      }
    }
  },
  {
    "id": "EXP-MS-0440",
    "component": "Using Connectors – Connector Error Mapping",
    "difficulty": "Extreme",
    "question": "What enables mapping connector errors to custom errors?",
    "options": {
      "A": "Try scope",
      "B": "Error mapping",
      "C": "Global error handler",
      "D": "Choice router"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error mapping translates errors at source.",
      "incorrect": {
        "A": "Catches only.",
        "C": "Handles later.",
        "D": "Routing only."
      }
    }
  },
  {
    "id": "EXP-MS-0441",
    "component": "Using Connectors – HTTP Response Streaming",
    "difficulty": "Extreme",
    "question": "What is the primary benefit of streaming HTTP responses?",
    "options": {
      "A": "Lower latency",
      "B": "Reduced memory footprint",
      "C": "Automatic retries",
      "D": "Schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming avoids loading entire payloads into memory.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "Retries are unrelated.",
        "D": "Validation is separate."
      }
    }
  },
  {
    "id": "EXP-MS-0442",
    "component": "Using Connectors – DB Transaction Scope Nesting",
    "difficulty": "Extreme",
    "question": "What happens when a transaction scope is nested inside another?",
    "options": {
      "A": "Inner overrides outer",
      "B": "Both commit independently",
      "C": "Inner joins outer transaction",
      "D": "Deployment fails"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Nested scopes join the existing transaction.",
      "incorrect": {
        "A": "No override.",
        "B": "Single transaction context.",
        "D": "Valid configuration."
      }
    }
  },
  {
    "id": "EXP-MS-0443",
    "component": "Using Connectors – File Connector Atomicity",
    "difficulty": "Extreme",
    "question": "How does File Write ensure atomic writes?",
    "options": {
      "A": "Locks directory",
      "B": "Writes to temp file then renames",
      "C": "Uses transactions",
      "D": "Buffers entire payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Temp file + rename ensures atomicity.",
      "incorrect": {
        "A": "No directory lock.",
        "C": "File system transactions not used.",
        "D": "Buffering is not atomicity."
      }
    }
  },
  {
    "id": "EXP-MS-0444",
    "component": "Using Connectors – HTTP Request Retry",
    "difficulty": "Extreme",
    "question": "Where should retry logic for HTTP Request be implemented?",
    "options": {
      "A": "Connector config",
      "B": "Until Successful scope",
      "C": "Global error handler",
      "D": "Policy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Until Successful handles transient retries.",
      "incorrect": {
        "A": "Config has no retry logic.",
        "C": "Too late for retry.",
        "D": "Policies are cross-cutting."
      }
    }
  },
  {
    "id": "EXP-MS-0445",
    "component": "Using Connectors – DB Deadlock",
    "difficulty": "Extreme",
    "question": "Best response to DB deadlock error?",
    "options": {
      "A": "Fail immediately",
      "B": "Retry transaction",
      "C": "Ignore",
      "D": "Restart application"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deadlocks are transient and retryable.",
      "incorrect": {
        "A": "Too aggressive.",
        "C": "Data loss risk.",
        "D": "Overkill."
      }
    }
  },

  {
    "id": "EXP-MS-0446",
    "component": "Using Connectors – FTP Read Lock",
    "difficulty": "Extreme",
    "question": "Why use a read lock strategy in FTP connector?",
    "options": {
      "A": "Encryption",
      "B": "Ensure file upload completion",
      "C": "Performance tuning",
      "D": "Compression"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Prevents reading partially written files.",
      "incorrect": {
        "A": "No security impact.",
        "C": "Not primary.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0447",
    "component": "Using Connectors – HTTP Header Propagation",
    "difficulty": "Extreme",
    "question": "How do you forward inbound headers to HTTP Request?",
    "options": {
      "A": "vars",
      "B": "payload",
      "C": "attributes.headers",
      "D": "listener config"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Inbound headers are in attributes.headers.",
      "incorrect": {
        "A": "Vars are manual.",
        "B": "Payload is body.",
        "D": "Static."
      }
    }
  },
  {
    "id": "EXP-MS-0448",
    "component": "Using Connectors – DB Streaming and Transactions",
    "difficulty": "Extreme",
    "question": "What is a risk of streaming DB results inside a transaction?",
    "options": {
      "A": "Memory leak",
      "B": "Long-lived locks",
      "C": "Data corruption",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming keeps transaction open longer.",
      "incorrect": {
        "A": "Streaming reduces memory.",
        "C": "No corruption.",
        "D": "Validation unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0449",
    "component": "Using Connectors – Object Store TTL",
    "difficulty": "Extreme",
    "question": "What happens when Object Store entry TTL expires?",
    "options": {
      "A": "Value becomes null",
      "B": "Entry is evicted",
      "C": "Application restarts",
      "D": "Exception thrown"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expired entries are evicted automatically.",
      "incorrect": {
        "A": "Not set to null.",
        "C": "No restart.",
        "D": "No exception."
      }
    }
  },
  {
    "id": "EXP-MS-0450",
    "component": "Using Connectors – HTTP Connection Pool",
    "difficulty": "Extreme",
    "question": "What is the effect of exhausting HTTP connection pool?",
    "options": {
      "A": "Automatic scaling",
      "B": "Requests queued or fail",
      "C": "Runtime crash",
      "D": "Payload dropped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Requests wait or fail depending on config.",
      "incorrect": {
        "A": "No auto-scale.",
        "C": "No crash.",
        "D": "Not silently dropped."
      }
    }
  },

  {
    "id": "EXP-MS-0451",
    "component": "Using Connectors – DB Batch Size",
    "difficulty": "Extreme",
    "question": "Why tune DB fetch size for large queries?",
    "options": {
      "A": "Security",
      "B": "Reduce memory usage",
      "C": "Enable retries",
      "D": "Schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller fetch size limits memory consumption.",
      "incorrect": {
        "A": "No security impact.",
        "C": "Retries unrelated.",
        "D": "Validation separate."
      }
    }
  },
  {
    "id": "EXP-MS-0452",
    "component": "Using Connectors – HTTP Request Idempotency",
    "difficulty": "Extreme",
    "question": "Which HTTP method is inherently idempotent?",
    "options": {
      "A": "POST",
      "B": "PATCH",
      "C": "PUT",
      "D": "CONNECT"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "PUT is defined as idempotent.",
      "incorrect": {
        "A": "POST is not idempotent.",
        "B": "PATCH is not guaranteed.",
        "D": "Not for resource modification."
      }
    }
  },
  {
    "id": "EXP-MS-0453",
    "component": "Using Connectors – FTP Passive Mode",
    "difficulty": "Extreme",
    "question": "Why enable passive mode in FTP?",
    "options": {
      "A": "Compression",
      "B": "Firewall/NAT compatibility",
      "C": "Encryption",
      "D": "Performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Passive mode works better behind firewalls.",
      "incorrect": {
        "A": "No compression.",
        "C": "Encryption is FTPS.",
        "D": "Secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0454",
    "component": "Using Connectors – HTTP Request Error Scope",
    "difficulty": "Extreme",
    "question": "Where should HTTP errors be handled closest to source?",
    "options": {
      "A": "Global error handler",
      "B": "Flow error handler",
      "C": "Try scope around request",
      "D": "Policy"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Local try allows precise handling.",
      "incorrect": {
        "A": "Too coarse.",
        "B": "Less granular.",
        "D": "Cross-cutting."
      }
    }
  },
  {
    "id": "EXP-MS-0455",
    "component": "Using Connectors – DB Autogenerated Keys",
    "difficulty": "Extreme",
    "question": "How are autogenerated keys retrieved after insert?",
    "options": {
      "A": "vars",
      "B": "payload",
      "C": "attributes",
      "D": "object store"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Generated keys are available in attributes.",
      "incorrect": {
        "A": "Vars are manual.",
        "B": "Payload holds result set.",
        "D": "Not persisted."
      }
    }
  },

  {
    "id": "EXP-MS-0456",
    "component": "Using Connectors – File Read Streaming",
    "difficulty": "Extreme",
    "question": "What is the main risk when streaming file content?",
    "options": {
      "A": "File corruption",
      "B": "File handle exhaustion",
      "C": "Schema mismatch",
      "D": "Encoding errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streams must be closed to avoid handle leaks.",
      "incorrect": {
        "A": "No modification.",
        "C": "Validation unrelated.",
        "D": "Encoding is separate."
      }
    }
  },
  {
    "id": "EXP-MS-0457",
    "component": "Using Connectors – HTTP Proxy Config",
    "difficulty": "Extreme",
    "question": "Where is proxy configured for HTTP Request?",
    "options": {
      "A": "Per operation",
      "B": "Global HTTP config",
      "C": "Listener",
      "D": "Policy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proxy is part of global HTTP requester config.",
      "incorrect": {
        "A": "Not per request.",
        "C": "Listener is server side.",
        "D": "Policy is higher level."
      }
    }
  },
  {
    "id": "EXP-MS-0458",
    "component": "Using Connectors – DB Lock Escalation",
    "difficulty": "Extreme",
    "question": "What increases risk of DB lock escalation?",
    "options": {
      "A": "Short transactions",
      "B": "Streaming results",
      "C": "Small batch size",
      "D": "Auto-commit"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-lived streaming transactions hold locks.",
      "incorrect": {
        "A": "Reduces risk.",
        "C": "Reduces impact.",
        "D": "Commits quickly."
      }
    }
  },
  {
    "id": "EXP-MS-0459",
    "component": "Using Connectors – Connector Threading",
    "difficulty": "Extreme",
    "question": "Connector operations execute on which thread pool?",
    "options": {
      "A": "CPU intensive",
      "B": "IO thread pool",
      "C": "Custom pool",
      "D": "Main thread"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors use non-blocking IO pools.",
      "incorrect": {
        "A": "Used for DW.",
        "C": "Not default.",
        "D": "Not main."
      }
    }
  },
  {
    "id": "EXP-MS-0460",
    "component": "Using Connectors – Section Integrity",
    "difficulty": "Extreme",
    "question": "What defines correct connector usage?",
    "options": {
      "A": "Minimal configuration",
      "B": "Correct semantics and lifecycle awareness",
      "C": "Maximum concurrency",
      "D": "Lowest latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct semantics and lifecycle handling are key.",
      "incorrect": {
        "A": "Minimal is not always correct.",
        "C": "Concurrency must be controlled.",
        "D": "Latency is secondary."
      }
    }
  },

  {
    "id": "EXP-MS-0461",
    "component": "Using Connectors – Idempotent Receiver",
    "difficulty": "Extreme",
    "question": "Which component helps prevent duplicate message processing?",
    "options": {
      "A": "Choice router",
      "B": "Idempotent Message Validator",
      "C": "Until Successful",
      "D": "Async scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent validator filters duplicates.",
      "incorrect": {
        "A": "Routing only.",
        "C": "Retries only.",
        "D": "Concurrency only."
      }
    }
  },

  {
    "id": "EXP-MS-0462",
    "component": "Using Connectors – Continuation Marker",
    "difficulty": "Extreme",
    "question": "Why is connector misuse dangerous?",
    "options": {
      "A": "Compilation failure",
      "B": "Hidden runtime bottlenecks",
      "C": "XML errors",
      "D": "Policy conflicts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Misuse causes subtle runtime issues.",
      "incorrect": {
        "A": "Not compile-time.",
        "C": "XML may still be valid.",
        "D": "Policies unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0463",
    "component": "Using Connectors – DB Idempotency",
    "difficulty": "Extreme",
    "question": "Which DB design best supports idempotent insert operations?",
    "options": {
      "A": "Auto-increment primary key",
      "B": "Composite natural key with unique constraint",
      "C": "No primary key",
      "D": "Random UUID without constraint"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unique constraints prevent duplicate inserts safely.",
      "incorrect": {
        "A": "Allows duplicates.",
        "C": "Invalid design.",
        "D": "Duplicates still possible."
      }
    }
  },
  {
    "id": "EXP-MS-0464",
    "component": "Using Connectors – HTTP Request Backpressure",
    "difficulty": "Extreme",
    "question": "What causes backpressure in HTTP Request operations?",
    "options": {
      "A": "Large payload size",
      "B": "Downstream service slowness",
      "C": "Invalid headers",
      "D": "Wrong HTTP method"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Slow downstream services block IO threads.",
      "incorrect": {
        "A": "Handled via streaming.",
        "C": "Rejected early.",
        "D": "Not performance-related."
      }
    }
  },
  {
    "id": "EXP-MS-0465",
    "component": "Using Connectors – File Connector Overwrite",
    "difficulty": "Extreme",
    "question": "What happens when overwrite=true in File Write?",
    "options": {
      "A": "Append data",
      "B": "Fail if file exists",
      "C": "Replace existing file",
      "D": "Create versioned file"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Existing file is replaced.",
      "incorrect": {
        "A": "Append is different option.",
        "B": "overwrite=false fails.",
        "D": "No versioning."
      }
    }
  },
  {
    "id": "EXP-MS-0466",
    "component": "Using Connectors – DB Result Set Mapping",
    "difficulty": "Extreme",
    "question": "DB select returns multiple rows by default as?",
    "options": {
      "A": "Java ResultSet",
      "B": "Map",
      "C": "Array of Objects",
      "D": "Stream"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Result is an array of row objects.",
      "incorrect": {
        "A": "Abstracted by Mule.",
        "B": "Single-row only.",
        "D": "Optional streaming."
      }
    }
  },
  {
    "id": "EXP-MS-0467",
    "component": "Using Connectors – HTTP Request Payload Reuse",
    "difficulty": "Extreme",
    "question": "Why use repeatable streams with HTTP Request?",
    "options": {
      "A": "Retry support",
      "B": "Better compression",
      "C": "Lower latency",
      "D": "Schema validation"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Retries require payload re-readability.",
      "incorrect": {
        "B": "Not related.",
        "C": "No effect.",
        "D": "Validation independent."
      }
    }
  },

  {
    "id": "EXP-MS-0468",
    "component": "Using Connectors – FTP Delete Strategy",
    "difficulty": "Extreme",
    "question": "What is the risk of delete-after-read strategy?",
    "options": {
      "A": "Duplicate processing",
      "B": "Data loss on failure",
      "C": "Performance drop",
      "D": "File lock issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Failures after read cause permanent loss.",
      "incorrect": {
        "A": "Opposite.",
        "C": "Secondary.",
        "D": "Lock handled earlier."
      }
    }
  },
  {
    "id": "EXP-MS-0469",
    "component": "Using Connectors – HTTP Error Classification",
    "difficulty": "Extreme",
    "question": "Which HTTP status codes are typically retryable?",
    "options": {
      "A": "4xx",
      "B": "401",
      "C": "5xx",
      "D": "200"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "5xx indicates transient server failures.",
      "incorrect": {
        "A": "Client errors.",
        "B": "Auth issue.",
        "D": "Success."
      }
    }
  },
  {
    "id": "EXP-MS-0470",
    "component": "Using Connectors – DB Transaction Isolation",
    "difficulty": "Extreme",
    "question": "Which isolation level prevents dirty reads?",
    "options": {
      "A": "READ_UNCOMMITTED",
      "B": "READ_COMMITTED",
      "C": "REPEATABLE_READ",
      "D": "SERIALIZABLE"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "READ_COMMITTED blocks dirty reads.",
      "incorrect": {
        "A": "Allows dirty reads.",
        "C": "Stronger than needed.",
        "D": "Strongest."
      }
    }
  },
  {
    "id": "EXP-MS-0471",
    "component": "Using Connectors – Object Store Consistency",
    "difficulty": "Extreme",
    "question": "What guarantees Object Store consistency?",
    "options": {
      "A": "In-memory caching",
      "B": "Single-thread access",
      "C": "Underlying persistence mechanism",
      "D": "Flow variables"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Consistency depends on the persistence backend.",
      "incorrect": {
        "A": "Cache is optional.",
        "B": "Concurrency supported.",
        "D": "Vars are transient."
      }
    }
  },
  {
    "id": "EXP-MS-0472",
    "component": "Using Connectors – HTTP Request Non-blocking",
    "difficulty": "Extreme",
    "question": "Why is HTTP Request considered non-blocking?",
    "options": {
      "A": "Uses async scope",
      "B": "Uses IO thread pool",
      "C": "Creates new thread per call",
      "D": "Blocks CPU thread"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "IO threads handle non-blocking operations.",
      "incorrect": {
        "A": "Async is optional.",
        "C": "No thread-per-call.",
        "D": "Does not block CPU."
      }
    }
  },

  {
    "id": "EXP-MS-0473",
    "component": "Using Connectors – File Connector Directory Creation",
    "difficulty": "Extreme",
    "question": "If target directory does not exist during File Write?",
    "options": {
      "A": "Fails",
      "B": "Creates directory automatically",
      "C": "Writes to temp",
      "D": "Skips write"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "File connector creates missing directories.",
      "incorrect": {
        "A": "Not default behavior.",
        "C": "Temp used internally.",
        "D": "Write attempted."
      }
    }
  },
  {
    "id": "EXP-MS-0474",
    "component": "Using Connectors – DB Timeout",
    "difficulty": "Extreme",
    "question": "What happens when DB query timeout is exceeded?",
    "options": {
      "A": "Query completes silently",
      "B": "DB:QUERY_TIMEOUT error",
      "C": "Flow retries automatically",
      "D": "Application crashes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeout results in a DB timeout error.",
      "incorrect": {
        "A": "Not silent.",
        "C": "No automatic retry.",
        "D": "App remains stable."
      }
    }
  },
  {
    "id": "EXP-MS-0475",
    "component": "Using Connectors – HTTP Request Header Override",
    "difficulty": "Extreme",
    "question": "If same header exists in attributes and request config?",
    "options": {
      "A": "Listener header wins",
      "B": "Request config wins",
      "C": "Merged",
      "D": "Error thrown"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit request headers override inbound ones.",
      "incorrect": {
        "A": "Not inbound priority.",
        "C": "Not merged.",
        "D": "No conflict error."
      }
    }
  },
  {
    "id": "EXP-MS-0476",
    "component": "Using Connectors – FTP Streaming Risk",
    "difficulty": "Extreme",
    "question": "Primary risk of streaming FTP files?",
    "options": {
      "A": "Encoding mismatch",
      "B": "Connection drop mid-stream",
      "C": "Schema violation",
      "D": "Duplicate files"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Network failure can corrupt streaming reads.",
      "incorrect": {
        "A": "Separate concern.",
        "C": "Validation later.",
        "D": "Handled by watermark."
      }
    }
  },
  {
    "id": "EXP-MS-0477",
    "component": "Using Connectors – DB Auto-Reconnect",
    "difficulty": "Extreme",
    "question": "How does DB connector handle dropped connections?",
    "options": {
      "A": "Fails permanently",
      "B": "Automatically reconnects via pool",
      "C": "Restarts application",
      "D": "Ignores error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connection pool recreates connections.",
      "incorrect": {
        "A": "Not permanent.",
        "C": "No restart.",
        "D": "Errors surfaced."
      }
    }
  },

  {
    "id": "EXP-MS-0478",
    "component": "Using Connectors – HTTP Compression",
    "difficulty": "Extreme",
    "question": "What enables gzip compression in HTTP Request?",
    "options": {
      "A": "Content-Encoding header",
      "B": "Accept-Encoding header",
      "C": "Transfer-Encoding",
      "D": "Streaming strategy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accept-Encoding requests compressed responses.",
      "incorrect": {
        "A": "Response header.",
        "C": "Chunking only.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0479",
    "component": "Using Connectors – DB Result Ordering",
    "difficulty": "Extreme",
    "question": "Without ORDER BY, DB result order is?",
    "options": {
      "A": "Guaranteed",
      "B": "Insertion order",
      "C": "Undefined",
      "D": "Primary key order"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "SQL does not guarantee order without ORDER BY.",
      "incorrect": {
        "A": "Never guaranteed.",
        "B": "Not reliable.",
        "D": "Not default."
      }
    }
  },
  {
    "id": "EXP-MS-0480",
    "component": "Using Connectors – Object Store vs DB",
    "difficulty": "Extreme",
    "question": "When should Object Store replace DB usage?",
    "options": {
      "A": "Transactional data",
      "B": "Long-term reporting",
      "C": "Lightweight state tracking",
      "D": "Relational joins"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object Store suits lightweight state.",
      "incorrect": {
        "A": "DB required.",
        "B": "Not analytical.",
        "D": "No joins."
      }
    }
  },

  {
    "id": "EXP-MS-0481",
    "component": "Using Connectors – HTTP Request Circuit Breaker",
    "difficulty": "Extreme",
    "question": "Which pattern prevents cascading failures?",
    "options": {
      "A": "Retry",
      "B": "Circuit breaker",
      "C": "Bulkhead",
      "D": "Cache"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers stop repeated failures.",
      "incorrect": {
        "A": "May worsen load.",
        "C": "Isolation pattern.",
        "D": "Performance pattern."
      }
    }
  },
  {
    "id": "EXP-MS-0482",
    "component": "Using Connectors – File Connector Charset",
    "difficulty": "Extreme",
    "question": "Why explicitly set file charset?",
    "options": {
      "A": "Compression",
      "B": "Cross-platform consistency",
      "C": "Performance",
      "D": "Security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Avoids platform default mismatches.",
      "incorrect": {
        "A": "Not compression.",
        "C": "Minor impact.",
        "D": "Not security."
      }
    }
  },
  {
    "id": "EXP-MS-0483",
    "component": "Using Connectors – DB Lock Timeout",
    "difficulty": "Extreme",
    "question": "DB lock timeout indicates?",
    "options": {
      "A": "Syntax error",
      "B": "Deadlock",
      "C": "Resource contention",
      "D": "Network failure"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Locks held too long by other transactions.",
      "incorrect": {
        "A": "Not syntax.",
        "B": "Different error.",
        "D": "Connectivity unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0484",
    "component": "Using Connectors – HTTP Request Payload Mutation",
    "difficulty": "Extreme",
    "question": "Does HTTP Request mutate original payload by default?",
    "options": {
      "A": "Yes",
      "B": "No",
      "C": "Only on error",
      "D": "Only with target"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Payload is replaced only if no target is set.",
      "incorrect": {
        "A": "Not always.",
        "C": "Errors differ.",
        "D": "Target preserves payload."
      }
    }
  },
  {
    "id": "EXP-MS-0485",
    "component": "Using Connectors – FTP Idempotency",
    "difficulty": "Extreme",
    "question": "Best FTP idempotency strategy?",
    "options": {
      "A": "File name",
      "B": "Timestamp",
      "C": "Checksum tracking",
      "D": "Polling frequency"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Checksums reliably detect duplicates.",
      "incorrect": {
        "A": "Names may repeat.",
        "B": "Timestamps unreliable.",
        "D": "Does not ensure uniqueness."
      }
    }
  },

  {
    "id": "EXP-MS-0486",
    "component": "Using Connectors – DB Pagination",
    "difficulty": "Extreme",
    "question": "Why prefer pagination over full table scan?",
    "options": {
      "A": "Security",
      "B": "Memory efficiency",
      "C": "Schema enforcement",
      "D": "Logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limits memory and lock duration.",
      "incorrect": {
        "A": "Not security.",
        "C": "Validation unrelated.",
        "D": "Logging separate."
      }
    }
  },
  {
    "id": "EXP-MS-0487",
    "component": "Using Connectors – HTTP Request DNS Failure",
    "difficulty": "Extreme",
    "question": "DNS resolution failure results in?",
    "options": {
      "A": "HTTP:BAD_REQUEST",
      "B": "HTTP:CONNECTIVITY",
      "C": "MULE:TIMEOUT",
      "D": "HTTP:NOT_FOUND"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DNS failures are connectivity issues.",
      "incorrect": {
        "A": "Client error.",
        "C": "Not timeout.",
        "D": "Not resource error."
      }
    }
  },
  {
    "id": "EXP-MS-0488",
    "component": "Using Connectors – Object Store Concurrency",
    "difficulty": "Extreme",
    "question": "How does Object Store handle concurrent writes?",
    "options": {
      "A": "Last write wins",
      "B": "Transaction isolation",
      "C": "Atomic operations",
      "D": "Flow locking"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Operations are atomic per key.",
      "incorrect": {
        "A": "Not blind overwrite.",
        "B": "No full transactions.",
        "D": "No flow locks."
      }
    }
  },
  {
    "id": "EXP-MS-0489",
    "component": "Using Connectors – DB Generated Columns",
    "difficulty": "Extreme",
    "question": "Generated DB columns are accessible where?",
    "options": {
      "A": "payload",
      "B": "attributes",
      "C": "vars",
      "D": "object store"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Generated values are exposed in attributes.",
      "incorrect": {
        "A": "Payload is result set.",
        "C": "Vars manual.",
        "D": "Not persisted."
      }
    }
  },
  {
    "id": "EXP-MS-0490",
    "component": "Using Connectors – HTTP Request Connection Reuse",
    "difficulty": "Extreme",
    "question": "Connection reuse depends on?",
    "options": {
      "A": "HTTP version",
      "B": "Keep-Alive settings",
      "C": "Payload size",
      "D": "Headers count"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Keep-alive controls reuse.",
      "incorrect": {
        "A": "Secondary.",
        "C": "Irrelevant.",
        "D": "No effect."
      }
    }
  },

  {
    "id": "EXP-MS-0491",
    "component": "Using Connectors – File Connector Locking",
    "difficulty": "Extreme",
    "question": "File read lock prevents?",
    "options": {
      "A": "Duplicate processing",
      "B": "Partial reads",
      "C": "Unauthorized access",
      "D": "Encoding issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ensures file is fully written.",
      "incorrect": {
        "A": "Handled separately.",
        "C": "Not security.",
        "D": "Charset issue."
      }
    }
  },
  {
    "id": "EXP-MS-0492",
    "component": "Using Connectors – DB Connection Leak",
    "difficulty": "Extreme",
    "question": "Primary cause of DB connection leaks?",
    "options": {
      "A": "Large queries",
      "B": "Improper transaction handling",
      "C": "Streaming",
      "D": "Index usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unclosed transactions exhaust pool.",
      "incorrect": {
        "A": "Performance issue.",
        "C": "Manageable.",
        "D": "Query optimization."
      }
    }
  },
  {
    "id": "EXP-MS-0493",
    "component": "Using Connectors – HTTP Request Payload Type",
    "difficulty": "Extreme",
    "question": "If payload is InputStream, HTTP Request sends?",
    "options": {
      "A": "String",
      "B": "Binary stream",
      "C": "JSON",
      "D": "XML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stream is sent as-is.",
      "incorrect": {
        "A": "No conversion.",
        "C": "Not inferred.",
        "D": "Not inferred."
      }
    }
  },
  {
    "id": "EXP-MS-0494",
    "component": "Using Connectors – Object Store Eviction",
    "difficulty": "Extreme",
    "question": "Eviction policy applies when?",
    "options": {
      "A": "TTL expires",
      "B": "Memory pressure",
      "C": "Manual delete",
      "D": "All of the above"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Entries can be evicted by multiple triggers.",
      "incorrect": {
        "A": "One case only.",
        "B": "One case only.",
        "C": "Manual is also eviction."
      }
    }
  },
  {
    "id": "EXP-MS-0495",
    "component": "Using Connectors – DB Batch Update Failure",
    "difficulty": "Extreme",
    "question": "If one statement fails in batch update?",
    "options": {
      "A": "All succeed",
      "B": "Partial commit",
      "C": "Batch fails",
      "D": "Ignored"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Batch is atomic by default.",
      "incorrect": {
        "A": "Incorrect.",
        "B": "Transaction prevents partial.",
        "D": "Never ignored."
      }
    }
  },

  {
    "id": "EXP-MS-0496",
    "component": "Using Connectors – HTTP Request Response Timeout",
    "difficulty": "Extreme",
    "question": "Response timeout measures?",
    "options": {
      "A": "Connection establishment",
      "B": "Total request time",
      "C": "Time waiting for response",
      "D": "DNS resolution"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Measures waiting time after request sent.",
      "incorrect": {
        "A": "Connection timeout.",
        "B": "Different metric.",
        "D": "Connectivity phase."
      }
    }
  },
  {
    "id": "EXP-MS-0497",
    "component": "Using Connectors – File Connector Atomic Rename",
    "difficulty": "Extreme",
    "question": "Why rename after write?",
    "options": {
      "A": "Security",
      "B": "Atomic visibility",
      "C": "Compression",
      "D": "Encoding"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ensures consumers see complete file.",
      "incorrect": {
        "A": "Not security.",
        "C": "Unrelated.",
        "D": "Charset unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0498",
    "component": "Using Connectors – DB Read Consistency",
    "difficulty": "Extreme",
    "question": "Repeatable reads guarantee?",
    "options": {
      "A": "No phantom reads",
      "B": "Same row values per transaction",
      "C": "Serializable execution",
      "D": "No locking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rows read remain consistent.",
      "incorrect": {
        "A": "Phantoms still possible.",
        "C": "Not serializable.",
        "D": "Locks still used."
      }
    }
  },
  {
    "id": "EXP-MS-0499",
    "component": "Using Connectors – HTTP Request TLS Failure",
    "difficulty": "Extreme",
    "question": "Invalid certificate results in?",
    "options": {
      "A": "HTTP:UNAUTHORIZED",
      "B": "HTTP:CONNECTIVITY",
      "C": "MULE:SECURITY",
      "D": "HTTP:BAD_REQUEST"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "TLS handshake failure is connectivity error.",
      "incorrect": {
        "A": "Auth is different.",
        "C": "Not Mule core.",
        "D": "Request not sent."
      }
    }
  },
  {
    "id": "EXP-MS-0500",
    "component": "Using Connectors – Section Completion",
    "difficulty": "Extreme",
    "question": "What defines mastery of connectors?",
    "options": {
      "A": "Knowing operations",
      "B": "Understanding lifecycle, errors, and performance",
      "C": "Minimal config",
      "D": "High throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lifecycle, error handling, and performance awareness matter.",
      "incorrect": {
        "A": "Insufficient.",
        "C": "Oversimplification.",
        "D": "Secondary outcome."
      }
    }
  },

  {
    "id": "EXP-MS-0501",
    "component": "Using Connectors – Connector Observability",
    "difficulty": "Extreme",
    "question": "Best way to observe connector latency?",
    "options": {
      "A": "Logger before and after",
      "B": "Anypoint Monitoring metrics",
      "C": "Flow variables",
      "D": "Payload inspection"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform metrics provide accurate latency data.",
      "incorrect": {
        "A": "Manual and coarse.",
        "C": "Not timing.",
        "D": "Not reliable."
      }
    }
  },
  {
    "id": "EXP-MS-0502",
    "component": "Using Connectors – Connector Misuse",
    "difficulty": "Extreme",
    "question": "Most dangerous connector anti-pattern?",
    "options": {
      "A": "Streaming",
      "B": "Blocking calls on CPU threads",
      "C": "Retry logic",
      "D": "Target variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blocking CPU threads kills scalability.",
      "incorrect": {
        "A": "Best practice.",
        "C": "When controlled.",
        "D": "Safe."
      }
    }
  },
  {
    "id": "EXP-MS-0503",
    "component": "Using Connectors – Connector Final Marker",
    "difficulty": "Extreme",
    "question": "When are connectors considered correctly used?",
    "options": {
      "A": "When they work",
      "B": "When failures are handled and impact minimized",
      "C": "When fast",
      "D": "When simple"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience and failure handling define correctness.",
      "incorrect": {
        "A": "Too shallow.",
        "C": "Speed alone insufficient.",
        "D": "Simplicity may hide issues."
      }
    }
  },
  {
    "id": "EXP-MS-0504",
    "component": "Using Connectors – Upper Bound Marker",
    "difficulty": "Extreme",
    "question": "Why stop expanding connector logic in a single flow?",
    "options": {
      "A": "XML limit",
      "B": "Readability and maintainability",
      "C": "Runtime crash",
      "D": "Policy conflict"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Complex flows reduce maintainability.",
      "incorrect": {
        "A": "No XML limit.",
        "C": "No inherent crash.",
        "D": "Policies unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0505",
    "component": "Using Connectors – Connector Section End",
    "difficulty": "Extreme",
    "question": "What is the final validation of connector design?",
    "options": {
      "A": "Unit tests pass",
      "B": "Handles failures gracefully under load",
      "C": "Minimal code",
      "D": "No warnings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Real resilience is proven under load and failure.",
      "incorrect": {
        "A": "Necessary but insufficient.",
        "C": "Not primary.",
        "D": "Warnings may exist."
      }
    }
  },
  {
    "id": "EXP-MS-0506",
    "component": "Using Connectors – DB Connector Auto-Commit Override",
    "difficulty": "Extreme",
    "question": "What is the effect of disabling auto-commit while not using a transaction scope?",
    "options": {
      "A": "Implicit commit at flow end",
      "B": "Operations remain uncommitted until error",
      "C": "Operations fail immediately",
      "D": "Connector forces commit anyway"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without auto-commit or transaction scope, operations remain uncommitted.",
      "incorrect": {
        "A": "No implicit commit occurs.",
        "C": "Operations execute successfully.",
        "D": "Connector does not force commit."
      }
    }
  },
  {
    "id": "EXP-MS-0507",
    "component": "Using Connectors – HTTP Request Response Validator",
    "difficulty": "Extreme",
    "question": "Which configuration allows HTTP Request to fail on non-2xx responses?",
    "options": {
      "A": "followRedirects=false",
      "B": "Response Validator",
      "C": "Streaming strategy",
      "D": "TLS config"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Response Validator enforces acceptable status codes.",
      "incorrect": {
        "A": "Redirect handling only.",
        "C": "Affects memory usage.",
        "D": "Security only."
      }
    }
  },
  {
    "id": "EXP-MS-0508",
    "component": "Using Connectors – File Connector Append",
    "difficulty": "Extreme",
    "question": "What happens when append=true and overwrite=true are both set?",
    "options": {
      "A": "Append wins",
      "B": "Overwrite wins",
      "C": "Configuration error",
      "D": "Random behavior"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Append and overwrite are mutually exclusive.",
      "incorrect": {
        "A": "Cannot append and overwrite.",
        "B": "Cannot overwrite when appending.",
        "D": "Behavior is deterministic."
      }
    }
  },
  {
    "id": "EXP-MS-0509",
    "component": "Using Connectors – DB Fetch Size Misconfiguration",
    "difficulty": "Extreme",
    "question": "What is the impact of extremely large DB fetch size?",
    "options": {
      "A": "Fewer DB calls",
      "B": "Higher memory consumption",
      "C": "Automatic pagination",
      "D": "Reduced locking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Large fetch size loads more rows into memory.",
      "incorrect": {
        "A": "Secondary effect.",
        "C": "Not automatic.",
        "D": "Locks may increase."
      }
    }
  },
  {
    "id": "EXP-MS-0510",
    "component": "Using Connectors – HTTP Request Payload Replay",
    "difficulty": "Extreme",
    "question": "Which streaming strategy supports payload replay for retries?",
    "options": {
      "A": "repeatable-in-memory",
      "B": "repeatable-file-store",
      "C": "non-repeatable",
      "D": "direct-streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "File-store backed streams allow replay with lower memory usage.",
      "incorrect": {
        "A": "Consumes heap memory.",
        "C": "Cannot be replayed.",
        "D": "Single-pass only."
      }
    }
  },
  {
    "id": "EXP-MS-0511",
    "component": "Using Connectors – FTP Polling Watermark Reset",
    "difficulty": "Extreme",
    "question": "What happens if FTP watermark store is cleared?",
    "options": {
      "A": "Connector stops",
      "B": "Previously processed files may reprocess",
      "C": "Only new files processed",
      "D": "Polling interval resets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Watermark reset causes reprocessing risk.",
      "incorrect": {
        "A": "Connector continues.",
        "C": "No historical context.",
        "D": "Interval unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0512",
    "component": "Using Connectors – HTTP Request Thread Saturation",
    "difficulty": "Extreme",
    "question": "What causes HTTP requester IO thread starvation?",
    "options": {
      "A": "Large payloads",
      "B": "Blocking operations in flow",
      "C": "High CPU usage elsewhere",
      "D": "TLS handshake"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blocking calls prevent IO threads from releasing.",
      "incorrect": {
        "A": "Streaming mitigates.",
        "C": "Separate pool.",
        "D": "Transient."
      }
    }
  },
  {
    "id": "EXP-MS-0513",
    "component": "Using Connectors – DB Savepoint Usage",
    "difficulty": "Extreme",
    "question": "Why are savepoints used inside transactions?",
    "options": {
      "A": "Parallel execution",
      "B": "Partial rollback capability",
      "C": "Performance improvement",
      "D": "Lock escalation prevention"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Savepoints allow rollback to intermediate state.",
      "incorrect": {
        "A": "Not parallel.",
        "C": "No speed gain.",
        "D": "Locks still held."
      }
    }
  },
  {
    "id": "EXP-MS-0514",
    "component": "Using Connectors – Object Store Persistent vs In-Memory",
    "difficulty": "Extreme",
    "question": "Persistent Object Store survives?",
    "options": {
      "A": "Flow restart",
      "B": "Application restart",
      "C": "Node failure",
      "D": "Heap cleanup"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Persistent store survives application restarts.",
      "incorrect": {
        "A": "Flow restarts are irrelevant.",
        "C": "Node loss may lose data.",
        "D": "Heap cleanup irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0515",
    "component": "Using Connectors – HTTP Request Header Case Sensitivity",
    "difficulty": "Extreme",
    "question": "HTTP header name matching is?",
    "options": {
      "A": "Case-sensitive",
      "B": "Case-insensitive",
      "C": "Lowercase only",
      "D": "Uppercase only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP headers are case-insensitive by spec.",
      "incorrect": {
        "A": "Incorrect per RFC.",
        "C": "Not enforced.",
        "D": "Not enforced."
      }
    }
  },
  {
    "id": "EXP-MS-0516",
    "component": "Using Connectors – DB Connector Metadata Caching",
    "difficulty": "Extreme",
    "question": "Why does DB connector cache metadata?",
    "options": {
      "A": "Security",
      "B": "Reduce schema lookup overhead",
      "C": "Prevent SQL injection",
      "D": "Improve locking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Metadata caching avoids repeated DB introspection.",
      "incorrect": {
        "A": "Not security.",
        "C": "Handled via parameters.",
        "D": "Locks unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0517",
    "component": "Using Connectors – FTP Binary Mode",
    "difficulty": "Extreme",
    "question": "Why use binary mode for FTP transfers?",
    "options": {
      "A": "Compression",
      "B": "Avoid character translation",
      "C": "Faster transfer",
      "D": "Encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Binary mode preserves raw bytes.",
      "incorrect": {
        "A": "No compression.",
        "C": "Speed varies.",
        "D": "Encryption is FTPS."
      }
    }
  },
  {
    "id": "EXP-MS-0518",
    "component": "Using Connectors – HTTP Request Payload Mutability",
    "difficulty": "Extreme",
    "question": "Why should payload not be modified before retry?",
    "options": {
      "A": "Validation fails",
      "B": "Retry sends altered data",
      "C": "Performance issue",
      "D": "Connector limitation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mutated payload breaks idempotent retries.",
      "incorrect": {
        "A": "Not validation-related.",
        "C": "Secondary.",
        "D": "Not limitation."
      }
    }
  },
  {
    "id": "EXP-MS-0519",
    "component": "Using Connectors – DB Connection Pool Exhaustion",
    "difficulty": "Extreme",
    "question": "Most effective mitigation for pool exhaustion?",
    "options": {
      "A": "Increase pool size",
      "B": "Reduce transaction duration",
      "C": "Add retries",
      "D": "Disable pooling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shorter transactions free connections faster.",
      "incorrect": {
        "A": "Temporary fix.",
        "C": "Worsens load.",
        "D": "Breaks scalability."
      }
    }
  },
  {
    "id": "EXP-MS-0520",
    "component": "Using Connectors – Connector Section Closure",
    "difficulty": "Extreme",
    "question": "What is the final indicator of connector robustness?",
    "options": {
      "A": "Successful happy-path execution",
      "B": "Correct behavior under failure and load",
      "C": "Minimal configuration",
      "D": "Fast execution time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Robustness is proven under stress and failure.",
      "incorrect": {
        "A": "Insufficient.",
        "C": "Not a quality metric.",
        "D": "Secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0521",
    "component": "Processing Records – For Each Scope Payload Behavior",
    "difficulty": "Extreme",
    "question": "Inside a For Each scope iterating over an array payload, what is the payload type for each iteration?",
    "options": {
      "A": "Original array",
      "B": "Current element",
      "C": "Map of index and value",
      "D": "Iterator object"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "For Each sets the payload to the current element.",
      "incorrect": {
        "A": "Original payload is split.",
        "C": "Index is not included automatically.",
        "D": "No iterator object is exposed."
      }
    }
  },
  {
    "id": "EXP-MS-0522",
    "component": "Processing Records – For Each Variable Scope",
    "difficulty": "Extreme",
    "question": "What happens to variables set inside a For Each after it completes?",
    "options": {
      "A": "They are discarded",
      "B": "They persist with last iteration value",
      "C": "They revert to original value",
      "D": "They become arrays"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Variables persist and hold the last iteration value.",
      "incorrect": {
        "A": "Vars are not local-only.",
        "C": "No automatic rollback.",
        "D": "Vars are scalar unless set otherwise."
      }
    }
  },
  {
    "id": "EXP-MS-0523",
    "component": "Processing Records – For Each Error Propagation",
    "difficulty": "Extreme",
    "question": "If an error occurs in one iteration of For Each, what is the default behavior?",
    "options": {
      "A": "Iteration is skipped",
      "B": "Error is logged and continues",
      "C": "For Each stops and error propagates",
      "D": "Only that record is rolled back"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "By default, errors stop the For Each and propagate.",
      "incorrect": {
        "A": "No skip by default.",
        "B": "Not automatic.",
        "D": "No per-record rollback."
      }
    }
  },
  {
    "id": "EXP-MS-0524",
    "component": "Processing Records – Batch Job Record Variable",
    "difficulty": "Extreme",
    "question": "Where is the current record stored during Batch Step execution?",
    "options": {
      "A": "payload",
      "B": "vars.record",
      "C": "attributes",
      "D": "batch:record"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Each batch record becomes the payload.",
      "incorrect": {
        "B": "No implicit variable.",
        "C": "Attributes hold metadata.",
        "D": "No such default object."
      }
    }
  },
  {
    "id": "EXP-MS-0525",
    "component": "Processing Records – Batch Commit Phase",
    "difficulty": "Extreme",
    "question": "What is the primary purpose of the Batch Commit phase?",
    "options": {
      "A": "Transform records",
      "B": "Persist successful records",
      "C": "Split payload",
      "D": "Handle errors only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Commit phase persists processed records.",
      "incorrect": {
        "A": "Transformation happens earlier.",
        "C": "Splitting happens in Input phase.",
        "D": "Errors handled separately."
      }
    }
  },

  {
    "id": "EXP-MS-0526",
    "component": "Processing Records – Batch Step Concurrency",
    "difficulty": "Extreme",
    "question": "What controls parallelism in a Batch Step?",
    "options": {
      "A": "maxConcurrency",
      "B": "blockSize",
      "C": "batchSize",
      "D": "threadingProfile"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "maxConcurrency controls parallel processing.",
      "incorrect": {
        "B": "Controls commit grouping.",
        "C": "Controls record grouping.",
        "D": "Not batch-specific."
      }
    }
  },
  {
    "id": "EXP-MS-0527",
    "component": "Processing Records – Batch Block Size",
    "difficulty": "Extreme",
    "question": "What does blockSize define in a Batch Job?",
    "options": {
      "A": "Total records",
      "B": "Records per commit",
      "C": "Records per step execution",
      "D": "Threads per step"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "blockSize controls how many records are committed together.",
      "incorrect": {
        "A": "Total is dynamic.",
        "C": "Not execution unit.",
        "D": "Threads separate."
      }
    }
  },
  {
    "id": "EXP-MS-0528",
    "component": "Processing Records – Batch Job Restartability",
    "difficulty": "Extreme",
    "question": "What enables a Batch Job to resume after failure?",
    "options": {
      "A": "Object Store persistence",
      "B": "Batch job name",
      "C": "Scheduler",
      "D": "Flow reference"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Batch uses Object Store to track state.",
      "incorrect": {
        "B": "Name alone insufficient.",
        "C": "Triggers only.",
        "D": "Routing only."
      }
    }
  },
  {
    "id": "EXP-MS-0529",
    "component": "Processing Records – Batch Aggregator",
    "difficulty": "Extreme",
    "question": "When does a Batch Aggregator execute?",
    "options": {
      "A": "Per record",
      "B": "Per block",
      "C": "Once per job",
      "D": "On error only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Aggregator runs once per block.",
      "incorrect": {
        "A": "Not per record.",
        "C": "Not entire job.",
        "D": "Not error-only."
      }
    }
  },
  {
    "id": "EXP-MS-0530",
    "component": "Processing Records – Batch Failure Handling",
    "difficulty": "Extreme",
    "question": "If a record fails in a Batch Step, what happens by default?",
    "options": {
      "A": "Entire batch fails",
      "B": "Only record is skipped",
      "C": "Job pauses",
      "D": "Application crashes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch continues processing other records.",
      "incorrect": {
        "A": "Not default.",
        "C": "No pause.",
        "D": "No crash."
      }
    }
  },

  {
    "id": "EXP-MS-0531",
    "component": "Processing Records – Async Scope Ordering",
    "difficulty": "Extreme",
    "question": "What guarantee does Async scope provide regarding execution order?",
    "options": {
      "A": "Strict ordering",
      "B": "Reverse ordering",
      "C": "No ordering guarantee",
      "D": "FIFO ordering"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async does not guarantee execution order.",
      "incorrect": {
        "A": "Not guaranteed.",
        "B": "No reversal.",
        "D": "Not FIFO."
      }
    }
  },
  {
    "id": "EXP-MS-0532",
    "component": "Processing Records – Async Scope Payload",
    "difficulty": "Extreme",
    "question": "What happens to the payload after Async scope?",
    "options": {
      "A": "Replaced by async result",
      "B": "Set to null",
      "C": "Remains unchanged",
      "D": "Merged automatically"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async does not modify main flow payload.",
      "incorrect": {
        "A": "No merge.",
        "B": "Not nulled.",
        "D": "No auto-merge."
      }
    }
  },
  {
    "id": "EXP-MS-0533",
    "component": "Processing Records – Async Error Handling",
    "difficulty": "Extreme",
    "question": "How are errors in Async scope handled by default?",
    "options": {
      "A": "Propagated to main flow",
      "B": "Ignored silently",
      "C": "Handled by async error handler",
      "D": "Crash application"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async has its own error handling context.",
      "incorrect": {
        "A": "Not propagated.",
        "B": "Not ignored.",
        "D": "No crash."
      }
    }
  },
  {
    "id": "EXP-MS-0534",
    "component": "Processing Records – DB Listener Record Processing",
    "difficulty": "Extreme",
    "question": "DB Listener emits records as?",
    "options": {
      "A": "Single aggregated payload",
      "B": "One record per event",
      "C": "Batch automatically",
      "D": "Stream only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each record triggers a separate event.",
      "incorrect": {
        "A": "Not aggregated.",
        "C": "Batch not implicit.",
        "D": "Not stream-only."
      }
    }
  },
  {
    "id": "EXP-MS-0535",
    "component": "Processing Records – DB Listener Watermark",
    "difficulty": "Extreme",
    "question": "What is the purpose of DB Listener watermark?",
    "options": {
      "A": "Performance tuning",
      "B": "Prevent duplicate processing",
      "C": "Schema validation",
      "D": "Thread control"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Watermark tracks last processed record.",
      "incorrect": {
        "A": "Secondary.",
        "C": "Unrelated.",
        "D": "Not threading."
      }
    }
  },

  {
    "id": "EXP-MS-0536",
    "component": "Processing Records – JMS Listener Acknowledgement",
    "difficulty": "Extreme",
    "question": "When is a JMS message acknowledged by default?",
    "options": {
      "A": "On receipt",
      "B": "After successful flow execution",
      "C": "Before commit",
      "D": "Manually only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Acknowledgement occurs after successful processing.",
      "incorrect": {
        "A": "Too early.",
        "C": "Commit differs.",
        "D": "Manual optional."
      }
    }
  },
  {
    "id": "EXP-MS-0537",
    "component": "Processing Records – JMS Redelivery",
    "difficulty": "Extreme",
    "question": "What triggers JMS message redelivery?",
    "options": {
      "A": "Logger failure",
      "B": "Transaction rollback",
      "C": "Slow processing",
      "D": "Async scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback causes message redelivery.",
      "incorrect": {
        "A": "Logging irrelevant.",
        "C": "No redelivery.",
        "D": "Async isolated."
      }
    }
  },
  {
    "id": "EXP-MS-0538",
    "component": "Processing Records – For Each vs Batch",
    "difficulty": "Extreme",
    "question": "Which is best for millions of records?",
    "options": {
      "A": "For Each",
      "B": "Choice",
      "C": "Batch Job",
      "D": "Async"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Batch Jobs are optimized for large datasets.",
      "incorrect": {
        "A": "Memory intensive.",
        "B": "Routing only.",
        "D": "Not record-oriented."
      }
    }
  },
  {
    "id": "EXP-MS-0539",
    "component": "Processing Records – For Each Streaming",
    "difficulty": "Extreme",
    "question": "How does streaming affect For Each?",
    "options": {
      "A": "Loads all records",
      "B": "Processes records lazily",
      "C": "Disables For Each",
      "D": "Forces batching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming allows lazy record consumption.",
      "incorrect": {
        "A": "Opposite.",
        "C": "For Each supports streaming.",
        "D": "No batching."
      }
    }
  },
  {
    "id": "EXP-MS-0540",
    "component": "Processing Records – Batch Job Memory",
    "difficulty": "Extreme",
    "question": "What minimizes Batch Job memory usage?",
    "options": {
      "A": "Large blockSize",
      "B": "Streaming input",
      "C": "High concurrency",
      "D": "Large payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming avoids loading all records.",
      "incorrect": {
        "A": "Increases memory.",
        "C": "More threads.",
        "D": "Increases memory."
      }
    }
  },
  {
    "id": "EXP-MS-0541",
    "component": "Processing Records – Batch Input Phase Streaming",
    "difficulty": "Extreme",
    "question": "Why should the Batch Input phase use streaming for very large datasets?",
    "options": {
      "A": "To enable parallel steps",
      "B": "To reduce initial memory footprint",
      "C": "To speed up commits",
      "D": "To guarantee ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming avoids loading all records into memory at once.",
      "incorrect": {
        "A": "Parallelism is step-level.",
        "C": "Commits are independent.",
        "D": "Ordering is not guaranteed."
      }
    }
  },
  {
    "id": "EXP-MS-0542",
    "component": "Processing Records – Batch Step Isolation",
    "difficulty": "Extreme",
    "question": "What is isolated between Batch Steps by default?",
    "options": {
      "A": "Variables",
      "B": "Payload only",
      "C": "Transactions",
      "D": "Thread pools"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Each Batch Step executes in its own transaction boundary.",
      "incorrect": {
        "A": "Vars propagate.",
        "B": "Payload flows through steps.",
        "D": "Thread pools are shared."
      }
    }
  },
  {
    "id": "EXP-MS-0543",
    "component": "Processing Records – Batch Step Failure Policy",
    "difficulty": "Extreme",
    "question": "How can a Batch Step be configured to stop the entire job on error?",
    "options": {
      "A": "Use For Each instead",
      "B": "Throw error in Input phase",
      "C": "Disable acceptPolicy",
      "D": "Use batch:fail-on-error"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "fail-on-error forces job termination on step failure.",
      "incorrect": {
        "A": "Different construct.",
        "B": "Input phase errors differ.",
        "C": "No such setting."
      }
    }
  },
  {
    "id": "EXP-MS-0544",
    "component": "Processing Records – Batch Aggregator Memory Risk",
    "difficulty": "Extreme",
    "question": "What is the main risk of using a Batch Aggregator with very large blocks?",
    "options": {
      "A": "Deadlocks",
      "B": "High memory usage",
      "C": "Duplicate commits",
      "D": "Lost records"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Aggregator holds block data in memory until execution.",
      "incorrect": {
        "A": "Not lock-related.",
        "C": "Commits remain atomic.",
        "D": "Records are tracked."
      }
    }
  },
  {
    "id": "EXP-MS-0545",
    "component": "Processing Records – For Each Index Access",
    "difficulty": "Extreme",
    "question": "How can the current index be accessed inside a For Each?",
    "options": {
      "A": "attributes.index",
      "B": "vars.index",
      "C": "Using counter variable manually",
      "D": "payload.index"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "For Each does not expose index automatically.",
      "incorrect": {
        "A": "No such attribute.",
        "B": "Not implicit.",
        "D": "Payload is the element."
      }
    }
  },

  {
    "id": "EXP-MS-0546",
    "component": "Processing Records – Async Scope Transaction Context",
    "difficulty": "Extreme",
    "question": "What happens to an active transaction when entering an Async scope?",
    "options": {
      "A": "It propagates",
      "B": "It is suspended",
      "C": "It is committed",
      "D": "It is rolled back"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async executes outside the original transaction.",
      "incorrect": {
        "A": "Transactions do not propagate.",
        "C": "No implicit commit.",
        "D": "No rollback."
      }
    }
  },
  {
    "id": "EXP-MS-0547",
    "component": "Processing Records – Async Scope Reliability",
    "difficulty": "Extreme",
    "question": "Why is Async scope risky for critical processing?",
    "options": {
      "A": "Low performance",
      "B": "No error propagation to main flow",
      "C": "High latency",
      "D": "Schema loss"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Failures may go unnoticed by the main flow.",
      "incorrect": {
        "A": "Async is performant.",
        "C": "Latency varies.",
        "D": "Schema unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0548",
    "component": "Processing Records – JMS Listener Concurrency",
    "difficulty": "Extreme",
    "question": "What controls parallel message consumption in JMS Listener?",
    "options": {
      "A": "maxConcurrency",
      "B": "ackMode",
      "C": "prefetch",
      "D": "threadingProfile"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "maxConcurrency defines concurrent consumers.",
      "incorrect": {
        "B": "Acknowledgement only.",
        "C": "Broker hint.",
        "D": "Not JMS-specific."
      }
    }
  },
  {
    "id": "EXP-MS-0549",
    "component": "Processing Records – JMS Redelivery Count",
    "difficulty": "Extreme",
    "question": "Where is JMS redelivery count typically exposed?",
    "options": {
      "A": "payload",
      "B": "attributes",
      "C": "vars",
      "D": "object store"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Redelivery metadata is in message attributes.",
      "incorrect": {
        "A": "Payload is body.",
        "C": "Vars are manual.",
        "D": "Not persisted automatically."
      }
    }
  },
  {
    "id": "EXP-MS-0550",
    "component": "Processing Records – For Each vs Choice",
    "difficulty": "Extreme",
    "question": "Why is Choice unsuitable for record-by-record processing?",
    "options": {
      "A": "No conditions",
      "B": "Processes only one route",
      "C": "Cannot iterate collections",
      "D": "Consumes too much memory"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Choice routes a single event, not collections.",
      "incorrect": {
        "A": "Choice uses conditions.",
        "B": "True but not core issue.",
        "D": "Not memory-related."
      }
    }
  },

  {
    "id": "EXP-MS-0551",
    "component": "Processing Records – Batch Job Ordering",
    "difficulty": "Extreme",
    "question": "Does a Batch Job guarantee record processing order?",
    "options": {
      "A": "Always",
      "B": "Only with blockSize=1",
      "C": "No",
      "D": "Only with concurrency=1"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Parallel execution breaks ordering guarantees.",
      "incorrect": {
        "A": "Never guaranteed.",
        "B": "Still not guaranteed.",
        "D": "Not strictly guaranteed."
      }
    }
  },
  {
    "id": "EXP-MS-0552",
    "component": "Processing Records – Batch Job Idempotency",
    "difficulty": "Extreme",
    "question": "Best way to ensure idempotency in Batch Jobs?",
    "options": {
      "A": "Use large blocks",
      "B": "Rely on restartability",
      "C": "Use unique keys in target system",
      "D": "Disable retries"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Target system constraints ensure true idempotency.",
      "incorrect": {
        "A": "Blocks don't prevent duplicates.",
        "B": "Restarts may reprocess.",
        "D": "Retries are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0553",
    "component": "Processing Records – For Each Memory Pitfall",
    "difficulty": "Extreme",
    "question": "What causes For Each to consume excessive memory?",
    "options": {
      "A": "Streaming payload",
      "B": "Large in-memory collections",
      "C": "Low concurrency",
      "D": "Small payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Entire collection must exist in memory if not streamed.",
      "incorrect": {
        "A": "Streaming reduces memory.",
        "C": "Concurrency unrelated.",
        "D": "No impact."
      }
    }
  },
  {
    "id": "EXP-MS-0554",
    "component": "Processing Records – Async Scope Completion",
    "difficulty": "Extreme",
    "question": "When does an Async scope complete relative to the main flow?",
    "options": {
      "A": "Before main flow continues",
      "B": "After main flow ends",
      "C": "In parallel without waiting",
      "D": "Only on success"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Main flow does not wait for async completion.",
      "incorrect": {
        "A": "No blocking.",
        "B": "No guarantee.",
        "D": "Runs regardless."
      }
    }
  },
  {
    "id": "EXP-MS-0555",
    "component": "Processing Records – DB Listener Transaction Mode",
    "difficulty": "Extreme",
    "question": "Why use transactional DB Listener?",
    "options": {
      "A": "Faster polling",
      "B": "Exactly-once processing semantics",
      "C": "Lower memory usage",
      "D": "Automatic batching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactions ensure records are not reprocessed incorrectly.",
      "incorrect": {
        "A": "Performance may decrease.",
        "C": "Memory unaffected.",
        "D": "Batching is separate."
      }
    }
  },

  {
    "id": "EXP-MS-0556",
    "component": "Processing Records – JMS Prefetch Impact",
    "difficulty": "Extreme",
    "question": "High JMS prefetch value can cause?",
    "options": {
      "A": "Message loss",
      "B": "Memory pressure on consumer",
      "C": "Lower throughput",
      "D": "Duplicate delivery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Prefetched messages are held in memory.",
      "incorrect": {
        "A": "Messages are buffered, not lost.",
        "C": "Throughput may increase.",
        "D": "Delivery semantics unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0557",
    "component": "Processing Records – Batch Job Monitoring",
    "difficulty": "Extreme",
    "question": "Best way to monitor Batch Job progress?",
    "options": {
      "A": "Custom loggers",
      "B": "Anypoint Monitoring Batch metrics",
      "C": "Object Store inspection",
      "D": "Debugger"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform metrics expose processed and failed counts.",
      "incorrect": {
        "A": "Manual and coarse.",
        "C": "Not real-time.",
        "D": "Not production-safe."
      }
    }
  },
  {
    "id": "EXP-MS-0558",
    "component": "Processing Records – For Each Nested Usage",
    "difficulty": "Extreme",
    "question": "Main risk of nested For Each scopes?",
    "options": {
      "A": "Compilation error",
      "B": "Exponential performance impact",
      "C": "Schema loss",
      "D": "Invalid payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Nested iteration multiplies execution cost.",
      "incorrect": {
        "A": "Valid XML.",
        "C": "Schema unaffected.",
        "D": "Payload remains valid."
      }
    }
  },
  {
    "id": "EXP-MS-0559",
    "component": "Processing Records – Async vs Batch",
    "difficulty": "Extreme",
    "question": "Why Async is not a replacement for Batch Jobs?",
    "options": {
      "A": "Lower performance",
      "B": "No state tracking or restartability",
      "C": "Harder syntax",
      "D": "Limited connectors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async lacks checkpointing and restart support.",
      "incorrect": {
        "A": "Async is fast.",
        "C": "Syntax is simple.",
        "D": "Connectors unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0560",
    "component": "Processing Records – Section Continuation Marker",
    "difficulty": "Extreme",
    "question": "What defines correct record-processing design?",
    "options": {
      "A": "Minimal code",
      "B": "Correct construct per data volume and reliability needs",
      "C": "Maximum concurrency",
      "D": "Single flow usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design must match volume, reliability, and semantics.",
      "incorrect": {
        "A": "Not sufficient.",
        "C": "May cause issues.",
        "D": "Oversimplification."
      }
    }
  },
  {
    "id": "EXP-MS-0561",
    "component": "Processing Records – Batch Commit Transaction Scope",
    "difficulty": "Extreme",
    "question": "What transaction boundary applies during the Batch Commit phase?",
    "options": {
      "A": "Single transaction for entire job",
      "B": "One transaction per record",
      "C": "One transaction per block",
      "D": "No transaction"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Each block is committed within its own transaction.",
      "incorrect": {
        "A": "Too broad.",
        "B": "Too granular.",
        "D": "Commit phase is transactional."
      }
    }
  },
  {
    "id": "EXP-MS-0562",
    "component": "Processing Records – Batch Step Retry Policy",
    "difficulty": "Extreme",
    "question": "Where should retry logic be implemented for failed batch records?",
    "options": {
      "A": "Flow global error handler",
      "B": "Batch Step error handling",
      "C": "Scheduler",
      "D": "Async scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch Step error handling allows record-level retries.",
      "incorrect": {
        "A": "Too coarse.",
        "C": "Not related to execution.",
        "D": "Not batch-aware."
      }
    }
  },
  {
    "id": "EXP-MS-0563",
    "component": "Processing Records – For Each Backpressure",
    "difficulty": "Extreme",
    "question": "How does For Each react to downstream backpressure?",
    "options": {
      "A": "Buffers all records",
      "B": "Pauses iteration until downstream frees",
      "C": "Skips records",
      "D": "Throws error immediately"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Iteration pauses when downstream cannot accept more events.",
      "incorrect": {
        "A": "No unbounded buffering.",
        "C": "No skipping.",
        "D": "Not default."
      }
    }
  },
  {
    "id": "EXP-MS-0564",
    "component": "Processing Records – Async Scope Backpressure",
    "difficulty": "Extreme",
    "question": "How is backpressure handled in Async scope?",
    "options": {
      "A": "Caller is blocked",
      "B": "Tasks are queued",
      "C": "Tasks are dropped",
      "D": "Flow fails"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async work is queued in the async scheduler.",
      "incorrect": {
        "A": "Main flow continues.",
        "C": "Not dropped by default.",
        "D": "No failure."
      }
    }
  },
  {
    "id": "EXP-MS-0565",
    "component": "Processing Records – DB Listener Exactly-Once",
    "difficulty": "Extreme",
    "question": "Which combination best achieves exactly-once semantics with DB Listener?",
    "options": {
      "A": "High polling frequency",
      "B": "Transactional listener + unique keys",
      "C": "Async processing",
      "D": "Large batch size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactions plus unique constraints ensure exactly-once behavior.",
      "incorrect": {
        "A": "Does not ensure semantics.",
        "C": "Async weakens guarantees.",
        "D": "Batching alone insufficient."
      }
    }
  },

  {
    "id": "EXP-MS-0566",
    "component": "Processing Records – JMS Listener Session Scope",
    "difficulty": "Extreme",
    "question": "What is shared across messages in a single JMS session?",
    "options": {
      "A": "Payload",
      "B": "Flow variables",
      "C": "Transaction context",
      "D": "Message attributes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "A JMS session maintains a single transaction context.",
      "incorrect": {
        "A": "Payload is per message.",
        "B": "Vars are per event.",
        "D": "Attributes are per message."
      }
    }
  },
  {
    "id": "EXP-MS-0567",
    "component": "Processing Records – Batch Job Throughput Tuning",
    "difficulty": "Extreme",
    "question": "Which parameter most directly increases Batch Job throughput?",
    "options": {
      "A": "blockSize",
      "B": "maxConcurrency",
      "C": "jobName",
      "D": "scheduler frequency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Higher concurrency allows more parallel record processing.",
      "incorrect": {
        "A": "Affects commit frequency.",
        "C": "Identifier only.",
        "D": "Not execution speed."
      }
    }
  },
  {
    "id": "EXP-MS-0568",
    "component": "Processing Records – For Each vs Batch Error Visibility",
    "difficulty": "Extreme",
    "question": "Why are Batch Job errors easier to analyze than For Each errors?",
    "options": {
      "A": "Batch uses more logs",
      "B": "Batch provides per-record failure tracking",
      "C": "For Each hides errors",
      "D": "Batch stops on first error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch tracks success and failure per record.",
      "incorrect": {
        "A": "Logging is configurable.",
        "C": "For Each propagates errors.",
        "D": "Batch continues by default."
      }
    }
  },
  {
    "id": "EXP-MS-0569",
    "component": "Processing Records – Async Scope Reliability Tradeoff",
    "difficulty": "Extreme",
    "question": "What reliability tradeoff does Async scope introduce?",
    "options": {
      "A": "Lower throughput",
      "B": "Loss of transactional guarantees",
      "C": "Higher latency",
      "D": "Reduced scalability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async breaks transaction propagation and acknowledgement chains.",
      "incorrect": {
        "A": "Throughput often increases.",
        "C": "Latency varies.",
        "D": "Scalability improves."
      }
    }
  },
  {
    "id": "EXP-MS-0570",
    "component": "Processing Records – Batch Job Completion Event",
    "difficulty": "Extreme",
    "question": "When is the Batch Job completion phase executed?",
    "options": {
      "A": "After each step",
      "B": "After each block",
      "C": "After all records processed",
      "D": "On first failure"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Completion runs once after all records finish.",
      "incorrect": {
        "A": "Steps run earlier.",
        "B": "Blocks commit earlier.",
        "D": "Failure does not trigger completion."
      }
    }
  },

  {
    "id": "EXP-MS-0571",
    "component": "Processing Records – Batch Job Restart Limitation",
    "difficulty": "Extreme",
    "question": "Which change prevents a Batch Job from restarting correctly?",
    "options": {
      "A": "Increasing blockSize",
      "B": "Changing job name",
      "C": "Increasing maxConcurrency",
      "D": "Adding a new step"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restart state is keyed by job name.",
      "incorrect": {
        "A": "Does not affect restart identity.",
        "C": "Concurrency change allowed.",
        "D": "Steps may be added carefully."
      }
    }
  },
  {
    "id": "EXP-MS-0572",
    "component": "Processing Records – For Each CPU Utilization",
    "difficulty": "Extreme",
    "question": "What primarily drives CPU usage in For Each processing?",
    "options": {
      "A": "Number of elements",
      "B": "Complexity of inner processing",
      "C": "Payload size",
      "D": "Streaming strategy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inner logic complexity dominates CPU usage.",
      "incorrect": {
        "A": "Element count alone insufficient.",
        "C": "More memory-related.",
        "D": "Affects memory, not CPU."
      }
    }
  },
  {
    "id": "EXP-MS-0573",
    "component": "Processing Records – JMS Redelivery Storm",
    "difficulty": "Extreme",
    "question": "What causes a JMS redelivery storm?",
    "options": {
      "A": "Large messages",
      "B": "Immediate rollback without delay",
      "C": "High concurrency",
      "D": "Slow consumer"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immediate rollback causes rapid redelivery loops.",
      "incorrect": {
        "A": "Size not causal.",
        "C": "Concurrency alone insufficient.",
        "D": "Slow consumer reduces rate."
      }
    }
  },
  {
    "id": "EXP-MS-0574",
    "component": "Processing Records – Batch Step Transaction Cost",
    "difficulty": "Extreme",
    "question": "Why can very small blockSize hurt Batch performance?",
    "options": {
      "A": "Increased transaction overhead",
      "B": "Higher memory usage",
      "C": "Reduced parallelism",
      "D": "Lost records"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Too many commits increase transaction cost.",
      "incorrect": {
        "B": "Memory usage is lower.",
        "C": "Concurrency unchanged.",
        "D": "Records are not lost."
      }
    }
  },
  {
    "id": "EXP-MS-0575",
    "component": "Processing Records – Async Scope Observability",
    "difficulty": "Extreme",
    "question": "Why is Async scope harder to observe in production?",
    "options": {
      "A": "No logs",
      "B": "Detached execution from main trace",
      "C": "No metrics",
      "D": "Lower performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async work is detached from main transaction traces.",
      "incorrect": {
        "A": "Logs can exist.",
        "C": "Metrics exist.",
        "D": "Not the issue."
      }
    }
  },

  {
    "id": "EXP-MS-0576",
    "component": "Processing Records – DB Listener Polling Gap",
    "difficulty": "Extreme",
    "question": "What risk does a long DB Listener polling interval introduce?",
    "options": {
      "A": "Duplicate records",
      "B": "Increased latency for new records",
      "C": "Data loss",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "New records wait longer before processing.",
      "incorrect": {
        "A": "Watermark prevents duplicates.",
        "C": "No data loss.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0577",
    "component": "Processing Records – Batch Job Partial Failure",
    "difficulty": "Extreme",
    "question": "After a partial Batch Job failure, which records are reprocessed on restart?",
    "options": {
      "A": "All records",
      "B": "Only failed records",
      "C": "All records in failed block",
      "D": "All records after failure point"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Restart resumes from last committed block.",
      "incorrect": {
        "A": "Committed records skipped.",
        "B": "Block-based, not record-based.",
        "C": "May include more."
      }
    }
  },
  {
    "id": "EXP-MS-0578",
    "component": "Processing Records – For Each vs Stream",
    "difficulty": "Extreme",
    "question": "Why combine For Each with streaming sources?",
    "options": {
      "A": "Enable retries",
      "B": "Reduce memory footprint",
      "C": "Increase concurrency",
      "D": "Guarantee ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming prevents loading full collections.",
      "incorrect": {
        "A": "Retries unrelated.",
        "C": "Concurrency unchanged.",
        "D": "Ordering not guaranteed."
      }
    }
  },
  {
    "id": "EXP-MS-0579",
    "component": "Processing Records – JMS Listener Acknowledgement Mode",
    "difficulty": "Extreme",
    "question": "Which acknowledgement mode provides the strongest delivery guarantee?",
    "options": {
      "A": "AUTO_ACKNOWLEDGE",
      "B": "CLIENT_ACKNOWLEDGE",
      "C": "DUPS_OK_ACKNOWLEDGE",
      "D": "TRANSACTED"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Transacted sessions tie acknowledgement to commit.",
      "incorrect": {
        "A": "Automatic and weaker.",
        "B": "Manual but error-prone.",
        "C": "Allows duplicates."
      }
    }
  },
  {
    "id": "EXP-MS-0580",
    "component": "Processing Records – Section Continuation Marker",
    "difficulty": "Extreme",
    "question": "What ultimately determines correct record-processing strategy?",
    "options": {
      "A": "Developer preference",
      "B": "Data volume, failure semantics, and restart needs",
      "C": "Simplest construct",
      "D": "Fastest execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Strategy must align with volume, reliability, and restartability.",
      "incorrect": {
        "A": "Subjective.",
        "C": "Often insufficient.",
        "D": "Not primary."
      }
    }
  },
  {
    "id": "EXP-MS-0581",
    "component": "Processing Records – Batch Job Resource Cleanup",
    "difficulty": "Extreme",
    "question": "When are resources such as DB connections released in a Batch Job?",
    "options": {
      "A": "After each record",
      "B": "After each step",
      "C": "After commit of each block",
      "D": "Only at job completion"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Resources are released at transaction boundaries, typically per block commit.",
      "incorrect": {
        "A": "Too granular.",
        "B": "Steps may span blocks.",
        "D": "Not held until end."
      }
    }
  },
  {
    "id": "EXP-MS-0582",
    "component": "Processing Records – Batch Step Variable Visibility",
    "difficulty": "Extreme",
    "question": "Which variables are visible across Batch Steps?",
    "options": {
      "A": "Flow variables only",
      "B": "Record variables only",
      "C": "Job variables",
      "D": "No variables"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Job variables are shared across steps.",
      "incorrect": {
        "A": "Flow vars are step-scoped.",
        "B": "Record vars are record-scoped.",
        "D": "Variables do exist."
      }
    }
  },
  {
    "id": "EXP-MS-0583",
    "component": "Processing Records – Batch Step Transaction Rollback",
    "difficulty": "Extreme",
    "question": "If a transaction rolls back in a Batch Step, what happens to the block?",
    "options": {
      "A": "Block is partially committed",
      "B": "Entire block is retried",
      "C": "Block is skipped",
      "D": "Job ends immediately"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback causes the entire block to be retried or marked failed.",
      "incorrect": {
        "A": "No partial commits.",
        "C": "Not skipped by default.",
        "D": "Job may continue."
      }
    }
  },
  {
    "id": "EXP-MS-0584",
    "component": "Processing Records – For Each Transaction Boundary",
    "difficulty": "Extreme",
    "question": "What is the default transaction scope of a For Each?",
    "options": {
      "A": "One transaction per element",
      "B": "Single transaction for entire For Each",
      "C": "No transaction unless explicitly defined",
      "D": "Nested transaction"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "For Each is non-transactional unless wrapped in a transaction scope.",
      "incorrect": {
        "A": "Not implicit.",
        "B": "No automatic transaction.",
        "D": "Nested only if defined."
      }
    }
  },
  {
    "id": "EXP-MS-0585",
    "component": "Processing Records – Async Scope Failure Visibility",
    "difficulty": "Extreme",
    "question": "How can Async scope failures be reliably observed?",
    "options": {
      "A": "Ignore errors",
      "B": "Rely on main flow error handler",
      "C": "Implement explicit logging and alerts",
      "D": "Disable Async"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async requires explicit observability mechanisms.",
      "incorrect": {
        "A": "Errors would be lost.",
        "B": "Not propagated.",
        "D": "Not a solution."
      }
    }
  },

  {
    "id": "EXP-MS-0586",
    "component": "Processing Records – JMS Listener Transaction Timeout",
    "difficulty": "Extreme",
    "question": "What happens if a JMS transaction exceeds its timeout?",
    "options": {
      "A": "Message is acknowledged",
      "B": "Transaction is rolled back",
      "C": "Listener stops permanently",
      "D": "Message is lost"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeout causes transaction rollback and message redelivery.",
      "incorrect": {
        "A": "Not acknowledged.",
        "C": "Listener continues.",
        "D": "Broker retains message."
      }
    }
  },
  {
    "id": "EXP-MS-0587",
    "component": "Processing Records – Batch Job Parallelism Limit",
    "difficulty": "Extreme",
    "question": "What limits effective parallelism in a Batch Job?",
    "options": {
      "A": "Job name",
      "B": "Underlying system capacity",
      "C": "Scheduler frequency",
      "D": "Payload format"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CPU, DB, and downstream limits cap parallelism.",
      "incorrect": {
        "A": "Identifier only.",
        "C": "Trigger only.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0588",
    "component": "Processing Records – For Each Exception Handling",
    "difficulty": "Extreme",
    "question": "How can errors be isolated to individual elements in For Each?",
    "options": {
      "A": "Global error handler",
      "B": "Try scope inside For Each",
      "C": "Async scope",
      "D": "Batch Job"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Try scope allows per-element error handling.",
      "incorrect": {
        "A": "Applies to entire flow.",
        "C": "Async changes semantics.",
        "D": "Different construct."
      }
    }
  },
  {
    "id": "EXP-MS-0589",
    "component": "Processing Records – Batch Job Failure Metrics",
    "difficulty": "Extreme",
    "question": "Where are Batch Job failure metrics primarily exposed?",
    "options": {
      "A": "Application logs only",
      "B": "Anypoint Monitoring",
      "C": "Object Store",
      "D": "Debugger"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Monitoring exposes failed and successful record counts.",
      "incorrect": {
        "A": "Logs are supplementary.",
        "C": "State only.",
        "D": "Not production."
      }
    }
  },
  {
    "id": "EXP-MS-0590",
    "component": "Processing Records – Async Scope Load Shedding",
    "difficulty": "Extreme",
    "question": "What happens when Async queue is saturated?",
    "options": {
      "A": "Main flow blocks",
      "B": "Tasks are queued with delay",
      "C": "Tasks may be rejected or delayed",
      "D": "Application crashes"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Saturation can lead to delayed or rejected tasks.",
      "incorrect": {
        "A": "Main flow continues.",
        "B": "Queue has limits.",
        "D": "No crash."
      }
    }
  },

  {
    "id": "EXP-MS-0591",
    "component": "Processing Records – DB Listener Consistency Window",
    "difficulty": "Extreme",
    "question": "Why can DB Listener miss records without proper watermark strategy?",
    "options": {
      "A": "Slow polling",
      "B": "Clock skew or non-monotonic keys",
      "C": "Large payloads",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Non-monotonic values can fall outside polling window.",
      "incorrect": {
        "A": "Latency only.",
        "C": "Unrelated.",
        "D": "Not relevant."
      }
    }
  },
  {
    "id": "EXP-MS-0592",
    "component": "Processing Records – Batch Job Resource Starvation",
    "difficulty": "Extreme",
    "question": "What can cause resource starvation in Batch Jobs?",
    "options": {
      "A": "Low concurrency",
      "B": "Excessive parallelism",
      "C": "Small blockSize",
      "D": "Streaming input"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too much parallelism overwhelms downstream systems.",
      "incorrect": {
        "A": "Opposite effect.",
        "C": "Affects commit overhead.",
        "D": "Streaming reduces memory."
      }
    }
  },
  {
    "id": "EXP-MS-0593",
    "component": "Processing Records – For Each Nested Transactions",
    "difficulty": "Extreme",
    "question": "What happens if a transaction scope wraps a nested For Each?",
    "options": {
      "A": "Each element has its own transaction",
      "B": "All iterations share the same transaction",
      "C": "Transaction is ignored",
      "D": "Compilation error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Outer transaction applies to all iterations.",
      "incorrect": {
        "A": "Not per-element.",
        "C": "Transaction is honored.",
        "D": "Valid configuration."
      }
    }
  },
  {
    "id": "EXP-MS-0594",
    "component": "Processing Records – JMS Listener Ordering",
    "difficulty": "Extreme",
    "question": "When is message ordering preserved in JMS Listener?",
    "options": {
      "A": "Always",
      "B": "When concurrency = 1",
      "C": "When using Async",
      "D": "When using Batch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Single consumer preserves broker order.",
      "incorrect": {
        "A": "Concurrency breaks order.",
        "C": "Async breaks order.",
        "D": "Batch reorders."
      }
    }
  },
  {
    "id": "EXP-MS-0595",
    "component": "Processing Records – Batch Job Checkpoint Granularity",
    "difficulty": "Extreme",
    "question": "What defines checkpoint granularity in Batch Jobs?",
    "options": {
      "A": "maxConcurrency",
      "B": "blockSize",
      "C": "Step count",
      "D": "Job name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "blockSize determines commit/checkpoint frequency.",
      "incorrect": {
        "A": "Concurrency only.",
        "C": "Not checkpoint-related.",
        "D": "Identifier only."
      }
    }
  },

  {
    "id": "EXP-MS-0596",
    "component": "Processing Records – Async Scope Thread Usage",
    "difficulty": "Extreme",
    "question": "Async scope executes tasks on which scheduler?",
    "options": {
      "A": "CPU intensive",
      "B": "IO scheduler",
      "C": "Dedicated async scheduler",
      "D": "Main thread"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Async uses its own scheduler pool.",
      "incorrect": {
        "A": "Used for DW.",
        "B": "Used for connectors.",
        "D": "Not main."
      }
    }
  },
  {
    "id": "EXP-MS-0597",
    "component": "Processing Records – Batch Job Failure Isolation",
    "difficulty": "Extreme",
    "question": "Why are Batch Jobs safer than For Each for bulk processing?",
    "options": {
      "A": "Faster execution",
      "B": "Record-level failure isolation",
      "C": "Simpler syntax",
      "D": "Lower latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch isolates failures per record/block.",
      "incorrect": {
        "A": "Performance varies.",
        "C": "Syntax is more complex.",
        "D": "Latency higher."
      }
    }
  },
  {
    "id": "EXP-MS-0598",
    "component": "Processing Records – DB Listener Duplicate Risk",
    "difficulty": "Extreme",
    "question": "What configuration mistake leads to duplicate DB Listener processing?",
    "options": {
      "A": "High concurrency",
      "B": "Missing watermark",
      "C": "Streaming disabled",
      "D": "Small polling interval"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without watermark, records can be re-read.",
      "incorrect": {
        "A": "Concurrency affects order.",
        "C": "Streaming unrelated.",
        "D": "Interval affects latency."
      }
    }
  },
  {
    "id": "EXP-MS-0599",
    "component": "Processing Records – For Each Payload Mutation Risk",
    "difficulty": "Extreme",
    "question": "Why can mutating payload inside For Each be risky?",
    "options": {
      "A": "Schema loss",
      "B": "Unexpected downstream behavior",
      "C": "Compilation error",
      "D": "Transaction rollback"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Downstream may expect original payload structure.",
      "incorrect": {
        "A": "Schema remains valid.",
        "C": "Valid syntax.",
        "D": "Not transactional."
      }
    }
  },
  {
    "id": "EXP-MS-0600",
    "component": "Processing Records – Section Integrity Marker",
    "difficulty": "Extreme",
    "question": "What signals completion of Processing Records domain?",
    "options": {
      "A": "All constructs used",
      "B": "Correct use of For Each, Batch, Async, and Listeners per scenario",
      "C": "Maximum concurrency",
      "D": "No errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct construct selection per scenario defines mastery.",
      "incorrect": {
        "A": "Usage alone insufficient.",
        "C": "Concurrency is contextual.",
        "D": "Errors may still occur."
      }
    }
  },

  {
    "id": "EXP-MS-0601",
    "component": "Processing Records – Batch Job Finalization Logic",
    "difficulty": "Extreme",
    "question": "Where should cleanup logic for Batch Jobs be placed?",
    "options": {
      "A": "Input phase",
      "B": "Process phase",
      "C": "On Complete phase",
      "D": "Scheduler"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "On Complete executes after all records finish.",
      "incorrect": {
        "A": "Runs too early.",
        "B": "Runs per record.",
        "D": "Not job-aware."
      }
    }
  },
  {
    "id": "EXP-MS-0602",
    "component": "Processing Records – Batch Job State Corruption",
    "difficulty": "Extreme",
    "question": "What can corrupt Batch Job restart state?",
    "options": {
      "A": "Increasing concurrency",
      "B": "Clearing Object Store",
      "C": "Changing blockSize",
      "D": "Adding logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restart state is stored in Object Store.",
      "incorrect": {
        "A": "Concurrency change allowed.",
        "C": "Block size change allowed.",
        "D": "Logging irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0603",
    "component": "Processing Records – For Each Streaming Constraint",
    "difficulty": "Extreme",
    "question": "When does For Each lose streaming benefits?",
    "options": {
      "A": "Simple transformations",
      "B": "Materializing the collection",
      "C": "Low concurrency",
      "D": "Small payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Materializing forces full load into memory.",
      "incorrect": {
        "A": "Does not break streaming.",
        "C": "Unrelated.",
        "D": "Payload size irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0604",
    "component": "Processing Records – Async Scope Retry Limitation",
    "difficulty": "Extreme",
    "question": "Why is retry logic difficult with Async scope?",
    "options": {
      "A": "No error handlers",
      "B": "Detached execution context",
      "C": "Low performance",
      "D": "Syntax limitation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Detached context complicates coordinated retries.",
      "incorrect": {
        "A": "Error handlers exist.",
        "C": "Performance unrelated.",
        "D": "Syntax sufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0605",
    "component": "Processing Records – JMS Listener Duplicate Handling",
    "difficulty": "Extreme",
    "question": "Best strategy to handle JMS duplicate messages?",
    "options": {
      "A": "Ignore duplicates",
      "B": "Use idempotent receiver",
      "C": "Disable retries",
      "D": "Increase concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent receiver filters duplicates reliably.",
      "incorrect": {
        "A": "Unsafe.",
        "C": "Does not prevent duplicates.",
        "D": "Worsens duplicates."
      }
    }
  },

  {
    "id": "EXP-MS-0606",
    "component": "Processing Records – Batch Job Payload Evolution",
    "difficulty": "Extreme",
    "question": "How does payload evolve across Batch Steps?",
    "options": {
      "A": "Reset each step",
      "B": "Accumulates across steps",
      "C": "Carries forward per record",
      "D": "Becomes job metadata"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Each record payload is transformed step by step.",
      "incorrect": {
        "A": "Not reset.",
        "B": "No accumulation across records.",
        "D": "Metadata separate."
      }
    }
  },
  {
    "id": "EXP-MS-0607",
    "component": "Processing Records – For Each Parallelism Limit",
    "difficulty": "Extreme",
    "question": "Why is For Each inherently sequential?",
    "options": {
      "A": "Single thread execution",
      "B": "Ordering guarantee",
      "C": "Design constraint",
      "D": "Lack of concurrency setting"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "For Each has no built-in concurrency control.",
      "incorrect": {
        "A": "Execution may still hop threads.",
        "B": "Ordering is side effect.",
        "C": "Not arbitrary."
      }
    }
  },
  {
    "id": "EXP-MS-0608",
    "component": "Processing Records – Batch Job Error Escalation",
    "difficulty": "Extreme",
    "question": "How can Batch Job escalate errors to calling flow?",
    "options": {
      "A": "Throw error in step",
      "B": "Use on-error-propagate in completion phase",
      "C": "Fail Input phase",
      "D": "Not possible"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Completion phase can propagate job-level errors.",
      "incorrect": {
        "A": "Step errors are isolated.",
        "C": "Input failure aborts job.",
        "D": "Escalation is possible."
      }
    }
  },
  {
    "id": "EXP-MS-0609",
    "component": "Processing Records – Async Scope Message Loss Risk",
    "difficulty": "Extreme",
    "question": "Why can Async scope lead to message loss in crash scenarios?",
    "options": {
      "A": "No persistence",
      "B": "No retries",
      "C": "No acknowledgement",
      "D": "No transactions"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Async tasks are not persisted by default.",
      "incorrect": {
        "B": "Retries can exist.",
        "C": "Ack unrelated.",
        "D": "Transactions are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0610",
    "component": "Processing Records – Section Closure",
    "difficulty": "Extreme",
    "question": "What is the defining risk when misusing record-processing scopes?",
    "options": {
      "A": "Compilation failure",
      "B": "Silent data loss or duplication",
      "C": "Slower startup",
      "D": "XML validation errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Misuse leads to subtle but severe data integrity issues.",
      "incorrect": {
        "A": "Rare.",
        "C": "Secondary.",
        "D": "Caught early."
      }
    }
  },

  {
    "id": "EXP-MS-0611",
    "component": "Processing Records – Batch Job External Side Effects",
    "difficulty": "Extreme",
    "question": "Why must external side effects be idempotent in Batch Jobs?",
    "options": {
      "A": "For performance",
      "B": "Because records may be retried",
      "C": "For schema validation",
      "D": "For concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can re-execute side effects.",
      "incorrect": {
        "A": "Not main reason.",
        "C": "Unrelated.",
        "D": "Secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0612",
    "component": "Processing Records – For Each Debugging Difficulty",
    "difficulty": "Extreme",
    "question": "Why is debugging For Each harder with large datasets?",
    "options": {
      "A": "No logs",
      "B": "High repetition obscures root cause",
      "C": "Debugger unsupported",
      "D": "Compilation issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated execution makes isolating failures harder.",
      "incorrect": {
        "A": "Logs exist.",
        "C": "Debugger works.",
        "D": "No compilation issue."
      }
    }
  },
  {
    "id": "EXP-MS-0613",
    "component": "Processing Records – Batch Job Success Criteria",
    "difficulty": "Extreme",
    "question": "When is a Batch Job considered successful?",
    "options": {
      "A": "No failures occurred",
      "B": "All records processed or accounted for",
      "C": "Completion phase runs",
      "D": "Scheduler triggers next run"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Success means every record is processed or handled.",
      "incorrect": {
        "A": "Failures may be acceptable.",
        "C": "Completion alone insufficient.",
        "D": "Trigger unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0614",
    "component": "Processing Records – Async Scope Use Case Boundary",
    "difficulty": "Extreme",
    "question": "When is Async scope most appropriate?",
    "options": {
      "A": "Critical data processing",
      "B": "Fire-and-forget side effects",
      "C": "Transactional updates",
      "D": "Exactly-once flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async suits non-critical side effects.",
      "incorrect": {
        "A": "Risky.",
        "C": "Breaks transactions.",
        "D": "No guarantees."
      }
    }
  },
  {
    "id": "EXP-MS-0615",
    "component": "Processing Records – DB Listener Scaling Risk",
    "difficulty": "Extreme",
    "question": "What risk arises when horizontally scaling DB Listener flows?",
    "options": {
      "A": "Lower throughput",
      "B": "Duplicate record processing",
      "C": "Schema mismatch",
      "D": "Polling stops"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Multiple instances may poll same records.",
      "incorrect": {
        "A": "Throughput may increase.",
        "C": "Unrelated.",
        "D": "Polling continues."
      }
    }
  },

  {
    "id": "EXP-MS-0616",
    "component": "Processing Records – Batch Job External Consistency",
    "difficulty": "Extreme",
    "question": "How can Batch Jobs maintain consistency with external systems?",
    "options": {
      "A": "Disable retries",
      "B": "Use idempotent external APIs",
      "C": "Increase concurrency",
      "D": "Use Async scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent APIs tolerate retries safely.",
      "incorrect": {
        "A": "Risky.",
        "C": "Worsens load.",
        "D": "Weakens guarantees."
      }
    }
  },
  {
    "id": "EXP-MS-0617",
    "component": "Processing Records – For Each Memory Leak Pattern",
    "difficulty": "Extreme",
    "question": "Which pattern risks memory leaks in For Each?",
    "options": {
      "A": "Streaming input",
      "B": "Accumulating results in variables",
      "C": "Simple transformations",
      "D": "Logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accumulating data grows memory unbounded.",
      "incorrect": {
        "A": "Streaming is safe.",
        "C": "No accumulation.",
        "D": "Logs are flushed."
      }
    }
  },
  {
    "id": "EXP-MS-0618",
    "component": "Processing Records – Batch Job Governance",
    "difficulty": "Extreme",
    "question": "Why are Batch Jobs governed more strictly in enterprises?",
    "options": {
      "A": "Complex syntax",
      "B": "High impact on data consistency",
      "C": "Slower execution",
      "D": "Rare usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch Jobs can affect large data volumes.",
      "incorrect": {
        "A": "Syntax is manageable.",
        "C": "Performance varies.",
        "D": "They are common."
      }
    }
  },
  {
    "id": "EXP-MS-0619",
    "component": "Processing Records – For Each vs Batch Decision",
    "difficulty": "Extreme",
    "question": "Which factor most strongly favors Batch over For Each?",
    "options": {
      "A": "Simple logic",
      "B": "Need for restartability",
      "C": "Small datasets",
      "D": "Low latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restartability is a key Batch advantage.",
      "incorrect": {
        "A": "Logic simplicity irrelevant.",
        "C": "For Each suits small data.",
        "D": "Batch has higher latency."
      }
    }
  },
  {
    "id": "EXP-MS-0620",
    "component": "Processing Records – Domain Completion Marker",
    "difficulty": "Extreme",
    "question": "What demonstrates expert mastery of Processing Records?",
    "options": {
      "A": "Using all scopes",
      "B": "Choosing correct construct per reliability and volume requirement",
      "C": "Maximizing concurrency",
      "D": "Avoiding Batch Jobs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expertise is shown by correct design decisions.",
      "incorrect": {
        "A": "Usage alone insufficient.",
        "C": "Can be harmful.",
        "D": "Batch is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0621",
    "component": "Transforming Data – DataWeave Streaming Semantics",
    "difficulty": "Extreme",
    "question": "What happens when a streaming payload is fully materialized inside a DataWeave script?",
    "options": {
      "A": "The stream is rewound automatically",
      "B": "The stream becomes non-repeatable for downstream components",
      "C": "The payload remains streamable",
      "D": "An implicit cache is created"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Materializing consumes the stream, making it non-repeatable.",
      "incorrect": {
        "A": "Streams are not rewound automatically.",
        "C": "Materialization breaks streaming.",
        "D": "No implicit cache is created."
      }
    }
  },
  {
    "id": "EXP-MS-0622",
    "component": "Transforming Data – Output Directive Precedence",
    "difficulty": "Extreme",
    "question": "Which output directive takes precedence when multiple are defined?",
    "options": {
      "A": "Flow-level output",
      "B": "Component-level output",
      "C": "Script-level output",
      "D": "Global configuration"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The DataWeave script’s output directive has highest precedence.",
      "incorrect": {
        "A": "Lower precedence.",
        "B": "Overridden by script.",
        "D": "Not applicable."
      }
    }
  },
  {
    "id": "EXP-MS-0623",
    "component": "Transforming Data – Type Coercion Failure",
    "difficulty": "Extreme",
    "question": "What happens when DataWeave cannot coerce a value to the target type?",
    "options": {
      "A": "Returns null",
      "B": "Throws a runtime error",
      "C": "Keeps original type",
      "D": "Logs a warning and continues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Invalid coercion results in a runtime error.",
      "incorrect": {
        "A": "Null is not returned implicitly.",
        "C": "Type is not preserved.",
        "D": "No automatic warning-only behavior."
      }
    }
  },
  {
    "id": "EXP-MS-0624",
    "component": "Transforming Data – Order of Operations",
    "difficulty": "Extreme",
    "question": "In a chained DataWeave expression, how are functions applied?",
    "options": {
      "A": "Left-to-right",
      "B": "Right-to-left",
      "C": "By precedence rules only",
      "D": "Randomly"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Chained expressions are evaluated left-to-right.",
      "incorrect": {
        "B": "Not right-to-left.",
        "C": "Precedence applies within expressions.",
        "D": "Evaluation is deterministic."
      }
    }
  },
  {
    "id": "EXP-MS-0625",
    "component": "Transforming Data – Lazy Evaluation",
    "difficulty": "Extreme",
    "question": "Which DataWeave construct benefits most from lazy evaluation?",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "sizeOf",
      "D": "flatten"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "filter can short-circuit evaluation when combined with streaming.",
      "incorrect": {
        "A": "map evaluates all elements.",
        "C": "Requires full evaluation.",
        "D": "Materializes data."
      }
    }
  },

  {
    "id": "EXP-MS-0626",
    "component": "Transforming Data – Calling Flows from DataWeave",
    "difficulty": "Extreme",
    "question": "What is the primary risk of calling a Mule flow from DataWeave?",
    "options": {
      "A": "Compilation failure",
      "B": "Blocking execution and performance impact",
      "C": "Schema mismatch",
      "D": "Loss of attributes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flow calls from DW are synchronous and blocking.",
      "incorrect": {
        "A": "Valid syntax.",
        "C": "Not inherent.",
        "D": "Attributes remain accessible."
      }
    }
  },
  {
    "id": "EXP-MS-0627",
    "component": "Transforming Data – Module Reuse",
    "difficulty": "Extreme",
    "question": "Why should common DataWeave functions be placed in modules?",
    "options": {
      "A": "Performance optimization",
      "B": "Improved reuse and consistency",
      "C": "Automatic caching",
      "D": "Error isolation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modules promote reuse and consistent logic.",
      "incorrect": {
        "A": "Performance impact is minimal.",
        "C": "No automatic caching.",
        "D": "Errors still propagate."
      }
    }
  },
  {
    "id": "EXP-MS-0628",
    "component": "Transforming Data – Variable Scope in DataWeave",
    "difficulty": "Extreme",
    "question": "How are variables defined with var scoped in DataWeave?",
    "options": {
      "A": "Globally",
      "B": "Per function",
      "C": "Lexically within the script",
      "D": "Across flows"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Variables are lexically scoped within the script.",
      "incorrect": {
        "A": "Not global.",
        "B": "Not function-only.",
        "D": "Not shared across flows."
      }
    }
  },
  {
    "id": "EXP-MS-0629",
    "component": "Transforming Data – Sorting Stability",
    "difficulty": "Extreme",
    "question": "What guarantees does DataWeave sort provide?",
    "options": {
      "A": "Stable sort",
      "B": "Unstable sort",
      "C": "Random order",
      "D": "Insertion order preserved"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "DataWeave sort is stable.",
      "incorrect": {
        "B": "Incorrect.",
        "C": "Not random.",
        "D": "Order changes based on sort key."
      }
    }
  },
  {
    "id": "EXP-MS-0630",
    "component": "Transforming Data – Coercion vs Casting",
    "difficulty": "Extreme",
    "question": "What is the difference between coercion and casting in DataWeave?",
    "options": {
      "A": "They are identical",
      "B": "Casting forces conversion, coercion attempts safe conversion",
      "C": "Coercion is compile-time only",
      "D": "Casting is implicit"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Coercion attempts safe conversion; casting forces it.",
      "incorrect": {
        "A": "They differ.",
        "C": "Coercion is runtime.",
        "D": "Casting is explicit."
      }
    }
  },

  {
    "id": "EXP-MS-0631",
    "component": "Transforming Data – Memory Hotspot",
    "difficulty": "Extreme",
    "question": "Which DataWeave operation most commonly causes memory spikes?",
    "options": {
      "A": "Streaming filter",
      "B": "Materializing large collections",
      "C": "Simple map",
      "D": "Type checking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Materialization loads entire datasets into memory.",
      "incorrect": {
        "A": "Streaming reduces memory.",
        "C": "Map alone is not the main cause.",
        "D": "Negligible impact."
      }
    }
  },
  {
    "id": "EXP-MS-0632",
    "component": "Transforming Data – Output Media Type Mismatch",
    "difficulty": "Extreme",
    "question": "What happens if the declared output media type does not match the produced structure?",
    "options": {
      "A": "Implicit correction",
      "B": "Runtime error",
      "C": "Silent conversion",
      "D": "Payload is dropped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mismatch results in runtime serialization error.",
      "incorrect": {
        "A": "No implicit correction.",
        "C": "Not silent.",
        "D": "Payload is not dropped."
      }
    }
  },
  {
    "id": "EXP-MS-0633",
    "component": "Transforming Data – Namespace Resolution",
    "difficulty": "Extreme",
    "question": "How are naming conflicts resolved when importing multiple DataWeave modules?",
    "options": {
      "A": "Last import wins",
      "B": "Alphabetical order",
      "C": "Explicit namespace qualification required",
      "D": "Runtime resolution"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Conflicts require explicit namespace usage.",
      "incorrect": {
        "A": "No implicit override.",
        "B": "Order irrelevant.",
        "D": "Resolved at compile time."
      }
    }
  },
  {
    "id": "EXP-MS-0634",
    "component": "Transforming Data – Error Propagation from DataWeave",
    "difficulty": "Extreme",
    "question": "How do DataWeave errors propagate by default?",
    "options": {
      "A": "Swallowed silently",
      "B": "Returned as null",
      "C": "Propagated as Mule errors",
      "D": "Logged only"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "DW errors propagate as Mule errors.",
      "incorrect": {
        "A": "Not swallowed.",
        "B": "Null not returned.",
        "D": "Not log-only."
      }
    }
  },
  {
    "id": "EXP-MS-0635",
    "component": "Transforming Data – Conditional Mapping Cost",
    "difficulty": "Extreme",
    "question": "What is the performance impact of deeply nested conditional mappings?",
    "options": {
      "A": "No impact",
      "B": "Increased CPU cost",
      "C": "Increased IO",
      "D": "Automatic optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Nested conditionals increase evaluation cost.",
      "incorrect": {
        "A": "There is impact.",
        "C": "No IO involved.",
        "D": "No automatic optimization."
      }
    }
  },
  {
    "id": "EXP-MS-0636",
    "component": "Transforming Data – Streaming vs Repeatable Streams",
    "difficulty": "Extreme",
    "question": "Which DataWeave action converts a streaming payload into a repeatable in-memory structure?",
    "options": {
      "A": "filter",
      "B": "map",
      "C": "toArray()",
      "D": "pluck"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "toArray() materializes the stream into memory, making it repeatable.",
      "incorrect": {
        "A": "filter can remain streaming.",
        "B": "map can remain streaming.",
        "D": "pluck does not guarantee materialization."
      }
    }
  },
  {
    "id": "EXP-MS-0637",
    "component": "Transforming Data – Implicit Type Inference",
    "difficulty": "Extreme",
    "question": "When does DataWeave rely on implicit type inference?",
    "options": {
      "A": "Only with explicit casts",
      "B": "When output directive is omitted",
      "C": "Never",
      "D": "Only in modules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without an output directive, DataWeave infers types based on expressions.",
      "incorrect": {
        "A": "Casts are explicit.",
        "C": "Inference is common.",
        "D": "Modules do not restrict inference."
      }
    }
  },
  {
    "id": "EXP-MS-0638",
    "component": "Transforming Data – map vs pluck Semantics",
    "difficulty": "Extreme",
    "question": "What is the key semantic difference between map and pluck when applied to objects?",
    "options": {
      "A": "map preserves keys, pluck discards them",
      "B": "pluck provides access to both key and value",
      "C": "map is lazy, pluck is eager",
      "D": "pluck changes ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "pluck exposes both key and value during iteration.",
      "incorrect": {
        "A": "map over objects does not preserve keys by default.",
        "C": "Both can be lazy with streaming.",
        "D": "Ordering is preserved unless sorted."
      }
    }
  },
  {
    "id": "EXP-MS-0639",
    "component": "Transforming Data – Numeric Precision",
    "difficulty": "Extreme",
    "question": "How does DataWeave handle large numeric precision by default?",
    "options": {
      "A": "IEEE double only",
      "B": "Arbitrary precision",
      "C": "String-based numbers",
      "D": "Integer-only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave supports arbitrary precision numbers.",
      "incorrect": {
        "A": "Not limited to IEEE doubles.",
        "C": "Numbers are not strings.",
        "D": "Not integer-only."
      }
    }
  },
  {
    "id": "EXP-MS-0640",
    "component": "Transforming Data – DateTime Zone Normalization",
    "difficulty": "Extreme",
    "question": "What happens when a DateTime is coerced without timezone information?",
    "options": {
      "A": "UTC is assumed",
      "B": "System default timezone is applied",
      "C": "Conversion fails",
      "D": "Timezone is ignored permanently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System default timezone is applied if none is specified.",
      "incorrect": {
        "A": "UTC is not assumed automatically.",
        "C": "Conversion succeeds.",
        "D": "Timezone can be added later."
      }
    }
  },

  {
    "id": "EXP-MS-0641",
    "component": "Transforming Data – filter vs find",
    "difficulty": "Extreme",
    "question": "Why is find often more efficient than filter for existence checks?",
    "options": {
      "A": "find is parallel",
      "B": "find short-circuits on first match",
      "C": "filter uses more memory by design",
      "D": "find is compiled differently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "find stops evaluation after the first match.",
      "incorrect": {
        "A": "No implicit parallelism.",
        "C": "filter may remain streaming.",
        "D": "Compilation is similar."
      }
    }
  },
  {
    "id": "EXP-MS-0642",
    "component": "Transforming Data – update Operator Side Effects",
    "difficulty": "Extreme",
    "question": "What is a key property of the update operator in DataWeave?",
    "options": {
      "A": "It mutates the original object",
      "B": "It returns a new modified structure",
      "C": "It updates variables in place",
      "D": "It modifies payload globally"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "update is immutable and returns a new structure.",
      "incorrect": {
        "A": "No mutation occurs.",
        "C": "Variables are not mutated.",
        "D": "Scope is local to expression."
      }
    }
  },
  {
    "id": "EXP-MS-0643",
    "component": "Transforming Data – Pattern Matching Cost",
    "difficulty": "Extreme",
    "question": "What is the primary cost of extensive pattern matching in DataWeave?",
    "options": {
      "A": "Memory leaks",
      "B": "Increased CPU usage",
      "C": "Schema corruption",
      "D": "IO blocking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pattern matching evaluates multiple branches, increasing CPU cost.",
      "incorrect": {
        "A": "No inherent leaks.",
        "C": "Schema remains intact.",
        "D": "No IO involved."
      }
    }
  },
  {
    "id": "EXP-MS-0644",
    "component": "Transforming Data – keysOf Evaluation",
    "difficulty": "Extreme",
    "question": "What is the impact of calling keysOf on a large object?",
    "options": {
      "A": "Streaming iteration",
      "B": "Full materialization of keys",
      "C": "Constant-time lookup",
      "D": "Lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "keysOf requires enumerating all keys.",
      "incorrect": {
        "A": "Not streaming.",
        "C": "Not constant time.",
        "D": "Not lazy."
      }
    }
  },
  {
    "id": "EXP-MS-0645",
    "component": "Transforming Data – reduce Initial Value",
    "difficulty": "Extreme",
    "question": "Why is providing an initial value to reduce important?",
    "options": {
      "A": "Improves performance",
      "B": "Avoids errors on empty collections",
      "C": "Forces type casting",
      "D": "Enables parallelism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without an initial value, reduce fails on empty inputs.",
      "incorrect": {
        "A": "Performance impact is secondary.",
        "C": "Casting is unrelated.",
        "D": "No parallelism."
      }
    }
  },

  {
    "id": "EXP-MS-0646",
    "component": "Transforming Data – flatten Materialization",
    "difficulty": "Extreme",
    "question": "Why can flatten be dangerous with deeply nested collections?",
    "options": {
      "A": "Syntax errors",
      "B": "Excessive memory usage",
      "C": "Loss of type information",
      "D": "Ordering corruption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flatten materializes nested structures into memory.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Types are preserved.",
        "D": "Order is preserved."
      }
    }
  },
  {
    "id": "EXP-MS-0647",
    "component": "Transforming Data – Object Merge Precedence",
    "difficulty": "Extreme",
    "question": "When merging two objects, which value wins on key conflict?",
    "options": {
      "A": "Left operand",
      "B": "Right operand",
      "C": "Random",
      "D": "Throws error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Right-hand object values override left-hand ones.",
      "incorrect": {
        "A": "Overridden.",
        "C": "Deterministic behavior.",
        "D": "No error thrown."
      }
    }
  },
  {
    "id": "EXP-MS-0648",
    "component": "Transforming Data – contains vs indexOf",
    "difficulty": "Extreme",
    "question": "Why is contains preferred over indexOf for membership checks?",
    "options": {
      "A": "Lower memory usage",
      "B": "Clearer semantics and boolean result",
      "C": "Faster execution always",
      "D": "Lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "contains directly expresses intent and returns boolean.",
      "incorrect": {
        "A": "Memory usage is similar.",
        "C": "Performance varies.",
        "D": "Both may evaluate eagerly."
      }
    }
  },
  {
    "id": "EXP-MS-0649",
    "component": "Transforming Data – mapObject Ordering",
    "difficulty": "Extreme",
    "question": "What happens to key order when using mapObject?",
    "options": {
      "A": "Order is randomized",
      "B": "Original order is preserved",
      "C": "Sorted alphabetically",
      "D": "Order is lost"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mapObject preserves insertion order.",
      "incorrect": {
        "A": "Not random.",
        "C": "No implicit sort.",
        "D": "Order is preserved."
      }
    }
  },
  {
    "id": "EXP-MS-0650",
    "component": "Transforming Data – Output Encoding Errors",
    "difficulty": "Extreme",
    "question": "What causes output encoding errors in DataWeave?",
    "options": {
      "A": "Invalid characters for target charset",
      "B": "Large payload size",
      "C": "Streaming input",
      "D": "Missing output directive"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Characters unsupported by the target charset cause encoding errors.",
      "incorrect": {
        "B": "Size alone does not cause encoding errors.",
        "C": "Streaming is unrelated.",
        "D": "Directive omission affects type inference."
      }
    }
  },

  {
    "id": "EXP-MS-0651",
    "component": "Transforming Data – Boolean Short-Circuiting",
    "difficulty": "Extreme",
    "question": "Which operator benefits from short-circuit evaluation?",
    "options": {
      "A": "and",
      "B": "++",
      "C": "as",
      "D": "map"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Logical and short-circuits on false.",
      "incorrect": {
        "B": "Concatenation evaluates both sides.",
        "C": "Casting always evaluates.",
        "D": "map evaluates elements."
      }
    }
  },
  {
    "id": "EXP-MS-0652",
    "component": "Transforming Data – sizeOf on Streams",
    "difficulty": "Extreme",
    "question": "What is the effect of calling sizeOf on a streaming payload?",
    "options": {
      "A": "Constant-time evaluation",
      "B": "Consumes the entire stream",
      "C": "Returns -1",
      "D": "Fails compilation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf must consume the stream to count elements.",
      "incorrect": {
        "A": "Not constant-time.",
        "C": "No such behavior.",
        "D": "Compiles successfully."
      }
    }
  },
  {
    "id": "EXP-MS-0653",
    "component": "Transforming Data – with Operator Scope",
    "difficulty": "Extreme",
    "question": "What does the with operator provide in DataWeave?",
    "options": {
      "A": "Mutation of existing object",
      "B": "Temporary scope for expression evaluation",
      "C": "Global variable injection",
      "D": "Parallel execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "with creates a temporary context for evaluation.",
      "incorrect": {
        "A": "No mutation.",
        "C": "Not global.",
        "D": "No parallelism."
      }
    }
  },
  {
    "id": "EXP-MS-0654",
    "component": "Transforming Data – Default Operator Evaluation",
    "difficulty": "Extreme",
    "question": "When does the default operator (default) evaluate its right-hand side?",
    "options": {
      "A": "Always",
      "B": "Only when left-hand side is null",
      "C": "Only when left-hand side is empty string",
      "D": "Never"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "default is evaluated only if the left-hand side is null.",
      "incorrect": {
        "A": "Not always.",
        "C": "Empty string is not null.",
        "D": "It does evaluate."
      }
    }
  },
  {
    "id": "EXP-MS-0655",
    "component": "Transforming Data – Memory Profiling Indicator",
    "difficulty": "Extreme",
    "question": "Which symptom most strongly indicates DataWeave memory pressure?",
    "options": {
      "A": "High CPU usage",
      "B": "Frequent garbage collection pauses",
      "C": "Slow network calls",
      "D": "Thread starvation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Frequent GC pauses signal heap pressure.",
      "incorrect": {
        "A": "CPU-bound issue.",
        "C": "IO-related.",
        "D": "Scheduler-related."
      }
    }
  },

  {
    "id": "EXP-MS-0656",
    "component": "Transforming Data – Null vs Absent Fields",
    "difficulty": "Extreme",
    "question": "How does DataWeave treat absent fields compared to fields with null values?",
    "options": {
      "A": "They are identical",
      "B": "Absent fields are omitted, null fields are present",
      "C": "Null fields are removed automatically",
      "D": "Absent fields cause errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Absent fields are omitted, null fields exist with null value.",
      "incorrect": {
        "A": "They differ.",
        "C": "Null fields remain unless filtered.",
        "D": "No error."
      }
    }
  },
  {
    "id": "EXP-MS-0657",
    "component": "Transforming Data – Dynamic Key Generation",
    "difficulty": "Extreme",
    "question": "What is the cost of generating dynamic object keys in DataWeave?",
    "options": {
      "A": "Compile-time error",
      "B": "Increased runtime computation",
      "C": "Schema invalidation",
      "D": "Automatic caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic key evaluation adds runtime computation.",
      "incorrect": {
        "A": "Valid syntax.",
        "C": "Schema remains valid.",
        "D": "No caching."
      }
    }
  },
  {
    "id": "EXP-MS-0658",
    "component": "Transforming Data – Error Localization",
    "difficulty": "Extreme",
    "question": "Which practice best improves DataWeave error localization?",
    "options": {
      "A": "Monolithic scripts",
      "B": "Small reusable functions",
      "C": "Implicit type inference",
      "D": "Dynamic expressions everywhere"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller functions isolate failures.",
      "incorrect": {
        "A": "Harder to debug.",
        "C": "Does not aid localization.",
        "D": "Increases complexity."
      }
    }
  },
  {
    "id": "EXP-MS-0659",
    "component": "Transforming Data – Streaming Safe Functions",
    "difficulty": "Extreme",
    "question": "Which function is safest to use with streaming data?",
    "options": {
      "A": "sizeOf",
      "B": "toArray",
      "C": "filter",
      "D": "flatten"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "filter can operate without materializing the entire stream.",
      "incorrect": {
        "A": "Consumes stream fully.",
        "B": "Materializes data.",
        "D": "Materializes nested data."
      }
    }
  },
  {
    "id": "EXP-MS-0660",
    "component": "Transforming Data – Section Continuation Marker",
    "difficulty": "Extreme",
    "question": "What is the primary indicator of expert-level DataWeave usage?",
    "options": {
      "A": "Complex expressions",
      "B": "Correct streaming, memory, and type decisions",
      "C": "Maximum function usage",
      "D": "Minimal code length"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert usage balances correctness, performance, and memory safety.",
      "incorrect": {
        "A": "Complexity alone is not expertise.",
        "C": "Quantity is irrelevant.",
        "D": "Brevity alone is insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0661",
    "component": "Transforming Data – groupBy Materialization",
    "difficulty": "Extreme",
    "question": "What is the primary impact of using groupBy on a large streaming collection?",
    "options": {
      "A": "Lazy grouping",
      "B": "Full materialization in memory",
      "C": "Partial streaming",
      "D": "Parallel grouping"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "groupBy must see all elements to build groups, forcing materialization.",
      "incorrect": {
        "A": "Grouping is not lazy.",
        "C": "Streaming is lost.",
        "D": "No implicit parallelism."
      }
    }
  },
  {
    "id": "EXP-MS-0662",
    "component": "Transforming Data – distinctBy Key Cost",
    "difficulty": "Extreme",
    "question": "Why can distinctBy be expensive on large datasets?",
    "options": {
      "A": "Repeated sorting",
      "B": "Maintaining a seen-key set in memory",
      "C": "Network calls",
      "D": "Schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "distinctBy tracks seen keys, increasing memory usage.",
      "incorrect": {
        "A": "Sorting is not required.",
        "C": "No network calls.",
        "D": "Schema validation is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0663",
    "component": "Transforming Data – orderBy Stability vs Cost",
    "difficulty": "Extreme",
    "question": "What tradeoff does orderBy introduce compared to simple iteration?",
    "options": {
      "A": "Lower CPU usage",
      "B": "Stable ordering at the cost of full materialization",
      "C": "Streaming with ordering",
      "D": "Automatic pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ordering requires materializing the collection to sort.",
      "incorrect": {
        "A": "CPU usage increases.",
        "C": "Streaming is lost.",
        "D": "No pagination."
      }
    }
  },
  {
    "id": "EXP-MS-0664",
    "component": "Transforming Data – flatMap Expansion Risk",
    "difficulty": "Extreme",
    "question": "What is a key risk when using flatMap on nested collections?",
    "options": {
      "A": "Compilation failure",
      "B": "Exponential growth of result size",
      "C": "Loss of keys",
      "D": "Type inference failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flatMap can significantly expand result size.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Keys are handled per expression.",
        "D": "Type inference remains intact."
      }
    }
  },
  {
    "id": "EXP-MS-0665",
    "component": "Transforming Data – mapObject Key Mutation",
    "difficulty": "Extreme",
    "question": "What happens if mapObject generates duplicate keys?",
    "options": {
      "A": "Compilation error",
      "B": "First key wins",
      "C": "Last key wins",
      "D": "Runtime error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Later entries overwrite earlier ones.",
      "incorrect": {
        "A": "No compile error.",
        "B": "Earlier keys are overwritten.",
        "D": "No runtime error."
      }
    }
  },

  {
    "id": "EXP-MS-0666",
    "component": "Transforming Data – find vs filter Memory",
    "difficulty": "Extreme",
    "question": "Why is find more memory-efficient than filter when searching?",
    "options": {
      "A": "find is parallel",
      "B": "find stops after first match",
      "C": "filter uses caching",
      "D": "filter always materializes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "find short-circuits evaluation.",
      "incorrect": {
        "A": "No parallelism.",
        "C": "No caching.",
        "D": "filter may stream."
      }
    }
  },
  {
    "id": "EXP-MS-0667",
    "component": "Transforming Data – zip Function Pitfall",
    "difficulty": "Extreme",
    "question": "What happens when zip is applied to collections of unequal length?",
    "options": {
      "A": "Error is thrown",
      "B": "Shorter collection length is used",
      "C": "Longer collection is padded",
      "D": "Result is empty"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "zip truncates to the shortest collection.",
      "incorrect": {
        "A": "No error.",
        "C": "No padding.",
        "D": "Result is not empty."
      }
    }
  },
  {
    "id": "EXP-MS-0668",
    "component": "Transforming Data – scan Accumulator Growth",
    "difficulty": "Extreme",
    "question": "Why can scan cause memory pressure?",
    "options": {
      "A": "It mutates input",
      "B": "It stores intermediate accumulator states",
      "C": "It forces sorting",
      "D": "It disables streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "scan emits all intermediate results.",
      "incorrect": {
        "A": "No mutation.",
        "C": "No sorting.",
        "D": "Streaming may still occur."
      }
    }
  },
  {
    "id": "EXP-MS-0669",
    "component": "Transforming Data – join Key Cardinality",
    "difficulty": "Extreme",
    "question": "What primarily drives the cost of join operations in DataWeave?",
    "options": {
      "A": "Output format",
      "B": "Key cardinality and data size",
      "C": "Function nesting",
      "D": "Variable scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High cardinality and size increase join complexity.",
      "incorrect": {
        "A": "Format is secondary.",
        "C": "Nesting is secondary.",
        "D": "Scope is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0670",
    "component": "Transforming Data – join Streaming Limitation",
    "difficulty": "Extreme",
    "question": "Why do joins typically break streaming?",
    "options": {
      "A": "They require network calls",
      "B": "They need both sides fully available",
      "C": "They require sorting",
      "D": "They enforce type casting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Both datasets must be available to match keys.",
      "incorrect": {
        "A": "No network calls.",
        "C": "Sorting is optional.",
        "D": "Casting is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0671",
    "component": "Transforming Data – every vs some Evaluation",
    "difficulty": "Extreme",
    "question": "Which operator can short-circuit on the first false result?",
    "options": {
      "A": "some",
      "B": "every",
      "C": "map",
      "D": "reduce"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "every stops when a false condition is found.",
      "incorrect": {
        "A": "some stops on true.",
        "C": "map evaluates all.",
        "D": "reduce evaluates all."
      }
    }
  },
  {
    "id": "EXP-MS-0672",
    "component": "Transforming Data – pluck Object Loss",
    "difficulty": "Extreme",
    "question": "What structural change does pluck introduce when applied to objects?",
    "options": {
      "A": "Preserves object shape",
      "B": "Converts object to array",
      "C": "Flattens nested objects",
      "D": "Removes null values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "pluck outputs an array, not an object.",
      "incorrect": {
        "A": "Shape changes.",
        "C": "No flattening.",
        "D": "Null handling is separate."
      }
    }
  },
  {
    "id": "EXP-MS-0673",
    "component": "Transforming Data – ++ Operator Memory",
    "difficulty": "Extreme",
    "question": "Why can excessive use of ++ be costly?",
    "options": {
      "A": "Syntax overhead",
      "B": "Repeated allocation of new collections",
      "C": "Loss of ordering",
      "D": "Implicit sorting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "++ creates new collections each time.",
      "incorrect": {
        "A": "Syntax is negligible.",
        "C": "Ordering is preserved.",
        "D": "No sorting occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0674",
    "component": "Transforming Data – substring Bounds",
    "difficulty": "Extreme",
    "question": "What happens if substring indices are out of bounds?",
    "options": {
      "A": "Empty string returned",
      "B": "Indices are clamped",
      "C": "Runtime error",
      "D": "Original string returned"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Out-of-bounds indices cause runtime errors.",
      "incorrect": {
        "A": "Not returned.",
        "B": "No clamping.",
        "D": "String is not returned unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0675",
    "component": "Transforming Data – split Materialization",
    "difficulty": "Extreme",
    "question": "What is the memory implication of split on large strings?",
    "options": {
      "A": "Streaming split",
      "B": "Full allocation of substrings",
      "C": "Constant memory",
      "D": "Lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "split allocates all substrings in memory.",
      "incorrect": {
        "A": "Not streaming.",
        "C": "Memory grows with size.",
        "D": "Not lazy."
      }
    }
  },

  {
    "id": "EXP-MS-0676",
    "component": "Transforming Data – trim Unicode Cost",
    "difficulty": "Extreme",
    "question": "Why can trim be more expensive with Unicode strings?",
    "options": {
      "A": "Extra IO",
      "B": "Complex character classification",
      "C": "Implicit sorting",
      "D": "Encoding conversion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unicode whitespace classification is more complex.",
      "incorrect": {
        "A": "No IO.",
        "C": "No sorting.",
        "D": "Encoding remains the same."
      }
    }
  },
  {
    "id": "EXP-MS-0677",
    "component": "Transforming Data – matches Regex Backtracking",
    "difficulty": "Extreme",
    "question": "What is the main risk of poorly designed regex in matches?",
    "options": {
      "A": "Compilation failure",
      "B": "Catastrophic backtracking",
      "C": "Schema loss",
      "D": "Incorrect output type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Poor regex can cause exponential backtracking.",
      "incorrect": {
        "A": "Regex compiles.",
        "C": "Schema unaffected.",
        "D": "Type remains boolean."
      }
    }
  },
  {
    "id": "EXP-MS-0678",
    "component": "Transforming Data – replaceAll Global Cost",
    "difficulty": "Extreme",
    "question": "Why can replaceAll be costly on large strings?",
    "options": {
      "A": "Repeated scanning of entire string",
      "B": "Implicit recursion",
      "C": "Sorting overhead",
      "D": "Type coercion"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "replaceAll scans the entire string for matches.",
      "incorrect": {
        "B": "No recursion.",
        "C": "No sorting.",
        "D": "No coercion."
      }
    }
  },
  {
    "id": "EXP-MS-0679",
    "component": "Transforming Data – toNumber Failure Mode",
    "difficulty": "Extreme",
    "question": "What happens when toNumber receives a non-numeric string?",
    "options": {
      "A": "Returns 0",
      "B": "Returns null",
      "C": "Throws runtime error",
      "D": "Returns NaN"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Invalid conversion throws a runtime error.",
      "incorrect": {
        "A": "Not default.",
        "B": "Not returned.",
        "D": "NaN is not used."
      }
    }
  },
  {
    "id": "EXP-MS-0680",
    "component": "Transforming Data – typeOf Debugging Use",
    "difficulty": "Extreme",
    "question": "Why is typeOf useful in complex transformations?",
    "options": {
      "A": "Performance optimization",
      "B": "Runtime introspection for debugging",
      "C": "Schema enforcement",
      "D": "Implicit casting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "typeOf helps inspect runtime types during debugging.",
      "incorrect": {
        "A": "No optimization.",
        "C": "No enforcement.",
        "D": "No casting."
      }
    }
  },

  {
    "id": "EXP-MS-0681",
    "component": "Transforming Data – isEmpty Semantics",
    "difficulty": "Extreme",
    "question": "What does isEmpty return for null?",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "Depends on type"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "isEmpty(null) returns true.",
      "incorrect": {
        "B": "Incorrect.",
        "C": "No error.",
        "D": "Defined behavior."
      }
    }
  },
  {
    "id": "EXP-MS-0682",
    "component": "Transforming Data – sizeOf Object Cost",
    "difficulty": "Extreme",
    "question": "What does sizeOf return for an object?",
    "options": {
      "A": "Total byte size",
      "B": "Number of keys",
      "C": "Number of values",
      "D": "Always 1"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf(object) returns the number of keys.",
      "incorrect": {
        "A": "Not byte size.",
        "C": "Keys define size.",
        "D": "Not constant."
      }
    }
  },
  {
    "id": "EXP-MS-0683",
    "component": "Transforming Data – as Operator Failure",
    "difficulty": "Extreme",
    "question": "What happens if an as cast is incompatible?",
    "options": {
      "A": "Implicit coercion",
      "B": "Returns null",
      "C": "Runtime error",
      "D": "Ignored"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Incompatible casts throw runtime errors.",
      "incorrect": {
        "A": "No implicit coercion.",
        "B": "Null not returned.",
        "D": "Not ignored."
      }
    }
  },
  {
    "id": "EXP-MS-0684",
    "component": "Transforming Data – Default vs ifElse Cost",
    "difficulty": "Extreme",
    "question": "Why is default often cheaper than if-else?",
    "options": {
      "A": "Compile-time optimization",
      "B": "Right-hand side evaluated conditionally",
      "C": "Parallel execution",
      "D": "Type inference"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "default evaluates RHS only if needed.",
      "incorrect": {
        "A": "No compile-time optimization.",
        "C": "No parallelism.",
        "D": "Inference unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0685",
    "component": "Transforming Data – Memory Leak Anti-Pattern",
    "difficulty": "Extreme",
    "question": "Which DataWeave pattern risks unbounded memory growth?",
    "options": {
      "A": "Streaming filter",
      "B": "Accumulating results in a reduce without limits",
      "C": "Simple map",
      "D": "find"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unbounded accumulation grows memory usage.",
      "incorrect": {
        "A": "Streaming-safe.",
        "C": "Bounded.",
        "D": "Short-circuits."
      }
    }
  },

  {
    "id": "EXP-MS-0686",
    "component": "Transforming Data – from Object to XML",
    "difficulty": "Extreme",
    "question": "What is required to generate attributes in XML output?",
    "options": {
      "A": "Special function",
      "B": "@ attribute notation",
      "C": "Namespace declaration",
      "D": "CDATA section"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "XML attributes are defined using @ notation.",
      "incorrect": {
        "A": "No function required.",
        "C": "Namespace is optional.",
        "D": "CDATA is content-only."
      }
    }
  },
  {
    "id": "EXP-MS-0687",
    "component": "Transforming Data – XML Namespace Collision",
    "difficulty": "Extreme",
    "question": "How are XML namespace collisions avoided in DataWeave?",
    "options": {
      "A": "Automatic renaming",
      "B": "Explicit namespace prefixes",
      "C": "Ignoring namespaces",
      "D": "Runtime resolution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit prefixes disambiguate namespaces.",
      "incorrect": {
        "A": "No automatic renaming.",
        "C": "Namespaces are respected.",
        "D": "Resolved at compile time."
      }
    }
  },
  {
    "id": "EXP-MS-0688",
    "component": "Transforming Data – CSV Quoting Pitfall",
    "difficulty": "Extreme",
    "question": "What causes CSV generation to fail unexpectedly?",
    "options": {
      "A": "Large dataset",
      "B": "Unescaped delimiter characters",
      "C": "Streaming input",
      "D": "Missing headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Delimiters must be properly escaped or quoted.",
      "incorrect": {
        "A": "Size alone is fine.",
        "C": "Streaming is supported.",
        "D": "Headers are optional."
      }
    }
  },
  {
    "id": "EXP-MS-0689",
    "component": "Transforming Data – JSON Null Serialization",
    "difficulty": "Extreme",
    "question": "How does DataWeave serialize null values in JSON by default?",
    "options": {
      "A": "Omitted",
      "B": "Serialized as null",
      "C": "Empty string",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Null values are serialized as null.",
      "incorrect": {
        "A": "Absent fields are omitted.",
        "C": "Empty string is different.",
        "D": "No error."
      }
    }
  },
  {
    "id": "EXP-MS-0690",
    "component": "Transforming Data – Media Type Influence",
    "difficulty": "Extreme",
    "question": "Why does output media type affect DataWeave behavior?",
    "options": {
      "A": "Controls connector selection",
      "B": "Determines serialization rules",
      "C": "Changes function semantics",
      "D": "Affects variable scope"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Media type defines how data is serialized.",
      "incorrect": {
        "A": "Connectors are separate.",
        "C": "Functions remain same.",
        "D": "Scope unaffected."
      }
    }
  },

  {
    "id": "EXP-MS-0691",
    "component": "Transforming Data – Binary Data Handling",
    "difficulty": "Extreme",
    "question": "How should binary data be handled in DataWeave?",
    "options": {
      "A": "As strings",
      "B": "As Binary type",
      "C": "As Base64 always",
      "D": "As arrays of numbers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Binary data should use the Binary type.",
      "incorrect": {
        "A": "Strings corrupt binary.",
        "C": "Base64 is optional.",
        "D": "Inefficient."
      }
    }
  },
  {
    "id": "EXP-MS-0692",
    "component": "Transforming Data – read Function Cost",
    "difficulty": "Extreme",
    "question": "What is a key cost of using read() in DataWeave?",
    "options": {
      "A": "Compilation delay",
      "B": "Parsing and materialization",
      "C": "Network IO",
      "D": "Thread blocking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "read parses and materializes input.",
      "incorrect": {
        "A": "Negligible.",
        "C": "No network.",
        "D": "Parsing is CPU-bound."
      }
    }
  },
  {
    "id": "EXP-MS-0693",
    "component": "Transforming Data – write Function Pitfall",
    "difficulty": "Extreme",
    "question": "Why can excessive use of write() be problematic?",
    "options": {
      "A": "Compilation errors",
      "B": "Repeated serialization overhead",
      "C": "Loss of streaming",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "write serializes data, adding overhead each time.",
      "incorrect": {
        "A": "Valid syntax.",
        "C": "Serialization already materializes.",
        "D": "Schema unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0694",
    "component": "Transforming Data – Type Guards",
    "difficulty": "Extreme",
    "question": "How can type guards improve DataWeave robustness?",
    "options": {
      "A": "Improve performance",
      "B": "Prevent invalid operations on unexpected types",
      "C": "Enable parallelism",
      "D": "Reduce memory usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Type guards prevent invalid operations at runtime.",
      "incorrect": {
        "A": "Performance gain is secondary.",
        "C": "No parallelism.",
        "D": "Memory unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0695",
    "component": "Transforming Data – Tail Recursion",
    "difficulty": "Extreme",
    "question": "Why should recursion be used cautiously in DataWeave?",
    "options": {
      "A": "No recursion support",
      "B": "Risk of stack overflow",
      "C": "Compilation failure",
      "D": "Loss of type safety"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep recursion risks stack overflow.",
      "incorrect": {
        "A": "Recursion is supported.",
        "C": "Valid syntax.",
        "D": "Type safety remains."
      }
    }
  },

  {
    "id": "EXP-MS-0696",
    "component": "Transforming Data – Object vs Array Choice",
    "difficulty": "Extreme",
    "question": "When should objects be preferred over arrays?",
    "options": {
      "A": "When ordering matters",
      "B": "When key-based lookup is needed",
      "C": "When streaming is required",
      "D": "When size is unknown"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Objects allow efficient key-based access.",
      "incorrect": {
        "A": "Arrays preserve order.",
        "C": "Both can stream.",
        "D": "Both can handle unknown sizes."
      }
    }
  },
  {
    "id": "EXP-MS-0697",
    "component": "Transforming Data – Array Index Safety",
    "difficulty": "Extreme",
    "question": "What happens when accessing an out-of-range array index?",
    "options": {
      "A": "Returns null",
      "B": "Returns empty value",
      "C": "Throws runtime error",
      "D": "Wraps around"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Out-of-range access throws a runtime error.",
      "incorrect": {
        "A": "Not returned.",
        "B": "No empty value.",
        "D": "No wraparound."
      }
    }
  },
  {
    "id": "EXP-MS-0698",
    "component": "Transforming Data – Empty Object Serialization",
    "difficulty": "Extreme",
    "question": "How is an empty object serialized in JSON?",
    "options": {
      "A": "null",
      "B": "{}",
      "C": "[]",
      "D": "Omitted"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Empty object serializes as {}.",
      "incorrect": {
        "A": "Null is different.",
        "C": "Array syntax differs.",
        "D": "Not omitted."
      }
    }
  },
  {
    "id": "EXP-MS-0699",
    "component": "Transforming Data – Performance Profiling Focus",
    "difficulty": "Extreme",
    "question": "What should be profiled first when optimizing DataWeave?",
    "options": {
      "A": "Network latency",
      "B": "Materialization points",
      "C": "Variable naming",
      "D": "Output formatting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Materialization points drive memory and CPU cost.",
      "incorrect": {
        "A": "DW is in-memory.",
        "C": "Naming irrelevant.",
        "D": "Formatting is secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0700",
    "component": "Transforming Data – Domain Completion Marker",
    "difficulty": "Extreme",
    "question": "What defines expert-level mastery in Transforming Data?",
    "options": {
      "A": "Using every DataWeave function",
      "B": "Balancing correctness, performance, streaming, and memory",
      "C": "Shortest possible scripts",
      "D": "Avoiding advanced operators"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expertise lies in balanced, safe, and efficient transformations.",
      "incorrect": {
        "A": "Function count is irrelevant.",
        "C": "Brevity alone is not expertise.",
        "D": "Advanced operators are often necessary."
      }
    }
  },
  {
    "id": "EXP-MS-0701",
    "component": "Transforming Data – map vs for Comprehension",
    "difficulty": "Extreme",
    "question": "What is a key advantage of using for-comprehension over map in complex transformations?",
    "options": {
      "A": "Better streaming support",
      "B": "Ability to introduce multiple generators and guards",
      "C": "Lower memory usage always",
      "D": "Implicit parallel execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "for-comprehensions support multiple generators and conditional guards.",
      "incorrect": {
        "A": "Streaming behavior is similar.",
        "C": "Memory usage depends on logic.",
        "D": "No parallelism is implied."
      }
    }
  },
  {
    "id": "EXP-MS-0702",
    "component": "Transforming Data – Guard Conditions Cost",
    "difficulty": "Extreme",
    "question": "What is the primary cost of adding guard conditions in DataWeave comprehensions?",
    "options": {
      "A": "Compilation overhead",
      "B": "Additional predicate evaluations",
      "C": "Memory allocation",
      "D": "Schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each guard adds an extra boolean evaluation per element.",
      "incorrect": {
        "A": "Compile-time cost is negligible.",
        "C": "Memory impact is indirect.",
        "D": "Schema validation is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0703",
    "component": "Transforming Data – Inline Function Allocation",
    "difficulty": "Extreme",
    "question": "Why can excessive inline lambda usage degrade DataWeave performance?",
    "options": {
      "A": "Compilation failure",
      "B": "Repeated function allocation and invocation",
      "C": "Loss of streaming",
      "D": "Implicit recursion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each lambda adds allocation and invocation overhead.",
      "incorrect": {
        "A": "Syntax remains valid.",
        "C": "Streaming may still work.",
        "D": "No recursion implied."
      }
    }
  },
  {
    "id": "EXP-MS-0704",
    "component": "Transforming Data – Variable Shadowing",
    "difficulty": "Extreme",
    "question": "What is the risk of variable shadowing in nested DataWeave scopes?",
    "options": {
      "A": "Compilation error",
      "B": "Unexpected value resolution",
      "C": "Memory leak",
      "D": "Type inference failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inner scope variables can override outer ones unexpectedly.",
      "incorrect": {
        "A": "Shadowing is allowed.",
        "C": "No leak by itself.",
        "D": "Type inference still works."
      }
    }
  },
  {
    "id": "EXP-MS-0705",
    "component": "Transforming Data – Object Constructor Cost",
    "difficulty": "Extreme",
    "question": "Why can building large objects field-by-field be expensive?",
    "options": {
      "A": "Compilation delay",
      "B": "Repeated object allocation",
      "C": "Implicit sorting",
      "D": "Loss of streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each field addition creates new object instances.",
      "incorrect": {
        "A": "Compile-time cost is minor.",
        "C": "No sorting occurs.",
        "D": "Streaming is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0706",
    "component": "Transforming Data – Conditional Object Fields",
    "difficulty": "Extreme",
    "question": "What is the safest way to conditionally include object fields?",
    "options": {
      "A": "if-else blocks everywhere",
      "B": "default operator",
      "C": "Using if condition directly in field value",
      "D": "Post-filtering with mapObject"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Inline conditions avoid unnecessary object reconstruction.",
      "incorrect": {
        "A": "Verbose and costly.",
        "B": "default handles nulls, not presence.",
        "D": "Adds extra pass."
      }
    }
  },
  {
    "id": "EXP-MS-0707",
    "component": "Transforming Data – Empty Collection Semantics",
    "difficulty": "Extreme",
    "question": "How does DataWeave treat empty arrays in boolean contexts?",
    "options": {
      "A": "true",
      "B": "false",
      "C": "Error",
      "D": "Depends on media type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Empty collections evaluate to false in boolean context.",
      "incorrect": {
        "A": "Only non-empty are true.",
        "C": "No error is thrown.",
        "D": "Media type is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0708",
    "component": "Transforming Data – Object Equality Check",
    "difficulty": "Extreme",
    "question": "What does the == operator compare for objects in DataWeave?",
    "options": {
      "A": "Reference equality",
      "B": "Key-value structural equality",
      "C": "Key order only",
      "D": "Serialized string equality"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Objects are compared structurally by keys and values.",
      "incorrect": {
        "A": "Not reference-based.",
        "C": "Order does not matter.",
        "D": "Serialization is not used."
      }
    }
  },
  {
    "id": "EXP-MS-0709",
    "component": "Transforming Data – Array Equality Cost",
    "difficulty": "Extreme",
    "question": "Why can array equality checks be expensive?",
    "options": {
      "A": "They require sorting",
      "B": "Element-by-element comparison",
      "C": "Implicit casting",
      "D": "Memory duplication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each element must be compared sequentially.",
      "incorrect": {
        "A": "No sorting is done.",
        "C": "No casting implied.",
        "D": "No duplication."
      }
    }
  },
  {
    "id": "EXP-MS-0710",
    "component": "Transforming Data – Null Propagation",
    "difficulty": "Extreme",
    "question": "What happens when arithmetic is performed with null values?",
    "options": {
      "A": "Null is ignored",
      "B": "Null propagates causing runtime error",
      "C": "Null treated as zero",
      "D": "Operation is skipped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Arithmetic with null results in runtime error.",
      "incorrect": {
        "A": "Null is not ignored.",
        "C": "Null is not zero.",
        "D": "Operation is not skipped."
      }
    }
  },

  {
    "id": "EXP-MS-0711",
    "component": "Transforming Data – Default Operator Chaining",
    "difficulty": "Extreme",
    "question": "How does chaining multiple default operators behave?",
    "options": {
      "A": "All defaults evaluated",
      "B": "Evaluated left-to-right until non-null",
      "C": "Evaluated right-to-left",
      "D": "Only last default used"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Evaluation stops at the first non-null value.",
      "incorrect": {
        "A": "Not all evaluated.",
        "C": "Not right-to-left.",
        "D": "Earlier defaults matter."
      }
    }
  },
  {
    "id": "EXP-MS-0712",
    "component": "Transforming Data – Function Overloading Resolution",
    "difficulty": "Extreme",
    "question": "How does DataWeave resolve overloaded functions?",
    "options": {
      "A": "Runtime inspection",
      "B": "Compile-time type resolution",
      "C": "Random selection",
      "D": "Last-defined wins"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resolution is based on compile-time type information.",
      "incorrect": {
        "A": "Not runtime-based.",
        "C": "Deterministic behavior.",
        "D": "Order does not decide."
      }
    }
  },
  {
    "id": "EXP-MS-0713",
    "component": "Transforming Data – Error Message Localization",
    "difficulty": "Extreme",
    "question": "What practice improves readability of DataWeave error messages?",
    "options": {
      "A": "Inlining all logic",
      "B": "Breaking logic into named functions",
      "C": "Dynamic expressions",
      "D": "Suppressing errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Named functions provide clearer stack traces.",
      "incorrect": {
        "A": "Inlining obscures errors.",
        "C": "Dynamics increase ambiguity.",
        "D": "Errors should not be suppressed."
      }
    }
  },
  {
    "id": "EXP-MS-0714",
    "component": "Transforming Data – Payload Mutation Misconception",
    "difficulty": "Extreme",
    "question": "Why is DataWeave considered immutable?",
    "options": {
      "A": "Variables cannot be declared",
      "B": "All transformations return new values",
      "C": "Payload is locked",
      "D": "Only functional syntax allowed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave never mutates existing data structures.",
      "incorrect": {
        "A": "Variables are allowed.",
        "C": "Payload can be reassigned.",
        "D": "Syntax supports more than functional."
      }
    }
  },
  {
    "id": "EXP-MS-0715",
    "component": "Transforming Data – Large Object Debugging",
    "difficulty": "Extreme",
    "question": "What is the safest way to debug very large transformed payloads?",
    "options": {
      "A": "Log entire payload",
      "B": "Log selective fields or summaries",
      "C": "Convert to string",
      "D": "Disable logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Selective logging avoids memory and log overflow issues.",
      "incorrect": {
        "A": "Logging entire payload is risky.",
        "C": "String conversion is expensive.",
        "D": "Disables observability."
      }
    }
  },

  {
    "id": "EXP-MS-0716",
    "component": "Transforming Data – Boolean Context Pitfall",
    "difficulty": "Extreme",
    "question": "Which value evaluates to false in boolean context?",
    "options": {
      "A": "0",
      "B": "\"\"",
      "C": "[]",
      "D": "\"false\""
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Empty collections evaluate to false.",
      "incorrect": {
        "A": "0 is true.",
        "B": "Empty string is true.",
        "D": "Non-empty string is true."
      }
    }
  },
  {
    "id": "EXP-MS-0717",
    "component": "Transforming Data – Precision Loss Risk",
    "difficulty": "Extreme",
    "question": "When can numeric precision be lost in DataWeave?",
    "options": {
      "A": "Using BigDecimal",
      "B": "Casting to Number with external systems",
      "C": "Using integers",
      "D": "Using sizeOf"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External systems may not support arbitrary precision.",
      "incorrect": {
        "A": "BigDecimal preserves precision.",
        "C": "Integers are exact.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0718",
    "component": "Transforming Data – Readability vs Performance Tradeoff",
    "difficulty": "Extreme",
    "question": "Which tradeoff is common in DataWeave design?",
    "options": {
      "A": "Performance vs correctness",
      "B": "Readability vs performance",
      "C": "Streaming vs correctness",
      "D": "Type safety vs speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readable code may be slightly less performant but safer.",
      "incorrect": {
        "A": "Correctness is mandatory.",
        "C": "Streaming does not reduce correctness.",
        "D": "Type safety is not optional."
      }
    }
  },
  {
    "id": "EXP-MS-0719",
    "component": "Transforming Data – Large Dataset Strategy",
    "difficulty": "Extreme",
    "question": "What is the best strategy for transforming extremely large datasets?",
    "options": {
      "A": "Materialize everything",
      "B": "Use streaming-safe operations",
      "C": "Increase heap size only",
      "D": "Disable transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming-safe operations minimize memory usage.",
      "incorrect": {
        "A": "Materialization risks OOM.",
        "C": "Heap increase is insufficient.",
        "D": "Not viable."
      }
    }
  },
  {
    "id": "EXP-MS-0720",
    "component": "Transforming Data – Transforming Data Section Closure",
    "difficulty": "Extreme",
    "question": "What final principle defines mastery of DataWeave transformations?",
    "options": {
      "A": "Complex syntax usage",
      "B": "Correct balance of immutability, streaming, and performance",
      "C": "Minimal number of functions",
      "D": "Avoiding edge cases"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert DataWeave balances correctness, immutability, streaming, and performance.",
      "incorrect": {
        "A": "Complexity alone is not mastery.",
        "C": "Function count is irrelevant.",
        "D": "Edge cases must be handled."
      }
    }
  },
  {
    "id": "EXP-MS-0721",
    "component": "Routing Events – Choice Router Evaluation Order",
    "difficulty": "Extreme",
    "question": "How does the Choice router evaluate its when conditions?",
    "options": {
      "A": "All conditions in parallel",
      "B": "Random order",
      "C": "Sequentially top-to-bottom, first match wins",
      "D": "Based on priority attribute"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Choice evaluates conditions sequentially and routes to the first matching when.",
      "incorrect": {
        "A": "No parallel evaluation.",
        "B": "Order is deterministic.",
        "D": "No priority attribute exists."
      }
    }
  },
  {
    "id": "EXP-MS-0722",
    "component": "Routing Events – Choice Default Branch",
    "difficulty": "Extreme",
    "question": "When is the otherwise branch of a Choice router executed?",
    "options": {
      "A": "Always after when branches",
      "B": "Only if all when conditions evaluate to false",
      "C": "Only on errors",
      "D": "When payload is null"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "otherwise runs only if no when condition matches.",
      "incorrect": {
        "A": "Not always.",
        "C": "Errors are separate.",
        "D": "Null payload alone does not trigger it."
      }
    }
  },
  {
    "id": "EXP-MS-0723",
    "component": "Routing Events – DataWeave Condition Cost",
    "difficulty": "Extreme",
    "question": "What primarily determines the cost of Choice router conditions?",
    "options": {
      "A": "Number of branches",
      "B": "Complexity of DataWeave expressions",
      "C": "Payload size only",
      "D": "Media type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Complex DataWeave expressions increase evaluation cost.",
      "incorrect": {
        "A": "Branch count alone is insufficient.",
        "C": "Size is secondary.",
        "D": "Media type is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0724",
    "component": "Routing Events – Scatter-Gather Execution",
    "difficulty": "Extreme",
    "question": "How are routes executed in a Scatter-Gather?",
    "options": {
      "A": "Sequentially",
      "B": "Random order",
      "C": "In parallel",
      "D": "Based on payload"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Scatter-Gather executes all routes in parallel.",
      "incorrect": {
        "A": "Not sequential.",
        "B": "Order is deterministic.",
        "D": "Payload does not control execution."
      }
    }
  },
  {
    "id": "EXP-MS-0725",
    "component": "Routing Events – Scatter-Gather Failure Behavior",
    "difficulty": "Extreme",
    "question": "What happens if one route in Scatter-Gather fails?",
    "options": {
      "A": "All routes stop immediately",
      "B": "Other routes continue, error is aggregated",
      "C": "Failure is ignored",
      "D": "Only failed route result is returned"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Other routes continue and the error is included in the result.",
      "incorrect": {
        "A": "Routes are not stopped.",
        "C": "Failure is not ignored.",
        "D": "Results are aggregated."
      }
    }
  },

  {
    "id": "EXP-MS-0726",
    "component": "Routing Events – Scatter-Gather Result Structure",
    "difficulty": "Extreme",
    "question": "What is the structure of the payload after Scatter-Gather?",
    "options": {
      "A": "Single merged object",
      "B": "Array of route results",
      "C": "Map keyed by route name",
      "D": "Original payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scatter-Gather outputs an array of route results.",
      "incorrect": {
        "A": "No implicit merge.",
        "C": "Not keyed unless transformed.",
        "D": "Payload is replaced."
      }
    }
  },
  {
    "id": "EXP-MS-0727",
    "component": "Routing Events – Scatter-Gather Ordering",
    "difficulty": "Extreme",
    "question": "What determines the order of results in Scatter-Gather output?",
    "options": {
      "A": "Completion time",
      "B": "Route declaration order",
      "C": "Thread scheduling",
      "D": "Payload content"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Results follow the route declaration order.",
      "incorrect": {
        "A": "Completion time does not affect order.",
        "C": "Scheduling does not affect order.",
        "D": "Payload content is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0728",
    "component": "Routing Events – Validation Component Failure",
    "difficulty": "Extreme",
    "question": "What happens when a Validation component fails?",
    "options": {
      "A": "Returns false",
      "B": "Throws a validation error",
      "C": "Routes to otherwise",
      "D": "Skips validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation components throw errors on failure.",
      "incorrect": {
        "A": "They do not return booleans.",
        "C": "No routing logic.",
        "D": "Validation is enforced."
      }
    }
  },
  {
    "id": "EXP-MS-0729",
    "component": "Routing Events – Choice vs Validation",
    "difficulty": "Extreme",
    "question": "Why prefer Validation over Choice for enforcing constraints?",
    "options": {
      "A": "Better performance",
      "B": "Explicit error semantics",
      "C": "Parallel execution",
      "D": "Automatic retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation provides clear error semantics.",
      "incorrect": {
        "A": "Performance is similar.",
        "C": "No parallelism.",
        "D": "Retries are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0730",
    "component": "Routing Events – Choice Router Side Effects",
    "difficulty": "Extreme",
    "question": "What is a common pitfall when using side effects in Choice conditions?",
    "options": {
      "A": "Compilation error",
      "B": "Conditions evaluated multiple times",
      "C": "Streaming loss",
      "D": "Implicit parallelism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Conditions may be evaluated more than once, causing repeated side effects.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Streaming is unrelated.",
        "D": "No parallelism."
      }
    }
  },

  {
    "id": "EXP-MS-0731",
    "component": "Routing Events – First Successful Route Pattern",
    "difficulty": "Extreme",
    "question": "How can you implement a first-successful-route pattern?",
    "options": {
      "A": "Scatter-Gather",
      "B": "Choice router",
      "C": "Until Successful scope",
      "D": "Try scope"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Until Successful retries routes until one succeeds.",
      "incorrect": {
        "A": "Scatter-Gather runs all routes.",
        "B": "Choice does not retry.",
        "D": "Try does not retry automatically."
      }
    }
  },
  {
    "id": "EXP-MS-0732",
    "component": "Routing Events – Until Successful Retry Semantics",
    "difficulty": "Extreme",
    "question": "What triggers a retry in Until Successful?",
    "options": {
      "A": "Boolean false result",
      "B": "Thrown error",
      "C": "Null payload",
      "D": "Timeout only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries occur only when an error is thrown.",
      "incorrect": {
        "A": "False does not trigger retry.",
        "C": "Null alone does not trigger retry.",
        "D": "Timeout limits retries."
      }
    }
  },
  {
    "id": "EXP-MS-0733",
    "component": "Routing Events – Until Successful Transaction Scope",
    "difficulty": "Extreme",
    "question": "How does Until Successful interact with transactions?",
    "options": {
      "A": "Retries inside the same transaction",
      "B": "Starts a new transaction per retry",
      "C": "Disables transactions",
      "D": "Commits partial work"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each retry starts a new transaction.",
      "incorrect": {
        "A": "Transactions are not reused.",
        "C": "Transactions are supported.",
        "D": "Partial work is rolled back."
      }
    }
  },
  {
    "id": "EXP-MS-0734",
    "component": "Routing Events – Until Successful Idempotency Risk",
    "difficulty": "Extreme",
    "question": "Why must operations inside Until Successful be idempotent?",
    "options": {
      "A": "For performance",
      "B": "Because operations may be retried multiple times",
      "C": "To enable streaming",
      "D": "To avoid compilation errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can re-execute operations.",
      "incorrect": {
        "A": "Not primary reason.",
        "C": "Streaming unrelated.",
        "D": "Compilation unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0735",
    "component": "Routing Events – Routing Section Midpoint",
    "difficulty": "Extreme",
    "question": "What is the primary design goal of routing components?",
    "options": {
      "A": "Improve performance",
      "B": "Control execution path deterministically",
      "C": "Reduce code size",
      "D": "Enable parallelism everywhere"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Routing components deterministically control execution flow.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Code size is secondary.",
        "D": "Parallelism is selective."
      }
    }
  },

  {
    "id": "EXP-MS-0736",
    "component": "Routing Events – Dynamic Routing Risk",
    "difficulty": "Extreme",
    "question": "What is a major risk of dynamic routing based on payload values?",
    "options": {
      "A": "Compilation errors",
      "B": "Harder predictability and testing",
      "C": "Memory leaks",
      "D": "Automatic retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic routing increases unpredictability.",
      "incorrect": {
        "A": "Syntax remains valid.",
        "C": "Not inherent.",
        "D": "Retries are not automatic."
      }
    }
  },
  {
    "id": "EXP-MS-0737",
    "component": "Routing Events – Flow-Ref Routing",
    "difficulty": "Extreme",
    "question": "Why use flow-ref for routing instead of direct processors?",
    "options": {
      "A": "Better performance",
      "B": "Reusability and separation of concerns",
      "C": "Implicit parallelism",
      "D": "Automatic transactions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref improves reuse and modularity.",
      "incorrect": {
        "A": "Performance is similar.",
        "C": "No parallelism implied.",
        "D": "Transactions are explicit."
      }
    }
  },
  {
    "id": "EXP-MS-0738",
    "component": "Routing Events – Flow-Ref Variable Scope",
    "difficulty": "Extreme",
    "question": "What happens to variables when using flow-ref?",
    "options": {
      "A": "Variables are lost",
      "B": "Variables are copied",
      "C": "Variables are shared with called flow",
      "D": "Variables become immutable"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Variables are part of the same Mule event and are shared.",
      "incorrect": {
        "A": "They are preserved.",
        "B": "No copy is made.",
        "D": "They can be modified."
      }
    }
  },
  {
    "id": "EXP-MS-0739",
    "component": "Routing Events – Flow-Ref Error Propagation",
    "difficulty": "Extreme",
    "question": "How do errors propagate from a flow-ref?",
    "options": {
      "A": "Errors are swallowed",
      "B": "Errors propagate to the caller",
      "C": "Errors are logged only",
      "D": "Errors are converted to null payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors propagate back to the calling flow.",
      "incorrect": {
        "A": "Errors are not swallowed.",
        "C": "Not log-only.",
        "D": "No implicit conversion."
      }
    }
  },
  {
    "id": "EXP-MS-0740",
    "component": "Routing Events – Routing Section Continuation Marker",
    "difficulty": "Extreme",
    "question": "What defines expert-level routing design?",
    "options": {
      "A": "Maximum number of routes",
      "B": "Predictable, testable, and deterministic execution paths",
      "C": "Heavy dynamic routing",
      "D": "Avoiding routing components"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert routing emphasizes determinism and testability.",
      "incorrect": {
        "A": "Quantity is irrelevant.",
        "C": "Dynamic routing increases risk.",
        "D": "Routing is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0741",
    "component": "Routing Events – Scatter-Gather Timeout",
    "difficulty": "Extreme",
    "question": "What happens when a Scatter-Gather route exceeds its timeout?",
    "options": {
      "A": "Only that route is skipped",
      "B": "Scatter-Gather fails with a timeout error",
      "C": "Other routes are cancelled silently",
      "D": "Partial results are returned without error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "A timeout in any route causes Scatter-Gather to fail.",
      "incorrect": {
        "A": "Routes are not skipped.",
        "C": "Other routes are not silently cancelled.",
        "D": "Timeout results in an error."
      }
    }
  },
  {
    "id": "EXP-MS-0742",
    "component": "Routing Events – Scatter-Gather Memory Pressure",
    "difficulty": "Extreme",
    "question": "Why can Scatter-Gather cause high memory usage?",
    "options": {
      "A": "Sequential execution",
      "B": "Materializing results from all routes",
      "C": "Implicit retries",
      "D": "Streaming enforcement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "All route results are held in memory until aggregation.",
      "incorrect": {
        "A": "Execution is parallel.",
        "C": "No implicit retries.",
        "D": "Streaming is not enforced."
      }
    }
  },
  {
    "id": "EXP-MS-0743",
    "component": "Routing Events – Choice Router with Side Effects",
    "difficulty": "Extreme",
    "question": "Why should side effects be avoided in Choice when expressions?",
    "options": {
      "A": "They cause compilation errors",
      "B": "Conditions may be evaluated multiple times",
      "C": "They disable otherwise branch",
      "D": "They break streaming automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated evaluation can trigger side effects more than once.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "otherwise is unaffected.",
        "D": "Streaming is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0744",
    "component": "Routing Events – Until Successful Backoff",
    "difficulty": "Extreme",
    "question": "What controls the delay between retries in Until Successful?",
    "options": {
      "A": "maxRetries",
      "B": "frequency",
      "C": "timeout",
      "D": "scheduler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "frequency defines the wait time between retries.",
      "incorrect": {
        "A": "Controls retry count.",
        "C": "Controls total execution time.",
        "D": "Not used here."
      }
    }
  },
  {
    "id": "EXP-MS-0745",
    "component": "Routing Events – Until Successful Resource Leak",
    "difficulty": "Extreme",
    "question": "What risk arises if resources are opened inside Until Successful?",
    "options": {
      "A": "Compilation failure",
      "B": "Resource leaks across retries",
      "C": "Lost variables",
      "D": "Payload corruption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries may reopen resources without proper cleanup.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Variables persist.",
        "D": "Payload remains consistent."
      }
    }
  },

  {
    "id": "EXP-MS-0746",
    "component": "Routing Events – Flow-Ref vs Async",
    "difficulty": "Extreme",
    "question": "What is a key difference between flow-ref and async?",
    "options": {
      "A": "flow-ref is parallel, async is sequential",
      "B": "flow-ref shares transaction context, async does not",
      "C": "async propagates errors, flow-ref does not",
      "D": "async preserves ordering, flow-ref does not"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref executes synchronously within the same transaction.",
      "incorrect": {
        "A": "flow-ref is synchronous.",
        "C": "async errors do not propagate by default.",
        "D": "Ordering is not guaranteed in async."
      }
    }
  },
  {
    "id": "EXP-MS-0747",
    "component": "Routing Events – Flow-Ref Performance Cost",
    "difficulty": "Extreme",
    "question": "What is the primary cost of excessive flow-ref usage?",
    "options": {
      "A": "Compilation overhead",
      "B": "Call stack depth and tracing overhead",
      "C": "Memory leaks",
      "D": "Implicit retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep flow-ref chains increase call stack and tracing cost.",
      "incorrect": {
        "A": "Compilation cost is minor.",
        "C": "No inherent leaks.",
        "D": "No retries."
      }
    }
  },
  {
    "id": "EXP-MS-0748",
    "component": "Routing Events – Validation Scope Placement",
    "difficulty": "Extreme",
    "question": "Where should validation components be placed for fail-fast behavior?",
    "options": {
      "A": "At the end of the flow",
      "B": "Immediately after the inbound endpoint",
      "C": "Inside async scope",
      "D": "After scatter-gather"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early validation prevents unnecessary processing.",
      "incorrect": {
        "A": "Too late.",
        "C": "Async delays failure.",
        "D": "Consumes resources first."
      }
    }
  },
  {
    "id": "EXP-MS-0749",
    "component": "Routing Events – Dynamic Flow-Ref Risk",
    "difficulty": "Extreme",
    "question": "What is the primary risk of dynamic flow-ref names?",
    "options": {
      "A": "Compilation failure",
      "B": "Reduced testability and static analysis",
      "C": "Automatic retries",
      "D": "Lost variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic references reduce predictability and tooling support.",
      "incorrect": {
        "A": "Syntax may still compile.",
        "C": "Retries are unrelated.",
        "D": "Variables are preserved."
      }
    }
  },
  {
    "id": "EXP-MS-0750",
    "component": "Routing Events – Routing Scope Selection",
    "difficulty": "Extreme",
    "question": "Which factor most strongly influences routing scope choice?",
    "options": {
      "A": "Code length",
      "B": "Failure semantics and concurrency needs",
      "C": "Developer preference",
      "D": "Media type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Routing scopes differ mainly in failure and concurrency behavior.",
      "incorrect": {
        "A": "Length is irrelevant.",
        "C": "Preference is secondary.",
        "D": "Media type is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0751",
    "component": "Routing Events – Choice Router with Streaming",
    "difficulty": "Extreme",
    "question": "How does Choice router interact with streaming payloads?",
    "options": {
      "A": "Always preserves streaming",
      "B": "May consume stream during condition evaluation",
      "C": "Automatically buffers payload",
      "D": "Disables streaming permanently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Evaluating conditions may consume the stream.",
      "incorrect": {
        "A": "Not guaranteed.",
        "C": "No automatic buffering.",
        "D": "Streaming loss is conditional."
      }
    }
  },
  {
    "id": "EXP-MS-0752",
    "component": "Routing Events – Scatter-Gather vs Parallel For Each",
    "difficulty": "Extreme",
    "question": "Why prefer Scatter-Gather over Parallel For Each for routing?",
    "options": {
      "A": "Better syntax",
      "B": "Designed for routing, not record processing",
      "C": "Lower memory usage",
      "D": "Implicit retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scatter-Gather is intended for routing to endpoints.",
      "incorrect": {
        "A": "Syntax is subjective.",
        "C": "Memory usage can be higher.",
        "D": "No implicit retries."
      }
    }
  },
  {
    "id": "EXP-MS-0753",
    "component": "Routing Events – Until Successful Termination",
    "difficulty": "Extreme",
    "question": "What causes Until Successful to stop retrying?",
    "options": {
      "A": "Successful execution",
      "B": "Boolean true result",
      "C": "Null payload",
      "D": "Variable change"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Retries stop when execution completes without error.",
      "incorrect": {
        "B": "Boolean result is irrelevant.",
        "C": "Null payload alone does not stop retries.",
        "D": "Variables do not control termination."
      }
    }
  },
  {
    "id": "EXP-MS-0754",
    "component": "Routing Events – Routing Observability",
    "difficulty": "Extreme",
    "question": "What improves observability in complex routing logic?",
    "options": {
      "A": "Dynamic routing everywhere",
      "B": "Explicit logging at routing decisions",
      "C": "Avoiding flow-ref",
      "D": "Single large flow"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit logs clarify which routing path was taken.",
      "incorrect": {
        "A": "Reduces predictability.",
        "C": "flow-ref can help modularity.",
        "D": "Large flows reduce clarity."
      }
    }
  },
  {
    "id": "EXP-MS-0755",
    "component": "Routing Events – Routing Anti-Pattern",
    "difficulty": "Extreme",
    "question": "Which is a common routing anti-pattern?",
    "options": {
      "A": "Fail-fast validation",
      "B": "Deeply nested Choice routers",
      "C": "Explicit otherwise branch",
      "D": "Clear flow naming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting reduces readability and maintainability.",
      "incorrect": {
        "A": "Fail-fast is good practice.",
        "C": "otherwise is recommended.",
        "D": "Naming improves clarity."
      }
    }
  },

  {
    "id": "EXP-MS-0756",
    "component": "Routing Events – Error vs Routing Separation",
    "difficulty": "Extreme",
    "question": "Why should error handling be separated from routing logic?",
    "options": {
      "A": "Performance reasons",
      "B": "Clearer responsibilities and simpler flows",
      "C": "Mandatory by Mule",
      "D": "To enable streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Separation improves clarity and maintainability.",
      "incorrect": {
        "A": "Performance impact is minor.",
        "C": "Not mandatory.",
        "D": "Streaming is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0757",
    "component": "Routing Events – Routing Determinism Test",
    "difficulty": "Extreme",
    "question": "How can routing determinism best be tested?",
    "options": {
      "A": "Manual testing only",
      "B": "MUnit tests covering each route condition",
      "C": "Production monitoring",
      "D": "Debugger sessions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MUnit tests validate each routing path deterministically.",
      "incorrect": {
        "A": "Manual testing is insufficient.",
        "C": "Monitoring is reactive.",
        "D": "Debugger is not repeatable."
      }
    }
  },
  {
    "id": "EXP-MS-0758",
    "component": "Routing Events – Routing and Idempotency",
    "difficulty": "Extreme",
    "question": "Why is idempotency important in routing with retries?",
    "options": {
      "A": "Improves speed",
      "B": "Prevents duplicate side effects",
      "C": "Reduces memory usage",
      "D": "Simplifies syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries may re-execute routes causing duplicates.",
      "incorrect": {
        "A": "Speed is secondary.",
        "C": "Memory is unrelated.",
        "D": "Syntax unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0759",
    "component": "Routing Events – Routing with Transactions",
    "difficulty": "Extreme",
    "question": "How do transactions affect routing decisions?",
    "options": {
      "A": "Transactions decide routes",
      "B": "Routing occurs within the same transaction context",
      "C": "Transactions are ignored in routing",
      "D": "Each route has its own transaction"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Routing does not break the transaction context by default.",
      "incorrect": {
        "A": "Transactions do not decide routing.",
        "C": "Transactions are respected.",
        "D": "Not unless explicitly configured."
      }
    }
  },
  {
    "id": "EXP-MS-0760",
    "component": "Routing Events – Routing Section Closure",
    "difficulty": "Extreme",
    "question": "What defines expert-level routing implementation?",
    "options": {
      "A": "Maximum routing branches",
      "B": "Deterministic, testable, and observable routing paths",
      "C": "Dynamic routing everywhere",
      "D": "Minimal use of routing scopes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert routing is predictable, testable, and observable.",
      "incorrect": {
        "A": "Branch count is irrelevant.",
        "C": "Dynamic routing increases risk.",
        "D": "Routing scopes are essential."
      }
    }
  },
  {
    "id": "EXP-MS-0761",
    "component": "Routing Events – Choice Router Short-Circuit",
    "difficulty": "Extreme",
    "question": "What happens to remaining when conditions after a Choice router match?",
    "options": {
      "A": "They are still evaluated",
      "B": "They are skipped entirely",
      "C": "They are evaluated lazily",
      "D": "They are cached"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Choice router stops evaluation after the first matching when.",
      "incorrect": {
        "A": "Evaluation halts immediately.",
        "C": "No lazy evaluation.",
        "D": "No caching occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0762",
    "component": "Routing Events – Choice Router Expression Side Effects",
    "difficulty": "Extreme",
    "question": "Why must DataWeave expressions in when conditions be side-effect free?",
    "options": {
      "A": "They may execute concurrently",
      "B": "They may execute more than once",
      "C": "They block the flow",
      "D": "They disable streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Conditions can be evaluated multiple times.",
      "incorrect": {
        "A": "They are sequential.",
        "C": "They do not block.",
        "D": "Streaming impact is indirect."
      }
    }
  },
  {
    "id": "EXP-MS-0763",
    "component": "Routing Events – Choice Router and Null Payload",
    "difficulty": "Extreme",
    "question": "If payload is null and when condition checks payload.field, what occurs?",
    "options": {
      "A": "Condition evaluates to false",
      "B": "Null is ignored",
      "C": "Runtime error is thrown",
      "D": "otherwise is automatically chosen"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Accessing a field on null throws a runtime error.",
      "incorrect": {
        "A": "No implicit false.",
        "B": "Null is not ignored.",
        "D": "otherwise is not automatic."
      }
    }
  },
  {
    "id": "EXP-MS-0764",
    "component": "Routing Events – Scatter-Gather Thread Model",
    "difficulty": "Extreme",
    "question": "How does Scatter-Gather utilize threads?",
    "options": {
      "A": "Single-threaded execution",
      "B": "One thread per route",
      "C": "Shared event-loop thread",
      "D": "Caller thread only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each route executes on its own thread.",
      "incorrect": {
        "A": "Execution is parallel.",
        "C": "Not event-loop based.",
        "D": "Caller thread delegates work."
      }
    }
  },
  {
    "id": "EXP-MS-0765",
    "component": "Routing Events – Scatter-Gather Backpressure",
    "difficulty": "Extreme",
    "question": "What happens if downstream processing is slower in Scatter-Gather?",
    "options": {
      "A": "Routes are dropped",
      "B": "Backpressure builds until completion",
      "C": "Routes auto-scale",
      "D": "Payload is truncated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Results are buffered until all routes complete.",
      "incorrect": {
        "A": "Routes are not dropped.",
        "C": "No auto-scaling.",
        "D": "Payload is preserved."
      }
    }
  },

  {
    "id": "EXP-MS-0766",
    "component": "Routing Events – Scatter-Gather Partial Failure Handling",
    "difficulty": "Extreme",
    "question": "How can partial failures in Scatter-Gather be tolerated?",
    "options": {
      "A": "Using Choice router",
      "B": "Wrapping routes in Try scopes",
      "C": "Using async scope",
      "D": "Disabling error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Try scopes can catch errors per route.",
      "incorrect": {
        "A": "Choice does not handle parallel routes.",
        "C": "Async does not aggregate.",
        "D": "Errors must be handled explicitly."
      }
    }
  },
  {
    "id": "EXP-MS-0767",
    "component": "Routing Events – Scatter-Gather Result Correlation",
    "difficulty": "Extreme",
    "question": "How can individual route results be correlated post Scatter-Gather?",
    "options": {
      "A": "By index position",
      "B": "By payload content",
      "C": "By correlationId automatically",
      "D": "By thread name"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Results preserve route declaration order.",
      "incorrect": {
        "B": "Content may vary.",
        "C": "No automatic correlation mapping.",
        "D": "Thread names are irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0768",
    "component": "Routing Events – Until Successful Retry Flooding",
    "difficulty": "Extreme",
    "question": "What risk exists if frequency is set too low in Until Successful?",
    "options": {
      "A": "Compilation failure",
      "B": "Retry storm against downstream systems",
      "C": "Lost variables",
      "D": "Payload mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Low frequency causes aggressive retries.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Variables persist.",
        "D": "Payload remains unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0769",
    "component": "Routing Events – Until Successful and Streaming",
    "difficulty": "Extreme",
    "question": "Why is streaming payload risky inside Until Successful?",
    "options": {
      "A": "Streams cannot be retried",
      "B": "Streams auto-reset",
      "C": "Streams are duplicated",
      "D": "Streams become immutable"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Streams are consumed and cannot be replayed.",
      "incorrect": {
        "B": "No auto-reset.",
        "C": "No duplication.",
        "D": "Immutability is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0770",
    "component": "Routing Events – Until Successful Timeout Semantics",
    "difficulty": "Extreme",
    "question": "What does timeout represent in Until Successful?",
    "options": {
      "A": "Delay between retries",
      "B": "Maximum total execution time",
      "C": "Per-attempt execution time",
      "D": "Network timeout"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeout caps total retry duration.",
      "incorrect": {
        "A": "That is frequency.",
        "C": "Not per-attempt.",
        "D": "Not network-specific."
      }
    }
  },

  {
    "id": "EXP-MS-0771",
    "component": "Routing Events – Flow-Ref Circular Dependency",
    "difficulty": "Extreme",
    "question": "What happens if two flows reference each other via flow-ref?",
    "options": {
      "A": "Compilation error",
      "B": "Runtime stack overflow",
      "C": "Deadlock",
      "D": "Silent failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circular calls cause infinite recursion.",
      "incorrect": {
        "A": "Configuration is valid.",
        "C": "No locking occurs.",
        "D": "Failure is explicit."
      }
    }
  },
  {
    "id": "EXP-MS-0772",
    "component": "Routing Events – Flow-Ref and Error Handler",
    "difficulty": "Extreme",
    "question": "Where is an error from flow-ref handled by default?",
    "options": {
      "A": "Inside the called flow only",
      "B": "Caller flow error handler",
      "C": "Global error handler only",
      "D": "It is swallowed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors propagate back to the caller.",
      "incorrect": {
        "A": "Not limited to called flow.",
        "C": "Global handler applies only if uncaught.",
        "D": "Errors are not swallowed."
      }
    }
  },
  {
    "id": "EXP-MS-0773",
    "component": "Routing Events – Async Scope Completion",
    "difficulty": "Extreme",
    "question": "When does the main flow continue after async scope?",
    "options": {
      "A": "After async completes",
      "B": "Immediately after async dispatch",
      "C": "After timeout",
      "D": "After error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async executes independently.",
      "incorrect": {
        "A": "Main flow does not wait.",
        "C": "Timeout is irrelevant.",
        "D": "Errors do not block."
      }
    }
  },
  {
    "id": "EXP-MS-0774",
    "component": "Routing Events – Async Error Visibility",
    "difficulty": "Extreme",
    "question": "How are errors inside async scope observed?",
    "options": {
      "A": "Propagated to caller",
      "B": "Logged only unless explicitly handled",
      "C": "Converted to payload",
      "D": "Ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async errors do not propagate by default.",
      "incorrect": {
        "A": "No propagation.",
        "C": "No conversion.",
        "D": "They are logged."
      }
    }
  },
  {
    "id": "EXP-MS-0775",
    "component": "Routing Events – Async Transaction Boundary",
    "difficulty": "Extreme",
    "question": "What happens to transaction context inside async?",
    "options": {
      "A": "Inherited",
      "B": "New transaction started",
      "C": "Transaction is lost",
      "D": "Transaction is suspended"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Async suspends the transaction context.",
      "incorrect": {
        "A": "Not inherited.",
        "B": "Not automatic.",
        "C": "Context is suspended, not lost."
      }
    }
  },

  {
    "id": "EXP-MS-0776",
    "component": "Routing Events – Router Testing Strategy",
    "difficulty": "Extreme",
    "question": "What is the most reliable way to test routing logic?",
    "options": {
      "A": "Manual QA",
      "B": "MUnit tests per route path",
      "C": "Production logs",
      "D": "Debugger breakpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MUnit ensures deterministic validation.",
      "incorrect": {
        "A": "Manual testing is insufficient.",
        "C": "Logs are reactive.",
        "D": "Debugging is non-repeatable."
      }
    }
  },
  {
    "id": "EXP-MS-0777",
    "component": "Routing Events – Router Observability",
    "difficulty": "Extreme",
    "question": "What improves observability of routing decisions?",
    "options": {
      "A": "Dynamic expressions",
      "B": "Explicit logs at decision points",
      "C": "Avoiding routing scopes",
      "D": "Large single flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logging decisions clarifies flow behavior.",
      "incorrect": {
        "A": "Dynamic logic obscures behavior.",
        "C": "Routing scopes are needed.",
        "D": "Large flows reduce clarity."
      }
    }
  },
  {
    "id": "EXP-MS-0778",
    "component": "Routing Events – Routing and Idempotency",
    "difficulty": "Extreme",
    "question": "Why must routed operations often be idempotent?",
    "options": {
      "A": "To improve performance",
      "B": "To handle retries safely",
      "C": "To enable streaming",
      "D": "To simplify code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can re-execute operations.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Streaming is unrelated.",
        "D": "Code simplicity is secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0779",
    "component": "Routing Events – Routing Complexity Limit",
    "difficulty": "Extreme",
    "question": "What signals excessive routing complexity?",
    "options": {
      "A": "Multiple flow-refs",
      "B": "Deeply nested routers",
      "C": "Explicit error handlers",
      "D": "Named subflows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting reduces maintainability.",
      "incorrect": {
        "A": "Flow-refs are normal.",
        "C": "Error handlers are required.",
        "D": "Subflows improve structure."
      }
    }
  },
  {
    "id": "EXP-MS-0780",
    "component": "Routing Events – Routing Section Completion",
    "difficulty": "Extreme",
    "question": "What is the defining characteristic of expert routing design?",
    "options": {
      "A": "Maximum concurrency",
      "B": "Predictable, testable, observable execution paths",
      "C": "Minimal processors",
      "D": "Dynamic routing everywhere"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert routing prioritizes determinism and observability.",
      "incorrect": {
        "A": "Concurrency is selective.",
        "C": "Minimalism alone is insufficient.",
        "D": "Dynamic routing increases risk."
      }
    }
  },
  {
    "id": "EXP-MS-0781",
    "component": "Routing Events – Choice Router Boolean Short-Circuit",
    "difficulty": "Extreme",
    "question": "In a Choice router, if the first when condition evaluates to true, what happens to the remaining conditions?",
    "options": {
      "A": "They are evaluated for logging",
      "B": "They are skipped entirely",
      "C": "They are cached",
      "D": "They are evaluated asynchronously"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Choice router stops evaluation after the first true condition.",
      "incorrect": {
        "A": "No evaluation occurs.",
        "C": "Conditions are not cached.",
        "D": "No async evaluation."
      }
    }
  },
  {
    "id": "EXP-MS-0782",
    "component": "Routing Events – Choice Router with Streaming Payload",
    "difficulty": "Extreme",
    "question": "Why can using payload-consuming expressions inside Choice conditions be dangerous?",
    "options": {
      "A": "Compilation error",
      "B": "Stream may be consumed before routing",
      "C": "Conditions return false",
      "D": "otherwise branch executes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Evaluating the payload may consume the stream.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Evaluation may succeed.",
        "D": "Routing logic remains intact."
      }
    }
  },
  {
    "id": "EXP-MS-0783",
    "component": "Routing Events – Scatter-Gather Thread Saturation",
    "difficulty": "Extreme",
    "question": "What risk arises when Scatter-Gather is used with many routes under load?",
    "options": {
      "A": "Payload corruption",
      "B": "Thread pool exhaustion",
      "C": "Duplicate responses",
      "D": "Implicit retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each route consumes a thread, risking exhaustion.",
      "incorrect": {
        "A": "Payload remains intact.",
        "C": "Responses are aggregated once.",
        "D": "No retries occur."
      }
    }
  },
  {
    "id": "EXP-MS-0784",
    "component": "Routing Events – Scatter-Gather Error Aggregation",
    "difficulty": "Extreme",
    "question": "If two routes fail inside Scatter-Gather, what happens?",
    "options": {
      "A": "First error only is propagated",
      "B": "All errors are aggregated into the result",
      "C": "Errors are ignored",
      "D": "Routes are retried"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scatter-Gather aggregates route failures.",
      "incorrect": {
        "A": "Not limited to first error.",
        "C": "Errors are preserved.",
        "D": "No retry occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0785",
    "component": "Routing Events – Scatter-Gather vs Async Semantics",
    "difficulty": "Extreme",
    "question": "What is the key semantic difference between Scatter-Gather and async?",
    "options": {
      "A": "Scatter-Gather is sequential",
      "B": "Scatter-Gather waits for all routes",
      "C": "async preserves transactions",
      "D": "async aggregates responses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scatter-Gather waits and aggregates all routes.",
      "incorrect": {
        "A": "Scatter-Gather is parallel.",
        "C": "async suspends transactions.",
        "D": "async does not aggregate."
      }
    }
  },

  {
    "id": "EXP-MS-0786",
    "component": "Routing Events – Until Successful Retry Explosion",
    "difficulty": "Extreme",
    "question": "What happens if maxRetries is very high and frequency is very low?",
    "options": {
      "A": "Retries stop early",
      "B": "Downstream systems may be overwhelmed",
      "C": "Retries are skipped",
      "D": "Errors are swallowed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Aggressive retries can overload downstream systems.",
      "incorrect": {
        "A": "Retries continue until success or timeout.",
        "C": "Retries are not skipped.",
        "D": "Errors are retried, not swallowed."
      }
    }
  },
  {
    "id": "EXP-MS-0787",
    "component": "Routing Events – Until Successful and Side Effects",
    "difficulty": "Extreme",
    "question": "Why must operations inside Until Successful be idempotent?",
    "options": {
      "A": "For compilation",
      "B": "Because retries may execute the operation multiple times",
      "C": "To preserve streaming",
      "D": "To avoid payload mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can repeat side effects.",
      "incorrect": {
        "A": "Compilation unaffected.",
        "C": "Streaming is unrelated.",
        "D": "Mutation is allowed."
      }
    }
  },
  {
    "id": "EXP-MS-0788",
    "component": "Routing Events – Until Successful and Streaming",
    "difficulty": "Extreme",
    "question": "What is the safest approach when using streaming payloads with Until Successful?",
    "options": {
      "A": "Retry automatically",
      "B": "Buffer the stream before retrying",
      "C": "Ignore errors",
      "D": "Disable streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streams must be buffered to allow retries.",
      "incorrect": {
        "A": "Streams cannot replay automatically.",
        "C": "Errors must be handled.",
        "D": "Disabling streaming is not always acceptable."
      }
    }
  },
  {
    "id": "EXP-MS-0789",
    "component": "Routing Events – Flow-Ref Execution Context",
    "difficulty": "Extreme",
    "question": "What execution context does flow-ref use?",
    "options": {
      "A": "New Mule event",
      "B": "Same Mule event",
      "C": "New thread always",
      "D": "Detached context"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "flow-ref executes in the same Mule event.",
      "incorrect": {
        "A": "Event is not cloned.",
        "C": "Thread reuse is possible.",
        "D": "Context is not detached."
      }
    }
  },
  {
    "id": "EXP-MS-0790",
    "component": "Routing Events – Flow-Ref Variable Mutation",
    "difficulty": "Extreme",
    "question": "If a variable is modified inside a flow-ref, what happens?",
    "options": {
      "A": "Change is lost",
      "B": "Change is visible to the caller",
      "C": "Variable becomes immutable",
      "D": "Runtime error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Variables belong to the same Mule event.",
      "incorrect": {
        "A": "No copy is made.",
        "C": "Variables remain mutable.",
        "D": "No error occurs."
      }
    }
  },

  {
    "id": "EXP-MS-0791",
    "component": "Routing Events – Async Error Visibility",
    "difficulty": "Extreme",
    "question": "How are errors thrown inside async handled by default?",
    "options": {
      "A": "Propagated to caller",
      "B": "Logged but not propagated",
      "C": "Converted to payload",
      "D": "Cause flow failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async errors do not propagate automatically.",
      "incorrect": {
        "A": "Caller continues execution.",
        "C": "No conversion occurs.",
        "D": "Main flow does not fail."
      }
    }
  },
  {
    "id": "EXP-MS-0792",
    "component": "Routing Events – Async Transaction Boundary",
    "difficulty": "Extreme",
    "question": "What happens to a transaction when entering async?",
    "options": {
      "A": "Transaction continues",
      "B": "Transaction is suspended",
      "C": "Transaction is committed",
      "D": "Transaction is rolled back"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async suspends the transaction context.",
      "incorrect": {
        "A": "It does not continue.",
        "C": "No commit occurs.",
        "D": "No rollback occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0793",
    "component": "Routing Events – Async Ordering Guarantee",
    "difficulty": "Extreme",
    "question": "What ordering guarantee does async provide?",
    "options": {
      "A": "FIFO ordering",
      "B": "No ordering guarantee",
      "C": "Sequential execution",
      "D": "Route-based ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async execution order is not guaranteed.",
      "incorrect": {
        "A": "FIFO is not guaranteed.",
        "C": "Execution is parallel.",
        "D": "Routes are irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0794",
    "component": "Routing Events – Router Observability",
    "difficulty": "Extreme",
    "question": "What is the most reliable way to observe routing behavior?",
    "options": {
      "A": "Debugger only",
      "B": "Explicit logs at routing points",
      "C": "Dynamic expressions",
      "D": "Large single flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logs provide deterministic observability.",
      "incorrect": {
        "A": "Debugger is transient.",
        "C": "Dynamics reduce clarity.",
        "D": "Large flows obscure logic."
      }
    }
  },
  {
    "id": "EXP-MS-0795",
    "component": "Routing Events – Routing Maintainability",
    "difficulty": "Extreme",
    "question": "What is a strong indicator of poor routing design?",
    "options": {
      "A": "Multiple subflows",
      "B": "Deeply nested routers",
      "C": "Explicit otherwise branches",
      "D": "Clear flow naming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting harms maintainability.",
      "incorrect": {
        "A": "Subflows improve clarity.",
        "C": "otherwise is recommended.",
        "D": "Naming improves readability."
      }
    }
  },

  {
    "id": "EXP-MS-0796",
    "component": "Routing Events – Routing and Idempotency",
    "difficulty": "Extreme",
    "question": "Why is idempotency critical when routing involves retries?",
    "options": {
      "A": "Improves throughput",
      "B": "Prevents duplicate side effects",
      "C": "Simplifies DataWeave",
      "D": "Reduces latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can re-trigger side effects.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "DW syntax unaffected.",
        "D": "Latency may increase."
      }
    }
  },
  {
    "id": "EXP-MS-0797",
    "component": "Routing Events – Routing Determinism",
    "difficulty": "Extreme",
    "question": "What property best defines deterministic routing?",
    "options": {
      "A": "Dynamic evaluation",
      "B": "Same input always yields same path",
      "C": "Maximum concurrency",
      "D": "Minimal processors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Determinism ensures predictable execution paths.",
      "incorrect": {
        "A": "Dynamic logic reduces determinism.",
        "C": "Concurrency is orthogonal.",
        "D": "Processor count is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0798",
    "component": "Routing Events – Routing Test Strategy",
    "difficulty": "Extreme",
    "question": "What is the best way to assert routing correctness?",
    "options": {
      "A": "Production monitoring",
      "B": "MUnit tests per routing path",
      "C": "Manual QA",
      "D": "Debugger sessions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MUnit provides deterministic validation.",
      "incorrect": {
        "A": "Monitoring is reactive.",
        "C": "Manual testing is insufficient.",
        "D": "Debugger is non-repeatable."
      }
    }
  },
  {
    "id": "EXP-MS-0799",
    "component": "Routing Events – Routing Complexity Signal",
    "difficulty": "Extreme",
    "question": "What signals excessive routing complexity?",
    "options": {
      "A": "Multiple flow-refs",
      "B": "Deep router nesting",
      "C": "Explicit logging",
      "D": "Named subflows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting reduces clarity and testability.",
      "incorrect": {
        "A": "flow-refs are normal.",
        "C": "Logging improves clarity.",
        "D": "Subflows improve structure."
      }
    }
  },
  {
    "id": "EXP-MS-0800",
    "component": "Routing Events – Routing Domain Completion",
    "difficulty": "Extreme",
    "question": "What defines expert-level mastery of Mule routing?",
    "options": {
      "A": "Using all routing scopes",
      "B": "Deterministic, observable, testable routing paths",
      "C": "Maximum parallelism",
      "D": "Avoiding routing logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert routing prioritizes predictability and observability.",
      "incorrect": {
        "A": "Scope count is irrelevant.",
        "C": "Parallelism is selective.",
        "D": "Routing is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0801",
    "component": "Handling Errors – Global Error Handler Resolution",
    "difficulty": "Extreme",
    "question": "When both a flow-level and global error handler can handle an error, which one is executed?",
    "options": {
      "A": "Global error handler",
      "B": "Flow-level error handler",
      "C": "Both in sequence",
      "D": "Randomly chosen"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flow-level error handlers take precedence over global ones.",
      "incorrect": {
        "A": "Global is used only if flow-level does not match.",
        "C": "Only one handler executes.",
        "D": "Resolution is deterministic."
      }
    }
  },
  {
    "id": "EXP-MS-0802",
    "component": "Handling Errors – on-error-propagate Semantics",
    "difficulty": "Extreme",
    "question": "What is the key behavior of on-error-propagate?",
    "options": {
      "A": "Consumes the error",
      "B": "Stops flow without error",
      "C": "Propagates the error after execution",
      "D": "Retries automatically"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "on-error-propagate executes logic and rethrows the error.",
      "incorrect": {
        "A": "Error is not consumed.",
        "B": "Flow ends with error.",
        "D": "No retry is implicit."
      }
    }
  },
  {
    "id": "EXP-MS-0803",
    "component": "Handling Errors – on-error-continue Semantics",
    "difficulty": "Extreme",
    "question": "What happens after on-error-continue completes?",
    "options": {
      "A": "Flow terminates with error",
      "B": "Flow resumes execution",
      "C": "Transaction rolls back",
      "D": "Global handler executes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "on-error-continue consumes the error and resumes flow execution.",
      "incorrect": {
        "A": "Error is handled.",
        "C": "Rollback depends on transaction config.",
        "D": "Global handler is bypassed."
      }
    }
  },
  {
    "id": "EXP-MS-0804",
    "component": "Handling Errors – Error Type Hierarchy",
    "difficulty": "Extreme",
    "question": "If an error handler matches a parent error type and a child type exists, which handler is selected?",
    "options": {
      "A": "Parent type handler",
      "B": "Child type handler",
      "C": "Both execute",
      "D": "Global handler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The most specific (child) error type handler is selected.",
      "incorrect": {
        "A": "Specificity takes precedence.",
        "C": "Only one handler executes.",
        "D": "Global applies only if none match."
      }
    }
  },
  {
    "id": "EXP-MS-0805",
    "component": "Handling Errors – Try Scope Error Boundary",
    "difficulty": "Extreme",
    "question": "What is the primary purpose of the Try scope?",
    "options": {
      "A": "Retry logic",
      "B": "Define a local error handling boundary",
      "C": "Enable parallel execution",
      "D": "Improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Try scopes isolate error handling for a block of processors.",
      "incorrect": {
        "A": "Retries require Until Successful.",
        "C": "Try is sequential.",
        "D": "Performance is secondary."
      }
    }
  },

  {
    "id": "EXP-MS-0806",
    "component": "Handling Errors – Try Scope Propagation",
    "difficulty": "Extreme",
    "question": "If a Try scope has no matching error handler, what happens?",
    "options": {
      "A": "Error is swallowed",
      "B": "Error propagates to outer scope",
      "C": "Flow resumes automatically",
      "D": "Global handler is ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors bubble up if not handled locally.",
      "incorrect": {
        "A": "Errors are not swallowed.",
        "C": "Flow does not resume automatically.",
        "D": "Global handler may still apply."
      }
    }
  },
  {
    "id": "EXP-MS-0807",
    "component": "Handling Errors – Multiple Error Handlers Order",
    "difficulty": "Extreme",
    "question": "How are multiple error handlers within the same scope evaluated?",
    "options": {
      "A": "Random order",
      "B": "Declaration order",
      "C": "Most specific error type first",
      "D": "Last-defined wins"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Handlers are chosen by most specific error type match.",
      "incorrect": {
        "A": "Resolution is deterministic.",
        "B": "Order matters only for equal specificity.",
        "D": "Last-defined does not override specificity."
      }
    }
  },
  {
    "id": "EXP-MS-0808",
    "component": "Handling Errors – Mapping Custom Errors",
    "difficulty": "Extreme",
    "question": "Why map connector errors to custom error types?",
    "options": {
      "A": "Improve performance",
      "B": "Enable business-specific error handling",
      "C": "Reduce logging",
      "D": "Avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom errors allow business-aligned handling logic.",
      "incorrect": {
        "A": "Performance unaffected.",
        "C": "Logging is independent.",
        "D": "Retries are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0809",
    "component": "Handling Errors – Error Mapping Timing",
    "difficulty": "Extreme",
    "question": "When does error mapping occur in a processor?",
    "options": {
      "A": "Before execution",
      "B": "At compile time",
      "C": "When the error is thrown",
      "D": "After global handler"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Error mapping is applied at runtime when the error occurs.",
      "incorrect": {
        "A": "Execution must occur first.",
        "B": "Mapping is runtime-based.",
        "D": "Global handler runs later."
      }
    }
  },
  {
    "id": "EXP-MS-0810",
    "component": "Handling Errors – Error Description vs Cause",
    "difficulty": "Extreme",
    "question": "What is the difference between error.description and error.cause?",
    "options": {
      "A": "No difference",
      "B": "description is user-friendly, cause is technical",
      "C": "cause is always null",
      "D": "description is immutable"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "description summarizes the error; cause holds the underlying exception.",
      "incorrect": {
        "A": "They serve different purposes.",
        "C": "cause may be populated.",
        "D": "description can be set."
      }
    }
  },

  {
    "id": "EXP-MS-0811",
    "component": "Handling Errors – Transaction Rollback Rule",
    "difficulty": "Extreme",
    "question": "When does a transaction roll back automatically?",
    "options": {
      "A": "on-error-continue executes",
      "B": "An error propagates out of the transaction",
      "C": "Any validation fails",
      "D": "Any error occurs inside Try"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback occurs when an error propagates out of the transaction scope.",
      "incorrect": {
        "A": "on-error-continue consumes errors.",
        "C": "Validation failure may be handled.",
        "D": "Try may catch errors."
      }
    }
  },
  {
    "id": "EXP-MS-0812",
    "component": "Handling Errors – Error Handling Anti-Pattern",
    "difficulty": "Extreme",
    "question": "Which is a common error-handling anti-pattern?",
    "options": {
      "A": "Fail-fast validation",
      "B": "Catching all errors generically",
      "C": "Mapping custom errors",
      "D": "Using specific error types"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Generic catching hides root causes and complicates debugging.",
      "incorrect": {
        "A": "Fail-fast is recommended.",
        "C": "Custom mapping improves clarity.",
        "D": "Specific handling is best practice."
      }
    }
  },
  {
    "id": "EXP-MS-0813",
    "component": "Handling Errors – Error Visibility in Logs",
    "difficulty": "Extreme",
    "question": "What practice improves error traceability in logs?",
    "options": {
      "A": "Suppress stack traces",
      "B": "Log correlationId with error",
      "C": "Catch and ignore errors",
      "D": "Use only global handlers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs allow tracing errors across flows.",
      "incorrect": {
        "A": "Suppressing traces reduces visibility.",
        "C": "Ignoring errors is unsafe.",
        "D": "Global handlers alone are insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0814",
    "component": "Handling Errors – Error Handler Side Effects",
    "difficulty": "Extreme",
    "question": "Why should error handlers avoid side effects?",
    "options": {
      "A": "They run in parallel",
      "B": "They may execute multiple times",
      "C": "They block transactions",
      "D": "They disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Handlers can be triggered repeatedly under retries.",
      "incorrect": {
        "A": "Handlers are sequential.",
        "C": "Transactions depend on scope.",
        "D": "Retries are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0815",
    "component": "Handling Errors – Error Propagation Boundary",
    "difficulty": "Extreme",
    "question": "What defines the boundary for error propagation?",
    "options": {
      "A": "Application",
      "B": "Flow and Try scopes",
      "C": "Connector",
      "D": "Runtime"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flows and Try scopes define propagation boundaries.",
      "incorrect": {
        "A": "Application is too broad.",
        "C": "Connectors throw errors but do not define boundaries.",
        "D": "Runtime is global."
      }
    }
  },

  {
    "id": "EXP-MS-0816",
    "component": "Handling Errors – HTTP Error Mapping",
    "difficulty": "Extreme",
    "question": "Why map internal errors to HTTP status codes explicitly?",
    "options": {
      "A": "Automatic mapping is perfect",
      "B": "To control API contract behavior",
      "C": "To reduce payload size",
      "D": "To enable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit mapping enforces consistent API responses.",
      "incorrect": {
        "A": "Automatic mapping is generic.",
        "C": "Payload size is unrelated.",
        "D": "Retries are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0817",
    "component": "Handling Errors – Error vs Fault Distinction",
    "difficulty": "Extreme",
    "question": "What differentiates a business fault from a system error?",
    "options": {
      "A": "Faults are retried",
      "B": "Faults represent valid business outcomes",
      "C": "Errors are logged",
      "D": "Faults are exceptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business faults are expected outcomes, not system failures.",
      "incorrect": {
        "A": "Faults usually are not retried.",
        "C": "Both can be logged.",
        "D": "Faults may not be exceptions."
      }
    }
  },
  {
    "id": "EXP-MS-0818",
    "component": "Handling Errors – Retry vs Error Handler",
    "difficulty": "Extreme",
    "question": "When should retries be avoided?",
    "options": {
      "A": "Transient network errors",
      "B": "Non-idempotent operations",
      "C": "Timeouts",
      "D": "Connector failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can duplicate side effects for non-idempotent operations.",
      "incorrect": {
        "A": "Retries are suitable here.",
        "C": "Retries may help.",
        "D": "Depends on error type."
      }
    }
  },
  {
    "id": "EXP-MS-0819",
    "component": "Handling Errors – Error Handling Testing",
    "difficulty": "Extreme",
    "question": "How should error handling logic be tested?",
    "options": {
      "A": "Manual testing only",
      "B": "MUnit tests simulating error conditions",
      "C": "Production monitoring",
      "D": "Debugger sessions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MUnit allows deterministic testing of error paths.",
      "incorrect": {
        "A": "Manual testing is insufficient.",
        "C": "Monitoring is reactive.",
        "D": "Debugger is non-repeatable."
      }
    }
  },
  {
    "id": "EXP-MS-0820",
    "component": "Handling Errors – Error Domain Midpoint Marker",
    "difficulty": "Extreme",
    "question": "What defines expert-level error handling?",
    "options": {
      "A": "Catching all errors",
      "B": "Specific, intentional, and observable error strategies",
      "C": "Suppressing stack traces",
      "D": "Single global handler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert handling is precise, intentional, and observable.",
      "incorrect": {
        "A": "Overly generic handling is harmful.",
        "C": "Suppressing traces reduces visibility.",
        "D": "Single handler is insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0821",
    "component": "Handling Errors – Nested Try Resolution",
    "difficulty": "Extreme",
    "question": "If an error occurs inside a nested Try scope and the inner Try has no matching handler, where does the error go?",
    "options": {
      "A": "It is swallowed",
      "B": "Outer Try error handler",
      "C": "Global error handler immediately",
      "D": "Flow resumes execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors bubble up to the nearest enclosing Try scope.",
      "incorrect": {
        "A": "Errors are not swallowed.",
        "C": "Global applies only if no local handler matches.",
        "D": "Execution does not resume automatically."
      }
    }
  },
  {
    "id": "EXP-MS-0822",
    "component": "Handling Errors – Error Handler Selection",
    "difficulty": "Extreme",
    "question": "If two on-error-propagate handlers match the same error type, which one is chosen?",
    "options": {
      "A": "Last declared",
      "B": "First declared",
      "C": "Most specific by hierarchy",
      "D": "Random"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Mule selects the most specific error type match.",
      "incorrect": {
        "A": "Declaration order is secondary.",
        "B": "Not first by default.",
        "D": "Selection is deterministic."
      }
    }
  },
  {
    "id": "EXP-MS-0823",
    "component": "Handling Errors – Multiple on-error-continue",
    "difficulty": "Extreme",
    "question": "What happens if multiple on-error-continue handlers could match an error?",
    "options": {
      "A": "All handlers execute",
      "B": "Most specific handler executes",
      "C": "Global handler executes",
      "D": "Error is swallowed silently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only the most specific handler is executed.",
      "incorrect": {
        "A": "Handlers do not chain.",
        "C": "Global is fallback.",
        "D": "Handling is explicit."
      }
    }
  },
  {
    "id": "EXP-MS-0824",
    "component": "Handling Errors – Error Handler Ordering",
    "difficulty": "Extreme",
    "question": "When does handler declaration order matter?",
    "options": {
      "A": "Never",
      "B": "Only when error types have equal specificity",
      "C": "Only for global handlers",
      "D": "Only in Try scopes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Order matters when specificity cannot resolve the handler.",
      "incorrect": {
        "A": "Order can matter.",
        "C": "Applies everywhere.",
        "D": "Not limited to Try."
      }
    }
  },
  {
    "id": "EXP-MS-0825",
    "component": "Handling Errors – Error Payload Availability",
    "difficulty": "Extreme",
    "question": "Inside an error handler, what does payload represent?",
    "options": {
      "A": "Always null",
      "B": "Original payload at failure point",
      "C": "Error object",
      "D": "Last successful payload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Payload remains as it was when the error occurred.",
      "incorrect": {
        "A": "Payload is preserved.",
        "C": "Error object is in error variable.",
        "D": "Payload is not rolled back."
      }
    }
  },

  {
    "id": "EXP-MS-0826",
    "component": "Handling Errors – error Variable Scope",
    "difficulty": "Extreme",
    "question": "Where is the error variable available?",
    "options": {
      "A": "Entire application",
      "B": "Only inside error handlers",
      "C": "Inside all flows",
      "D": "Only global handlers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The error variable exists only within error handlers.",
      "incorrect": {
        "A": "Not global.",
        "C": "Not available in normal flow.",
        "D": "Also available in local handlers."
      }
    }
  },
  {
    "id": "EXP-MS-0827",
    "component": "Handling Errors – error.errorType Structure",
    "difficulty": "Extreme",
    "question": "What does error.errorType contain?",
    "options": {
      "A": "HTTP status code",
      "B": "Namespace and identifier of the error",
      "C": "Stack trace",
      "D": "Connector name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "errorType is composed of namespace and identifier.",
      "incorrect": {
        "A": "Status is separate.",
        "C": "Stack trace is elsewhere.",
        "D": "Connector name is not included."
      }
    }
  },
  {
    "id": "EXP-MS-0828",
    "component": "Handling Errors – Raising Custom Errors",
    "difficulty": "Extreme",
    "question": "What is the effect of the Raise Error component?",
    "options": {
      "A": "Logs and continues",
      "B": "Throws a custom error type",
      "C": "Retries the flow",
      "D": "Ends application"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Raise Error explicitly throws a custom error.",
      "incorrect": {
        "A": "Flow does not continue.",
        "C": "Retries are not automatic.",
        "D": "Application continues."
      }
    }
  },
  {
    "id": "EXP-MS-0829",
    "component": "Handling Errors – Raise Error vs Throw",
    "difficulty": "Extreme",
    "question": "Why prefer Raise Error over throwing Java exceptions?",
    "options": {
      "A": "Better performance",
      "B": "Integrates with Mule error type system",
      "C": "Avoids stack traces",
      "D": "Enables retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Raise Error works with Mule’s structured error system.",
      "incorrect": {
        "A": "Performance difference is negligible.",
        "C": "Stack traces still exist.",
        "D": "Retries are separate."
      }
    }
  },
  {
    "id": "EXP-MS-0830",
    "component": "Handling Errors – Error Mapping Precedence",
    "difficulty": "Extreme",
    "question": "If a processor has error-mapping configured and throws an error, what happens?",
    "options": {
      "A": "Original error type is preserved",
      "B": "Mapped error type replaces original",
      "C": "Both error types are available",
      "D": "Error is ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mapped error type replaces the original.",
      "incorrect": {
        "A": "Original is overridden.",
        "C": "Only mapped type is exposed.",
        "D": "Error is not ignored."
      }
    }
  },

  {
    "id": "EXP-MS-0831",
    "component": "Handling Errors – Transaction + on-error-continue",
    "difficulty": "Extreme",
    "question": "What happens if on-error-continue executes inside a transaction?",
    "options": {
      "A": "Transaction commits automatically",
      "B": "Transaction rolls back automatically",
      "C": "Transaction outcome depends on configuration",
      "D": "Transaction is ignored"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Transaction behavior depends on transactional scope settings.",
      "incorrect": {
        "A": "Not always committed.",
        "B": "Not always rolled back.",
        "D": "Transactions still apply."
      }
    }
  },
  {
    "id": "EXP-MS-0832",
    "component": "Handling Errors – Error Handler Logging Pitfall",
    "difficulty": "Extreme",
    "question": "Why is logging full stack traces in every error handler risky?",
    "options": {
      "A": "Compilation error",
      "B": "Log flooding and performance impact",
      "C": "Loss of payload",
      "D": "Disables retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive logging degrades performance and observability.",
      "incorrect": {
        "A": "Syntax is valid.",
        "C": "Payload unaffected.",
        "D": "Retries unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0833",
    "component": "Handling Errors – Global Handler Anti-Pattern",
    "difficulty": "Extreme",
    "question": "What is a common global error handler anti-pattern?",
    "options": {
      "A": "Mapping HTTP status codes",
      "B": "Handling all errors generically",
      "C": "Logging correlationId",
      "D": "Returning structured error payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Generic handling hides specific failure causes.",
      "incorrect": {
        "A": "Status mapping is recommended.",
        "C": "Correlation improves tracing.",
        "D": "Structured payloads are good practice."
      }
    }
  },
  {
    "id": "EXP-MS-0834",
    "component": "Handling Errors – Error Handler Reentrancy",
    "difficulty": "Extreme",
    "question": "What risk exists if an error handler itself throws an error?",
    "options": {
      "A": "Error is ignored",
      "B": "Recursive error handling or escalation",
      "C": "Flow resumes",
      "D": "Transaction commits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Handlers can trigger further errors leading to escalation.",
      "incorrect": {
        "A": "Errors are not ignored.",
        "C": "Flow does not resume.",
        "D": "Transactions depend on scope."
      }
    }
  },
  {
    "id": "EXP-MS-0835",
    "component": "Handling Errors – Error vs Retry Strategy",
    "difficulty": "Extreme",
    "question": "Which errors should generally not be retried?",
    "options": {
      "A": "Timeouts",
      "B": "Authentication failures",
      "C": "Temporary network failures",
      "D": "Service unavailable"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Auth failures are not transient.",
      "incorrect": {
        "A": "May be transient.",
        "C": "Often transient.",
        "D": "May recover."
      }
    }
  },

  {
    "id": "EXP-MS-0836",
    "component": "Handling Errors – Error Payload Design",
    "difficulty": "Extreme",
    "question": "What is the primary goal of structured error payloads?",
    "options": {
      "A": "Reduce payload size",
      "B": "Enable consumers to react programmatically",
      "C": "Hide internal errors",
      "D": "Improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structured errors allow predictable client behavior.",
      "incorrect": {
        "A": "Size is secondary.",
        "C": "Errors should be transparent but safe.",
        "D": "Performance impact is minimal."
      }
    }
  },
  {
    "id": "EXP-MS-0837",
    "component": "Handling Errors – Error Handling Observability",
    "difficulty": "Extreme",
    "question": "What metric best indicates unhealthy error handling?",
    "options": {
      "A": "High throughput",
      "B": "High retry counts",
      "C": "Low latency",
      "D": "Large payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive retries often indicate systemic issues.",
      "incorrect": {
        "A": "Throughput alone is insufficient.",
        "C": "Latency may hide errors.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0838",
    "component": "Handling Errors – Error Strategy Consistency",
    "difficulty": "Extreme",
    "question": "Why should error handling be consistent across APIs?",
    "options": {
      "A": "For easier deployment",
      "B": "For predictable consumer behavior",
      "C": "To reduce code size",
      "D": "To improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency allows consumers to handle errors reliably.",
      "incorrect": {
        "A": "Deployment is unrelated.",
        "C": "Code size is secondary.",
        "D": "Performance impact is minimal."
      }
    }
  },
  {
    "id": "EXP-MS-0839",
    "component": "Handling Errors – Error Strategy Validation",
    "difficulty": "Extreme",
    "question": "How should error strategies be validated?",
    "options": {
      "A": "Manual testing",
      "B": "MUnit tests for each error scenario",
      "C": "Production monitoring only",
      "D": "Debugger sessions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MUnit enables deterministic testing of error paths.",
      "incorrect": {
        "A": "Manual testing is insufficient.",
        "C": "Monitoring is reactive.",
        "D": "Debugger is non-repeatable."
      }
    }
  },
  {
    "id": "EXP-MS-0840",
    "component": "Handling Errors – Error Domain Completion Marker",
    "difficulty": "Extreme",
    "question": "What best represents expert-level Mule error handling?",
    "options": {
      "A": "Single global handler",
      "B": "Intentional, specific, observable error strategies",
      "C": "Suppressing all errors",
      "D": "Retrying every failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert error handling is deliberate and observable.",
      "incorrect": {
        "A": "Too coarse-grained.",
        "C": "Hides issues.",
        "D": "Retries must be selective."
      }
    }
  },

  {
    "id": "EXP-MS-0841",
    "component": "Handling Errors – Error Handling Boundary Crossing",
    "difficulty": "Extreme",
    "question": "What happens when an error exits an API implementation flow?",
    "options": {
      "A": "It is swallowed",
      "B": "It propagates to the HTTP listener",
      "C": "It is converted automatically to 500",
      "D": "It restarts the flow"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors propagate to the listener for response handling.",
      "incorrect": {
        "A": "Errors are not swallowed.",
        "C": "Conversion depends on configuration.",
        "D": "Flows do not restart."
      }
    }
  },
  {
    "id": "EXP-MS-0842",
    "component": "Handling Errors – HTTP Listener Error Response",
    "difficulty": "Extreme",
    "question": "Where is the HTTP error response body typically defined?",
    "options": {
      "A": "on-error-continue",
      "B": "HTTP Listener error-response",
      "C": "Global error handler",
      "D": "Raise Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP Listener defines error-response configuration.",
      "incorrect": {
        "A": "Consumes errors but not response.",
        "C": "Global handler prepares error but not response body.",
        "D": "Raise Error throws errors only."
      }
    }
  },
  {
    "id": "EXP-MS-0843",
    "component": "Handling Errors – Error Handler Payload Mutation",
    "difficulty": "Extreme",
    "question": "Can an error handler modify the payload?",
    "options": {
      "A": "No, payload is immutable",
      "B": "Yes, payload can be transformed",
      "C": "Only global handlers can",
      "D": "Only with Raise Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error handlers can transform payloads.",
      "incorrect": {
        "A": "Payload is mutable.",
        "C": "Both local and global handlers can.",
        "D": "Raise Error is not required."
      }
    }
  },
  {
    "id": "EXP-MS-0844",
    "component": "Handling Errors – Error Handler Side-Effects Scope",
    "difficulty": "Extreme",
    "question": "Where should compensating actions be performed?",
    "options": {
      "A": "Main flow",
      "B": "Error handlers",
      "C": "Global configuration",
      "D": "Schedulers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error handlers are designed for compensation logic.",
      "incorrect": {
        "A": "Main flow assumes success.",
        "C": "Config is static.",
        "D": "Schedulers are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0845",
    "component": "Handling Errors – Error Handling Idempotency",
    "difficulty": "Extreme",
    "question": "Why should compensating actions be idempotent?",
    "options": {
      "A": "To improve performance",
      "B": "They may run multiple times",
      "C": "To reduce logging",
      "D": "To avoid payload mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries or re-throws can re-trigger handlers.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Logging is unrelated.",
        "D": "Mutation is allowed."
      }
    }
  },

  {
    "id": "EXP-MS-0846",
    "component": "Handling Errors – Error Handling Documentation",
    "difficulty": "Extreme",
    "question": "Why should error strategies be documented?",
    "options": {
      "A": "For certification",
      "B": "For consumer expectations and support",
      "C": "To reduce code",
      "D": "To improve runtime speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumers rely on documented error behavior.",
      "incorrect": {
        "A": "Certification is incidental.",
        "C": "Docs do not reduce code.",
        "D": "Docs do not affect runtime."
      }
    }
  },
  {
    "id": "EXP-MS-0847",
    "component": "Handling Errors – Error Strategy Evolution",
    "difficulty": "Extreme",
    "question": "When should error strategies be revisited?",
    "options": {
      "A": "Never",
      "B": "When upstream or downstream contracts change",
      "C": "Only during outages",
      "D": "Only before deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract changes can invalidate existing strategies.",
      "incorrect": {
        "A": "Strategies evolve.",
        "C": "Outages are reactive.",
        "D": "Post-deployment review is also needed."
      }
    }
  },
  {
    "id": "EXP-MS-0848",
    "component": "Handling Errors – Error vs Alerting",
    "difficulty": "Extreme",
    "question": "What should trigger alerting instead of retries?",
    "options": {
      "A": "Transient failures",
      "B": "Repeated systemic errors",
      "C": "Timeouts",
      "D": "Validation failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Systemic issues require human intervention.",
      "incorrect": {
        "A": "Transient issues may retry.",
        "C": "Timeouts may be transient.",
        "D": "Validation errors are expected."
      }
    }
  },
  {
    "id": "EXP-MS-0849",
    "component": "Handling Errors – Error Handling Governance",
    "difficulty": "Extreme",
    "question": "Why is centralized governance for error handling useful?",
    "options": {
      "A": "Improves compilation speed",
      "B": "Ensures consistency across teams",
      "C": "Reduces heap usage",
      "D": "Avoids error handlers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance ensures uniform error behavior.",
      "incorrect": {
        "A": "Compilation unaffected.",
        "C": "Memory unaffected.",
        "D": "Handlers are still required."
      }
    }
  },
  {
    "id": "EXP-MS-0850",
    "component": "Handling Errors – Error Domain Completion",
    "difficulty": "Extreme",
    "question": "What signals mature Mule error-handling practices?",
    "options": {
      "A": "Retry everything",
      "B": "Clear distinction between business faults and system errors",
      "C": "Single global handler",
      "D": "Suppressing error details"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Separating business faults from system errors is key to maturity.",
      "incorrect": {
        "A": "Retries must be selective.",
        "C": "Too coarse-grained.",
        "D": "Suppressing details reduces observability."
      }
    }
  },
  {
    "id": "EXP-MS-0851",
    "component": "Handling Errors – Error Propagation to API Layer",
    "difficulty": "Extreme",
    "question": "When an error propagates out of an API implementation flow, what determines the final HTTP status code?",
    "options": {
      "A": "The error type namespace",
      "B": "HTTP Listener error-response configuration",
      "C": "The last processor executed",
      "D": "The global error handler name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP Listener error-response controls the final HTTP status.",
      "incorrect": {
        "A": "Namespace alone is insufficient.",
        "C": "Processors do not decide status.",
        "D": "Handler name is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0852",
    "component": "Handling Errors – Error Object Mutability",
    "difficulty": "Extreme",
    "question": "Can the Mule error object itself be modified inside an error handler?",
    "options": {
      "A": "Yes, fully mutable",
      "B": "Only description can be changed",
      "C": "No, error object is immutable",
      "D": "Only errorType can be changed"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The error object is immutable; you can only read it.",
      "incorrect": {
        "A": "Direct mutation is not allowed.",
        "B": "Description cannot be mutated directly.",
        "D": "errorType is immutable."
      }
    }
  },
  {
    "id": "EXP-MS-0853",
    "component": "Handling Errors – Error Masking Risk",
    "difficulty": "Extreme",
    "question": "What is the primary risk of mapping all internal errors to a single custom error?",
    "options": {
      "A": "Compilation failure",
      "B": "Loss of diagnostic granularity",
      "C": "Transaction rollback",
      "D": "Increased latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Over-mapping hides the true root cause.",
      "incorrect": {
        "A": "Mapping is valid.",
        "C": "Rollback depends on propagation.",
        "D": "Latency is not the main issue."
      }
    }
  },
  {
    "id": "EXP-MS-0854",
    "component": "Handling Errors – Error Handler Performance",
    "difficulty": "Extreme",
    "question": "Which practice most negatively impacts error-handling performance?",
    "options": {
      "A": "Selective error mapping",
      "B": "Heavy synchronous calls inside handlers",
      "C": "Using errorType matching",
      "D": "Returning structured error payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blocking calls inside handlers delay failure resolution.",
      "incorrect": {
        "A": "Mapping is inexpensive.",
        "C": "Matching is efficient.",
        "D": "Payload structure has minimal cost."
      }
    }
  },
  {
    "id": "EXP-MS-0855",
    "component": "Handling Errors – Error vs Exception Strategy",
    "difficulty": "Extreme",
    "question": "Why should Mule errors be preferred over Java exceptions?",
    "options": {
      "A": "Better performance",
      "B": "They integrate with Mule’s error-type system",
      "C": "They suppress stack traces",
      "D": "They auto-retry"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mule errors are first-class and type-aware.",
      "incorrect": {
        "A": "Performance difference is negligible.",
        "C": "Stack traces still exist.",
        "D": "Retries are explicit."
      }
    }
  },

  {
    "id": "EXP-MS-0856",
    "component": "Handling Errors – Error Handling in Subflows",
    "difficulty": "Extreme",
    "question": "Where must error handlers be defined for subflows?",
    "options": {
      "A": "Inside the subflow",
      "B": "In the calling flow",
      "C": "Globally only",
      "D": "In mule-artifact.json"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Subflows do not have their own error handlers.",
      "incorrect": {
        "A": "Subflows cannot define handlers.",
        "C": "Global is fallback only.",
        "D": "Not configurable there."
      }
    }
  },
  {
    "id": "EXP-MS-0857",
    "component": "Handling Errors – Error Handling and Flow-Ref",
    "difficulty": "Extreme",
    "question": "If a flow-ref throws an error, where is it handled first?",
    "options": {
      "A": "Inside the referenced flow",
      "B": "In the calling flow",
      "C": "Global handler",
      "D": "HTTP Listener"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors propagate back to the caller flow.",
      "incorrect": {
        "A": "Referenced flow has no handler boundary.",
        "C": "Global is fallback.",
        "D": "Listener handles only uncaught errors."
      }
    }
  },
  {
    "id": "EXP-MS-0858",
    "component": "Handling Errors – Error Handling and Async",
    "difficulty": "Extreme",
    "question": "How are errors inside async scopes surfaced by default?",
    "options": {
      "A": "Propagated to the main flow",
      "B": "Logged but not propagated",
      "C": "Converted to payload",
      "D": "Ignored completely"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async errors do not propagate to the caller.",
      "incorrect": {
        "A": "Main flow continues normally.",
        "C": "No conversion occurs.",
        "D": "They are logged."
      }
    }
  },
  {
    "id": "EXP-MS-0859",
    "component": "Handling Errors – Error Handler Idempotency",
    "difficulty": "Extreme",
    "question": "Why must compensating logic inside error handlers be idempotent?",
    "options": {
      "A": "To improve throughput",
      "B": "Handlers may run multiple times",
      "C": "To reduce memory usage",
      "D": "To avoid logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries or rethrows can re-execute handlers.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Memory impact is minimal.",
        "D": "Logging is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0860",
    "component": "Handling Errors – Error Handling in Batch Jobs",
    "difficulty": "Extreme",
    "question": "How are record-level errors typically handled in batch jobs?",
    "options": {
      "A": "Stop entire batch",
      "B": "Route failed records to on-record-failure",
      "C": "Ignore errors",
      "D": "Retry entire batch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch jobs isolate record failures.",
      "incorrect": {
        "A": "Batch continues by default.",
        "C": "Errors are not ignored.",
        "D": "Retries are record-scoped."
      }
    }
  },

  {
    "id": "EXP-MS-0861",
    "component": "Handling Errors – Batch Error Aggregation",
    "difficulty": "Extreme",
    "question": "What happens if many records fail in a batch job?",
    "options": {
      "A": "Job fails immediately",
      "B": "Failures are aggregated and reported",
      "C": "Remaining records are skipped",
      "D": "Batch restarts automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch jobs collect and report failures.",
      "incorrect": {
        "A": "Job continues.",
        "C": "Other records still process.",
        "D": "Restart is manual."
      }
    }
  },
  {
    "id": "EXP-MS-0862",
    "component": "Handling Errors – Error vs Validation",
    "difficulty": "Extreme",
    "question": "Why should validation failures often be modeled as business errors?",
    "options": {
      "A": "They are unexpected",
      "B": "They represent valid client mistakes",
      "C": "They should trigger retries",
      "D": "They are system failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation failures are expected business outcomes.",
      "incorrect": {
        "A": "They are expected.",
        "C": "Retries are not appropriate.",
        "D": "They are not system errors."
      }
    }
  },
  {
    "id": "EXP-MS-0863",
    "component": "Handling Errors – Error Handling and SLA",
    "difficulty": "Extreme",
    "question": "Why must error handling consider API SLAs?",
    "options": {
      "A": "To increase throughput",
      "B": "To avoid excessive retries and delays",
      "C": "To reduce code",
      "D": "To simplify logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries can violate response-time SLAs.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Code size is irrelevant.",
        "D": "Logging is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0864",
    "component": "Handling Errors – Error Handling Metrics",
    "difficulty": "Extreme",
    "question": "Which metric best indicates fragile error handling?",
    "options": {
      "A": "High CPU usage",
      "B": "High retry counts with low success",
      "C": "Low memory usage",
      "D": "High throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated retries signal systemic problems.",
      "incorrect": {
        "A": "CPU alone is insufficient.",
        "C": "Memory is unrelated.",
        "D": "Throughput can hide failures."
      }
    }
  },
  {
    "id": "EXP-MS-0865",
    "component": "Handling Errors – Error Strategy Drift",
    "difficulty": "Extreme",
    "question": "What causes error strategy drift over time?",
    "options": {
      "A": "Stable contracts",
      "B": "Incremental changes without governance",
      "C": "MUnit testing",
      "D": "Consistent standards"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ungoverned changes erode consistency.",
      "incorrect": {
        "A": "Stability prevents drift.",
        "C": "Testing reduces drift.",
        "D": "Standards enforce consistency."
      }
    }
  },

  {
    "id": "EXP-MS-0866",
    "component": "Handling Errors – Error Handling and Security",
    "difficulty": "Extreme",
    "question": "Why should internal error details be masked in API responses?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent information leakage",
      "C": "To improve performance",
      "D": "To simplify clients"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Detailed errors can expose internal implementation.",
      "incorrect": {
        "A": "Size is secondary.",
        "C": "Performance impact is minimal.",
        "D": "Clients still need structured errors."
      }
    }
  },
  {
    "id": "EXP-MS-0867",
    "component": "Handling Errors – Error Handling and Observability",
    "difficulty": "Extreme",
    "question": "What improves observability of error trends?",
    "options": {
      "A": "Verbose stack traces only",
      "B": "Consistent error codes and metrics",
      "C": "Suppressing errors",
      "D": "Manual log inspection"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structured codes enable aggregation and alerting.",
      "incorrect": {
        "A": "Verbose logs alone are insufficient.",
        "C": "Suppressing errors hides issues.",
        "D": "Manual inspection does not scale."
      }
    }
  },
  {
    "id": "EXP-MS-0868",
    "component": "Handling Errors – Error Handling and Versioning",
    "difficulty": "Extreme",
    "question": "Why must error contracts be versioned?",
    "options": {
      "A": "To reduce runtime errors",
      "B": "To avoid breaking consumers",
      "C": "To simplify code",
      "D": "To improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients depend on stable error structures.",
      "incorrect": {
        "A": "Runtime errors are separate.",
        "C": "Code simplicity is secondary.",
        "D": "Performance unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0869",
    "component": "Handling Errors – Error Handling Governance Final",
    "difficulty": "Extreme",
    "question": "What is the strongest indicator of mature Mule error governance?",
    "options": {
      "A": "Single global handler",
      "B": "Documented, tested, and enforced error standards",
      "C": "Retrying all failures",
      "D": "Suppressing error details"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance requires standards, testing, and enforcement.",
      "incorrect": {
        "A": "Too simplistic.",
        "C": "Retries must be selective.",
        "D": "Suppressing details reduces transparency."
      }
    }
  },
  {
    "id": "EXP-MS-0870",
    "component": "Handling Errors – Error Domain Closure",
    "difficulty": "Extreme",
    "question": "What marks completion of a robust Mule error-handling design?",
    "options": {
      "A": "No errors observed",
      "B": "Predictable behavior under failure",
      "C": "Maximum retries",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictability under failure defines robustness.",
      "incorrect": {
        "A": "Absence of errors is unrealistic.",
        "C": "Retries are situational.",
        "D": "Minimal logging reduces visibility."
      }
    }
  },

  {
    "id": "EXP-MS-0871",
    "component": "Handling Errors – Error Escalation Strategy",
    "difficulty": "Extreme",
    "question": "When should errors be escalated instead of handled locally?",
    "options": {
      "A": "When retry succeeds",
      "B": "When local context cannot resolve the failure",
      "C": "When payload is large",
      "D": "When logging is verbose"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unresolvable errors must propagate upward.",
      "incorrect": {
        "A": "Success negates escalation.",
        "C": "Payload size is irrelevant.",
        "D": "Logging verbosity is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0872",
    "component": "Handling Errors – Error Handling and Idempotent APIs",
    "difficulty": "Extreme",
    "question": "Why do idempotent APIs simplify error handling?",
    "options": {
      "A": "They eliminate errors",
      "B": "They allow safe retries",
      "C": "They improve performance",
      "D": "They reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotency ensures retries do not duplicate effects.",
      "incorrect": {
        "A": "Errors still occur.",
        "C": "Performance impact is indirect.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0873",
    "component": "Handling Errors – Error Handling and CloudHub",
    "difficulty": "Extreme",
    "question": "Why is centralized logging critical for CloudHub error handling?",
    "options": {
      "A": "To reduce heap usage",
      "B": "Instances are ephemeral",
      "C": "To speed deployments",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ephemeral workers require centralized logs.",
      "incorrect": {
        "A": "Heap usage is unrelated.",
        "C": "Deployment speed is unrelated.",
        "D": "Retries are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0874",
    "component": "Handling Errors – Error Handling and Scaling",
    "difficulty": "Extreme",
    "question": "How does poor error handling impact horizontal scaling?",
    "options": {
      "A": "No impact",
      "B": "Amplifies failure storms across instances",
      "C": "Improves resilience",
      "D": "Reduces concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries across instances can amplify failures.",
      "incorrect": {
        "A": "Impact is significant.",
        "C": "Poor handling reduces resilience.",
        "D": "Concurrency is not directly reduced."
      }
    }
  },
  {
    "id": "EXP-MS-0875",
    "component": "Handling Errors – Error Handling Final Marker",
    "difficulty": "Extreme",
    "question": "What is the ultimate goal of Mule error handling?",
    "options": {
      "A": "Hide failures",
      "B": "Provide predictable, safe failure behavior",
      "C": "Retry indefinitely",
      "D": "Eliminate logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable failure behavior enables resilient systems.",
      "incorrect": {
        "A": "Failures must be visible.",
        "C": "Retries must be bounded.",
        "D": "Logging is essential."
      }
    }
  },

  {
    "id": "EXP-MS-0876",
    "component": "Handling Errors – Error Handling Review Trigger",
    "difficulty": "Extreme",
    "question": "What should trigger a review of error handling design?",
    "options": {
      "A": "Stable operations",
      "B": "Recurring incidents of the same error",
      "C": "Low traffic",
      "D": "Minor refactoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated incidents indicate design gaps.",
      "incorrect": {
        "A": "Stability needs no review.",
        "C": "Traffic volume is irrelevant.",
        "D": "Minor refactors are insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0877",
    "component": "Handling Errors – Error Handling and DR",
    "difficulty": "Extreme",
    "question": "Why must error handling be considered in disaster recovery?",
    "options": {
      "A": "To improve performance",
      "B": "To handle partial failures gracefully",
      "C": "To reduce code size",
      "D": "To simplify deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DR scenarios often involve partial system failures.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Code size is irrelevant.",
        "D": "Deployment simplicity is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0878",
    "component": "Handling Errors – Error Handling and Chaos Testing",
    "difficulty": "Extreme",
    "question": "Why use chaos testing for error handling?",
    "options": {
      "A": "To reduce latency",
      "B": "To validate resilience under failure",
      "C": "To improve code readability",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Chaos testing validates behavior under real failures.",
      "incorrect": {
        "A": "Latency is unrelated.",
        "C": "Readability is unrelated.",
        "D": "Retries are not avoided."
      }
    }
  },
  {
    "id": "EXP-MS-0879",
    "component": "Handling Errors – Error Handling and Postmortems",
    "difficulty": "Extreme",
    "question": "What is the purpose of postmortems in error handling?",
    "options": {
      "A": "Assign blame",
      "B": "Improve future resilience",
      "C": "Reduce logging",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Postmortems drive systemic improvements.",
      "incorrect": {
        "A": "Blame is counterproductive.",
        "C": "Logging remains important.",
        "D": "Documentation is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0880",
    "component": "Handling Errors – Error Handling Section Completion",
    "difficulty": "Extreme",
    "question": "What conclusively indicates expert-level Mule error handling?",
    "options": {
      "A": "Zero production errors",
      "B": "Resilient, observable, and well-governed failure behavior",
      "C": "Maximum retries everywhere",
      "D": "Minimal error responses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert handling focuses on resilience and observability.",
      "incorrect": {
        "A": "Zero errors is unrealistic.",
        "C": "Retries must be selective.",
        "D": "Minimal responses reduce usefulness."
      }
    }
  },
  {
    "id": "EXP-MS-0881",
    "component": "Debugging & Troubleshooting – Logger Placement",
    "difficulty": "Extreme",
    "question": "Where should loggers be placed to best trace Mule event mutation?",
    "options": {
      "A": "Only at flow start",
      "B": "Before and after critical processors",
      "C": "Only inside error handlers",
      "D": "Only at flow end"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Strategic placement shows how payload/vars change.",
      "incorrect": {
        "A": "Insufficient visibility.",
        "C": "Misses normal execution.",
        "D": "Too late for root cause."
      }
    }
  },
  {
    "id": "EXP-MS-0882",
    "component": "Debugging & Troubleshooting – Debugger Side Effects",
    "difficulty": "Extreme",
    "question": "Why should Mule debugger not be used in performance testing?",
    "options": {
      "A": "It changes execution timing",
      "B": "It disables logging",
      "C": "It corrupts payload",
      "D": "It breaks compilation"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Debugger alters thread timing and flow behavior.",
      "incorrect": {
        "B": "Logging remains active.",
        "C": "Payload is not corrupted.",
        "D": "Compilation unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0883",
    "component": "Debugging & Troubleshooting – Breakpoint Scope",
    "difficulty": "Extreme",
    "question": "What is a key risk of leaving breakpoints enabled in deployed environments?",
    "options": {
      "A": "Compilation failure",
      "B": "Thread blocking and request backlog",
      "C": "Memory leaks",
      "D": "Payload mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Breakpoints pause execution and block threads.",
      "incorrect": {
        "A": "Build succeeds.",
        "C": "Not a direct effect.",
        "D": "Payload unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0884",
    "component": "Debugging & Troubleshooting – Log Level Strategy",
    "difficulty": "Extreme",
    "question": "Which log level should be used for high-volume payload dumps in production?",
    "options": {
      "A": "INFO",
      "B": "DEBUG",
      "C": "ERROR",
      "D": "WARN"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DEBUG can be disabled to avoid performance impact.",
      "incorrect": {
        "A": "Too noisy for prod.",
        "C": "Incorrect semantic.",
        "D": "Warnings are not verbose."
      }
    }
  },
  {
    "id": "EXP-MS-0885",
    "component": "Debugging & Troubleshooting – Correlation IDs",
    "difficulty": "Extreme",
    "question": "Why are correlation IDs critical in distributed Mule applications?",
    "options": {
      "A": "They improve performance",
      "B": "They enable end-to-end traceability",
      "C": "They reduce payload size",
      "D": "They enforce ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs link logs across systems.",
      "incorrect": {
        "A": "Performance unaffected.",
        "C": "Payload size unchanged.",
        "D": "Ordering is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0886",
    "component": "Debugging & Troubleshooting – Log Flooding Risk",
    "difficulty": "Extreme",
    "question": "What is the main risk of excessive logging inside loops?",
    "options": {
      "A": "Compilation error",
      "B": "I/O bottlenecks and latency",
      "C": "Lost variables",
      "D": "Payload truncation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High I/O severely impacts performance.",
      "incorrect": {
        "A": "Code compiles.",
        "C": "Variables unaffected.",
        "D": "Payload intact."
      }
    }
  },
  {
    "id": "EXP-MS-0887",
    "component": "Debugging & Troubleshooting – Stack Trace Interpretation",
    "difficulty": "Extreme",
    "question": "Which part of a Mule stack trace is most useful for root cause analysis?",
    "options": {
      "A": "The first line",
      "B": "The deepest application-level frame",
      "C": "Connector internal frames",
      "D": "Thread metadata"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The deepest app frame shows where failure originated.",
      "incorrect": {
        "A": "Often generic.",
        "C": "Too low-level.",
        "D": "Contextual only."
      }
    }
  },
  {
    "id": "EXP-MS-0888",
    "component": "Debugging & Troubleshooting – Reproducing Issues",
    "difficulty": "Extreme",
    "question": "What is the most reliable way to reproduce a production issue?",
    "options": {
      "A": "Guessing inputs",
      "B": "Using captured payloads and attributes",
      "C": "Increasing log level",
      "D": "Restarting the app"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Captured data recreates exact conditions.",
      "incorrect": {
        "A": "Unreliable.",
        "C": "Logging is observational.",
        "D": "Restarts hide issues."
      }
    }
  },
  {
    "id": "EXP-MS-0889",
    "component": "Debugging & Troubleshooting – MUnit Failure Diagnosis",
    "difficulty": "Extreme",
    "question": "What usually indicates a brittle MUnit test?",
    "options": {
      "A": "Mocking connectors",
      "B": "Asserting exact payload ordering unnecessarily",
      "C": "Using error assertions",
      "D": "Validating variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Over-specific assertions break on harmless changes.",
      "incorrect": {
        "A": "Mocking is best practice.",
        "C": "Error assertions are correct.",
        "D": "Variable validation is stable."
      }
    }
  },
  {
    "id": "EXP-MS-0890",
    "component": "Debugging & Troubleshooting – Heisenbugs",
    "difficulty": "Extreme",
    "question": "Why are concurrency-related bugs hard to debug?",
    "options": {
      "A": "They always crash",
      "B": "They may disappear when observed",
      "C": "They are syntax errors",
      "D": "They occur at compile time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timing changes during observation hide the issue.",
      "incorrect": {
        "A": "They are intermittent.",
        "C": "Not syntax-related.",
        "D": "They occur at runtime."
      }
    }
  },

  {
    "id": "EXP-MS-0891",
    "component": "Debugging & Troubleshooting – Thread Dump Usage",
    "difficulty": "Extreme",
    "question": "When should thread dumps be captured?",
    "options": {
      "A": "During startup",
      "B": "When system is unresponsive or slow",
      "C": "After deployment",
      "D": "Only during tests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Thread dumps reveal blocking and deadlocks.",
      "incorrect": {
        "A": "Startup rarely shows issues.",
        "C": "Not indicative.",
        "D": "Tests are controlled."
      }
    }
  },
  {
    "id": "EXP-MS-0892",
    "component": "Debugging & Troubleshooting – Memory Leak Detection",
    "difficulty": "Extreme",
    "question": "Which symptom most strongly indicates a memory leak?",
    "options": {
      "A": "High CPU usage",
      "B": "Steadily increasing heap usage",
      "C": "Slow startup",
      "D": "High throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Leaks cause unbounded heap growth.",
      "incorrect": {
        "A": "CPU is unrelated.",
        "C": "Startup is unrelated.",
        "D": "Throughput may remain high."
      }
    }
  },
  {
    "id": "EXP-MS-0893",
    "component": "Debugging & Troubleshooting – Streaming Debug Pitfall",
    "difficulty": "Extreme",
    "question": "Why is debugging streaming payloads risky?",
    "options": {
      "A": "They auto-reset",
      "B": "They may be consumed during inspection",
      "C": "They are immutable",
      "D": "They are copied"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inspecting streams can consume them.",
      "incorrect": {
        "A": "No auto-reset.",
        "C": "Immutability irrelevant.",
        "D": "No automatic copy."
      }
    }
  },
  {
    "id": "EXP-MS-0894",
    "component": "Debugging & Troubleshooting – Connector Timeouts",
    "difficulty": "Extreme",
    "question": "What does a sudden spike in connector timeouts usually indicate?",
    "options": {
      "A": "Compilation issue",
      "B": "Downstream system degradation",
      "C": "Memory leak",
      "D": "DataWeave error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeouts reflect slow or unavailable downstream systems.",
      "incorrect": {
        "A": "Compilation unaffected.",
        "C": "Leaks manifest differently.",
        "D": "DW errors are immediate."
      }
    }
  },
  {
    "id": "EXP-MS-0895",
    "component": "Debugging & Troubleshooting – Dead Letter Queues",
    "difficulty": "Extreme",
    "question": "Why are Dead Letter Queues valuable in troubleshooting?",
    "options": {
      "A": "They improve throughput",
      "B": "They preserve failed messages for analysis",
      "C": "They retry automatically",
      "D": "They suppress errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DLQs retain failed messages intact.",
      "incorrect": {
        "A": "Throughput unaffected.",
        "C": "Retries are manual.",
        "D": "Errors remain visible."
      }
    }
  },

  {
    "id": "EXP-MS-0896",
    "component": "Debugging & Troubleshooting – Partial Failure Analysis",
    "difficulty": "Extreme",
    "question": "What is the hardest class of production issue to diagnose?",
    "options": {
      "A": "Complete outages",
      "B": "Partial and intermittent failures",
      "C": "Syntax errors",
      "D": "Startup failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Intermittent failures lack consistent signals.",
      "incorrect": {
        "A": "Outages are obvious.",
        "C": "Syntax errors are caught early.",
        "D": "Startup failures are deterministic."
      }
    }
  },
  {
    "id": "EXP-MS-0897",
    "component": "Debugging & Troubleshooting – Observability Signals",
    "difficulty": "Extreme",
    "question": "Which combination best supports troubleshooting?",
    "options": {
      "A": "Logs only",
      "B": "Metrics, logs, and traces",
      "C": "Alerts only",
      "D": "Dashboards only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "All three provide complementary insights.",
      "incorrect": {
        "A": "Logs alone are insufficient.",
        "C": "Alerts lack context.",
        "D": "Dashboards summarize only."
      }
    }
  },
  {
    "id": "EXP-MS-0898",
    "component": "Debugging & Troubleshooting – Root Cause Bias",
    "difficulty": "Extreme",
    "question": "What cognitive bias most commonly affects debugging?",
    "options": {
      "A": "Recency bias",
      "B": "Confirmation bias",
      "C": "Availability bias",
      "D": "Anchoring bias"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Engineers seek evidence confirming initial assumptions.",
      "incorrect": {
        "A": "Less common.",
        "C": "Secondary effect.",
        "D": "Can occur but less dominant."
      }
    }
  },
  {
    "id": "EXP-MS-0899",
    "component": "Debugging & Troubleshooting – Fix Verification",
    "difficulty": "Extreme",
    "question": "What best verifies a bug fix?",
    "options": {
      "A": "Successful deployment",
      "B": "Reproducing and eliminating the failure condition",
      "C": "Code review approval",
      "D": "No new alerts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Verification requires controlled reproduction.",
      "incorrect": {
        "A": "Deployment alone proves nothing.",
        "C": "Reviews are insufficient.",
        "D": "Alerts may lag."
      }
    }
  },
  {
    "id": "EXP-MS-0900",
    "component": "Debugging & Troubleshooting – Section Completion",
    "difficulty": "Extreme",
    "question": "What defines expert-level troubleshooting in Mule applications?",
    "options": {
      "A": "Fast reaction time",
      "B": "Systematic, evidence-driven diagnosis",
      "C": "Extensive logging",
      "D": "Frequent restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expert troubleshooting relies on disciplined analysis.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Logs must be interpreted.",
        "D": "Restarts mask issues."
      }
    }
  },

  {
    "id": "EXP-MS-0901",
    "component": "Debugging & Troubleshooting – Prod vs Test Parity",
    "difficulty": "Extreme",
    "question": "Why is environment parity important for debugging?",
    "options": {
      "A": "Reduces deployment time",
      "B": "Ensures issues reproduce consistently",
      "C": "Improves throughput",
      "D": "Reduces logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Differences hide or create issues.",
      "incorrect": {
        "A": "Deployment speed is unrelated.",
        "C": "Throughput unaffected.",
        "D": "Logging is independent."
      }
    }
  },
  {
    "id": "EXP-MS-0902",
    "component": "Debugging & Troubleshooting – Config Drift",
    "difficulty": "Extreme",
    "question": "What is a common cause of hard-to-diagnose production bugs?",
    "options": {
      "A": "Code complexity",
      "B": "Configuration drift between environments",
      "C": "High traffic",
      "D": "Strict validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Drift causes behavior differences.",
      "incorrect": {
        "A": "Complexity alone is insufficient.",
        "C": "Traffic exposes but does not cause bugs.",
        "D": "Validation prevents bugs."
      }
    }
  },
  {
    "id": "EXP-MS-0903",
    "component": "Debugging & Troubleshooting – Safe Debugging Principle",
    "difficulty": "Extreme",
    "question": "What principle should guide debugging in production?",
    "options": {
      "A": "Change as much as needed",
      "B": "Minimize blast radius",
      "C": "Disable error handling",
      "D": "Increase retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Production debugging must be minimally invasive.",
      "incorrect": {
        "A": "Risky in prod.",
        "C": "Dangerous.",
        "D": "Retries can worsen issues."
      }
    }
  },
  {
    "id": "EXP-MS-0904",
    "component": "Debugging & Troubleshooting – Section Marker",
    "difficulty": "Extreme",
    "question": "What marks completion of effective troubleshooting practices?",
    "options": {
      "A": "No incidents",
      "B": "Repeatable diagnosis and prevention",
      "C": "Maximum monitoring",
      "D": "Minimal code changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeatability and prevention indicate maturity.",
      "incorrect": {
        "A": "Incidents are inevitable.",
        "C": "Monitoring alone is insufficient.",
        "D": "Change size is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0905",
    "component": "Debugging & Troubleshooting – Knowledge Sharing",
    "difficulty": "Extreme",
    "question": "Why should troubleshooting outcomes be documented?",
    "options": {
      "A": "For audits",
      "B": "To accelerate future incident resolution",
      "C": "To reduce code size",
      "D": "To satisfy tooling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation prevents repeated mistakes.",
      "incorrect": {
        "A": "Audits are secondary.",
        "C": "Code size unaffected.",
        "D": "Tools do not require it."
      }
    }
  },

  {
    "id": "EXP-MS-0906",
    "component": "Debugging & Troubleshooting – Post-Incident Review",
    "difficulty": "Extreme",
    "question": "What is the main goal of post-incident reviews?",
    "options": {
      "A": "Assign responsibility",
      "B": "Improve system resilience",
      "C": "Reduce logging",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reviews focus on systemic improvements.",
      "incorrect": {
        "A": "Blame is counterproductive.",
        "C": "Logging remains important.",
        "D": "Documentation is essential."
      }
    }
  },
  {
    "id": "EXP-MS-0907",
    "component": "Debugging & Troubleshooting – Debugging Automation",
    "difficulty": "Extreme",
    "question": "What is the biggest benefit of automated diagnostics?",
    "options": {
      "A": "Lower memory usage",
      "B": "Faster mean time to resolution",
      "C": "Fewer deployments",
      "D": "Less code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation speeds detection and diagnosis.",
      "incorrect": {
        "A": "Memory unaffected.",
        "C": "Deployments are separate.",
        "D": "Code volume unchanged."
      }
    }
  },
  {
    "id": "EXP-MS-0908",
    "component": "Debugging & Troubleshooting – Section End Marker",
    "difficulty": "Extreme",
    "question": "What ultimately defines mastery of debugging in Mule?",
    "options": {
      "A": "Knowing all tools",
      "B": "Consistently restoring service with minimal impact",
      "C": "Extensive logging",
      "D": "Avoiding failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mastery is measured by outcome and impact.",
      "incorrect": {
        "A": "Tools are means, not goal.",
        "C": "Logs alone are insufficient.",
        "D": "Failures are inevitable."
      }
    }
  },
  {
    "id": "EXP-MS-0909",
    "component": "Debugging & Troubleshooting – Heap Dump Timing",
    "difficulty": "Extreme",
    "question": "When is the most useful time to capture a heap dump for memory analysis?",
    "options": {
      "A": "At application startup",
      "B": "Immediately after OutOfMemoryError",
      "C": "After application restart",
      "D": "During idle periods"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Heap dump at failure preserves leaking objects.",
      "incorrect": {
        "A": "Startup heap is clean.",
        "C": "Restart clears evidence.",
        "D": "Idle heap hides issues."
      }
    }
  },
  {
    "id": "EXP-MS-0910",
    "component": "Debugging & Troubleshooting – CPU Profiling Pitfall",
    "difficulty": "Extreme",
    "question": "Why should CPU profiling be used cautiously in production?",
    "options": {
      "A": "It disables logging",
      "B": "It introduces execution overhead",
      "C": "It corrupts memory",
      "D": "It breaks transactions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Profiling adds overhead and alters timing.",
      "incorrect": {
        "A": "Logging remains intact.",
        "C": "Memory is not corrupted.",
        "D": "Transactions remain valid."
      }
    }
  },
  {
    "id": "EXP-MS-0911",
    "component": "Debugging & Troubleshooting – Flow Analyzer Usage",
    "difficulty": "Extreme",
    "question": "What does Mule Flow Analyzer primarily help identify?",
    "options": {
      "A": "Syntax errors",
      "B": "Execution bottlenecks",
      "C": "Invalid RAML",
      "D": "Missing connectors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flow Analyzer highlights performance bottlenecks.",
      "incorrect": {
        "A": "Syntax is validated earlier.",
        "C": "RAML is separate.",
        "D": "Connectors are validated at deploy."
      }
    }
  },
  {
    "id": "EXP-MS-0912",
    "component": "Debugging & Troubleshooting – Thread Pool Saturation",
    "difficulty": "Extreme",
    "question": "What symptom most strongly indicates thread pool saturation?",
    "options": {
      "A": "High CPU",
      "B": "Requests queued with low CPU",
      "C": "Frequent GC",
      "D": "Fast failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Threads are blocked, not CPU-bound.",
      "incorrect": {
        "A": "CPU may remain low.",
        "C": "GC is memory-related.",
        "D": "Failures are delayed."
      }
    }
  },
  {
    "id": "EXP-MS-0913",
    "component": "Debugging & Troubleshooting – GC Log Analysis",
    "difficulty": "Extreme",
    "question": "What indicates GC pressure rather than memory leak?",
    "options": {
      "A": "Heap never decreases",
      "B": "Frequent short GC pauses with recovery",
      "C": "OOM errors",
      "D": "Monotonic heap growth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "GC pressure recovers memory between cycles.",
      "incorrect": {
        "A": "Indicates leak.",
        "C": "Late-stage failure.",
        "D": "Leak pattern."
      }
    }
  },

  {
    "id": "EXP-MS-0914",
    "component": "Debugging & Troubleshooting – Attribute Visibility",
    "difficulty": "Extreme",
    "question": "Why are attributes often logged separately from payload?",
    "options": {
      "A": "They are immutable",
      "B": "They change independently of payload",
      "C": "They are smaller",
      "D": "They are optional"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Attributes evolve separately from payload.",
      "incorrect": {
        "A": "Immutability is irrelevant.",
        "C": "Size is not the reason.",
        "D": "They are always present."
      }
    }
  },
  {
    "id": "EXP-MS-0915",
    "component": "Debugging & Troubleshooting – Retry Storm Diagnosis",
    "difficulty": "Extreme",
    "question": "What log pattern most clearly signals a retry storm?",
    "options": {
      "A": "Single error repeated rapidly",
      "B": "Multiple unique errors",
      "C": "Slow steady errors",
      "D": "No errors logged"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Rapid repetition indicates aggressive retry loops.",
      "incorrect": {
        "B": "Indicates systemic diversity.",
        "C": "Not storm-like.",
        "D": "Storms are noisy."
      }
    }
  },
  {
    "id": "EXP-MS-0916",
    "component": "Debugging & Troubleshooting – Log Correlation Failure",
    "difficulty": "Extreme",
    "question": "What happens when correlation IDs are regenerated mid-flow?",
    "options": {
      "A": "Improved tracing",
      "B": "Broken end-to-end traceability",
      "C": "Better performance",
      "D": "No effect"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tracing breaks across services.",
      "incorrect": {
        "A": "Tracing degrades.",
        "C": "Performance unaffected.",
        "D": "Impact is significant."
      }
    }
  },
  {
    "id": "EXP-MS-0917",
    "component": "Debugging & Troubleshooting – Non-Deterministic Bugs",
    "difficulty": "Extreme",
    "question": "What is the most effective approach to debug non-deterministic issues?",
    "options": {
      "A": "Add more logging everywhere",
      "B": "Capture inputs and execution context",
      "C": "Restart frequently",
      "D": "Disable concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Captured context enables controlled reproduction.",
      "incorrect": {
        "A": "Noise increases.",
        "C": "Restarts hide issues.",
        "D": "Not always feasible."
      }
    }
  },
  {
    "id": "EXP-MS-0918",
    "component": "Debugging & Troubleshooting – Queue Backlog Signal",
    "difficulty": "Extreme",
    "question": "What does a steadily growing queue backlog indicate?",
    "options": {
      "A": "High throughput",
      "B": "Downstream processing slower than ingestion",
      "C": "Successful retries",
      "D": "Low traffic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumption cannot keep up with production.",
      "incorrect": {
        "A": "Throughput imbalance exists.",
        "C": "Retries increase backlog.",
        "D": "Low traffic reduces backlog."
      }
    }
  },

  {
    "id": "EXP-MS-0919",
    "component": "Debugging & Troubleshooting – Batch Failure Pattern",
    "difficulty": "Extreme",
    "question": "What pattern indicates data-quality issues in batch jobs?",
    "options": {
      "A": "Random failures",
      "B": "Same record positions failing repeatedly",
      "C": "Thread exhaustion",
      "D": "OOM errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent record failures indicate bad data.",
      "incorrect": {
        "A": "Random suggests infra.",
        "C": "Resource issue.",
        "D": "Memory issue."
      }
    }
  },
  {
    "id": "EXP-MS-0920",
    "component": "Debugging & Troubleshooting – Payload Logging Risk",
    "difficulty": "Extreme",
    "question": "Why should payload logging be avoided for large binary content?",
    "options": {
      "A": "Compilation failure",
      "B": "Memory and I/O pressure",
      "C": "Schema violation",
      "D": "Transaction rollback"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Binary logging is expensive and unsafe.",
      "incorrect": {
        "A": "Compilation unaffected.",
        "C": "Schema irrelevant.",
        "D": "Transactions unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0921",
    "component": "Debugging & Troubleshooting – Failure Domain Isolation",
    "difficulty": "Extreme",
    "question": "What design choice simplifies troubleshooting blast radius?",
    "options": {
      "A": "Large monolithic flows",
      "B": "Clear domain isolation per flow",
      "C": "Dynamic routing everywhere",
      "D": "Single global error handler"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation limits failure scope.",
      "incorrect": {
        "A": "Monoliths obscure cause.",
        "C": "Dynamics reduce predictability.",
        "D": "Too coarse-grained."
      }
    }
  },
  {
    "id": "EXP-MS-0922",
    "component": "Debugging & Troubleshooting – Timeout Triangulation",
    "difficulty": "Extreme",
    "question": "How should timeout issues be diagnosed?",
    "options": {
      "A": "Increase timeout blindly",
      "B": "Measure latency at each integration hop",
      "C": "Restart the app",
      "D": "Disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Latency must be measured per hop.",
      "incorrect": {
        "A": "Masks root cause.",
        "C": "Temporary relief.",
        "D": "Retries are orthogonal."
      }
    }
  },
  {
    "id": "EXP-MS-0923",
    "component": "Debugging & Troubleshooting – Configuration Drift Detection",
    "difficulty": "Extreme",
    "question": "What is the most reliable way to detect config drift?",
    "options": {
      "A": "Manual comparison",
      "B": "Config-as-code with version control",
      "C": "Runtime logs",
      "D": "Heap dumps"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Versioned configs expose drift.",
      "incorrect": {
        "A": "Error-prone.",
        "C": "Reactive.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0924",
    "component": "Debugging & Troubleshooting – Canary Debugging",
    "difficulty": "Extreme",
    "question": "Why are canary deployments useful for debugging?",
    "options": {
      "A": "They reduce deployment time",
      "B": "They limit impact while validating fixes",
      "C": "They eliminate monitoring",
      "D": "They avoid rollbacks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Canaries constrain blast radius.",
      "incorrect": {
        "A": "Deployment time unchanged.",
        "C": "Monitoring still required.",
        "D": "Rollbacks may still be needed."
      }
    }
  },

  {
    "id": "EXP-MS-0925",
    "component": "Debugging & Troubleshooting – Debug vs Fix Order",
    "difficulty": "Extreme",
    "question": "What is the correct order during incident response?",
    "options": {
      "A": "Fix then understand",
      "B": "Stabilize then analyze",
      "C": "Refactor immediately",
      "D": "Add features"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stability comes before root cause analysis.",
      "incorrect": {
        "A": "Risky.",
        "C": "Dangerous.",
        "D": "Irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0926",
    "component": "Debugging & Troubleshooting – Error Budget Signal",
    "difficulty": "Extreme",
    "question": "What does rapid error budget consumption indicate?",
    "options": {
      "A": "Normal operations",
      "B": "Systemic instability",
      "C": "High throughput",
      "D": "Successful retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Budget burn signals instability.",
      "incorrect": {
        "A": "Normal ops are stable.",
        "C": "Throughput irrelevant.",
        "D": "Retries still consume budget."
      }
    }
  },
  {
    "id": "EXP-MS-0927",
    "component": "Debugging & Troubleshooting – Observability Debt",
    "difficulty": "Extreme",
    "question": "What is observability debt?",
    "options": {
      "A": "Excess logging",
      "B": "Missing signals that delay diagnosis",
      "C": "Too many dashboards",
      "D": "High memory usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Missing signals slow incident response.",
      "incorrect": {
        "A": "Opposite issue.",
        "C": "Dashboards alone are not debt.",
        "D": "Unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0928",
    "component": "Debugging & Troubleshooting – Root Cause Confirmation",
    "difficulty": "Extreme",
    "question": "When can a root cause be considered confirmed?",
    "options": {
      "A": "When logs look better",
      "B": "When the issue is reproducible and eliminated",
      "C": "When alerts stop",
      "D": "After restart"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reproduction and elimination confirm causality.",
      "incorrect": {
        "A": "Subjective.",
        "C": "Alerts may lag.",
        "D": "Restarts mask issues."
      }
    }
  },
  {
    "id": "EXP-MS-0929",
    "component": "Debugging & Troubleshooting – Debugging Maturity",
    "difficulty": "Extreme",
    "question": "What best signals mature debugging capability?",
    "options": {
      "A": "Fast fixes",
      "B": "Low MTTR with minimal regressions",
      "C": "High logging volume",
      "D": "Frequent restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Low MTTR with stability indicates maturity.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Logs must be actionable.",
        "D": "Restarts hide problems."
      }
    }
  },
  {
    "id": "EXP-MS-0930",
    "component": "Debugging & Troubleshooting – Section Closure",
    "difficulty": "Extreme",
    "question": "What is the defining goal of expert Mule troubleshooting?",
    "options": {
      "A": "Zero incidents",
      "B": "Predictable diagnosis and recovery",
      "C": "Maximum logging",
      "D": "Avoiding failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expertise delivers predictable recovery.",
      "incorrect": {
        "A": "Unrealistic.",
        "C": "Logging is a tool, not goal.",
        "D": "Failures are inevitable."
      }
    }
  },
  {
    "id": "EXP-MS-0931",
    "component": "Deploying & Managing APIs – CloudHub Deployment Model",
    "difficulty": "Extreme",
    "question": "When deploying an application to CloudHub with multiple workers, how is inbound traffic handled?",
    "options": {
      "A": "Pinned to first worker",
      "B": "Round-robin load balanced",
      "C": "Broadcast to all workers",
      "D": "Queued centrally"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CloudHub load-balances traffic across workers.",
      "incorrect": {
        "A": "No pinning occurs.",
        "C": "Traffic is not broadcast.",
        "D": "No central request queue."
      }
    }
  },
  {
    "id": "EXP-MS-0932",
    "component": "Deploying & Managing APIs – Worker Isolation",
    "difficulty": "Extreme",
    "question": "What is isolated between CloudHub workers?",
    "options": {
      "A": "Heap memory",
      "B": "Object store",
      "C": "VPC",
      "D": "Anypoint MQ"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Each worker has its own JVM and heap.",
      "incorrect": {
        "B": "Object store can be shared.",
        "C": "VPC is shared.",
        "D": "MQ is external."
      }
    }
  },
  {
    "id": "EXP-MS-0933",
    "component": "Deploying & Managing APIs – Zero-Downtime Deployment",
    "difficulty": "Extreme",
    "question": "How does CloudHub support zero-downtime deployments?",
    "options": {
      "A": "Restarting all workers together",
      "B": "Rolling worker replacement",
      "C": "Pausing traffic",
      "D": "Snapshot restore"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Workers are replaced gradually to maintain availability.",
      "incorrect": {
        "A": "Causes downtime.",
        "C": "Traffic is not paused.",
        "D": "Snapshots are unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0934",
    "component": "Deploying & Managing APIs – Properties Resolution",
    "difficulty": "Extreme",
    "question": "Which property source has highest precedence at runtime?",
    "options": {
      "A": "mule-app.properties",
      "B": "Secure properties file",
      "C": "Runtime Manager properties",
      "D": "Global configuration defaults"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Runtime Manager overrides all packaged properties.",
      "incorrect": {
        "A": "Lower precedence.",
        "B": "Overridden by runtime.",
        "D": "Lowest precedence."
      }
    }
  },
  {
    "id": "EXP-MS-0935",
    "component": "Deploying & Managing APIs – Secure Property Decryption",
    "difficulty": "Extreme",
    "question": "When are secure properties decrypted in Mule?",
    "options": {
      "A": "At build time",
      "B": "At application startup",
      "C": "On first access",
      "D": "At deployment upload"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure properties are decrypted during startup.",
      "incorrect": {
        "A": "Build does not decrypt.",
        "C": "Decryption is eager.",
        "D": "Upload does not decrypt."
      }
    }
  },

  {
    "id": "EXP-MS-0936",
    "component": "Deploying & Managing APIs – Auto-Discovery Binding",
    "difficulty": "Extreme",
    "question": "What links a deployed API implementation to API Manager?",
    "options": {
      "A": "RAML name",
      "B": "API instance ID",
      "C": "HTTP port",
      "D": "Application name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Auto-discovery uses the API instance ID.",
      "incorrect": {
        "A": "Name is not binding.",
        "C": "Port is irrelevant.",
        "D": "App name is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0937",
    "component": "Deploying & Managing APIs – Policy Enforcement Order",
    "difficulty": "Extreme",
    "question": "In which order are API policies enforced?",
    "options": {
      "A": "Alphabetical",
      "B": "Order configured in API Manager",
      "C": "Random",
      "D": "Deployment-time order"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policies execute in configured order.",
      "incorrect": {
        "A": "Alphabetical is irrelevant.",
        "C": "Order is deterministic.",
        "D": "Deployment order is ignored."
      }
    }
  },
  {
    "id": "EXP-MS-0938",
    "component": "Deploying & Managing APIs – Client ID Enforcement",
    "difficulty": "Extreme",
    "question": "Where is Client ID enforcement executed?",
    "options": {
      "A": "Inside Mule flow",
      "B": "At API Gateway layer",
      "C": "In APIkit router",
      "D": "In DataWeave"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client ID enforcement is a gateway policy.",
      "incorrect": {
        "A": "Flow logic is bypassed.",
        "C": "APIkit does not enforce security.",
        "D": "DW is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0939",
    "component": "Deploying & Managing APIs – Policy Failure Behavior",
    "difficulty": "Extreme",
    "question": "What happens when a policy rejects a request?",
    "options": {
      "A": "Flow continues",
      "B": "Request never reaches the API implementation",
      "C": "Error handler executes",
      "D": "Payload is transformed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rejected requests are blocked at the gateway.",
      "incorrect": {
        "A": "Flow is not invoked.",
        "C": "Implementation handlers do not run.",
        "D": "No transformation occurs."
      }
    }
  },
  {
    "id": "EXP-MS-0940",
    "component": "Deploying & Managing APIs – API Versioning Strategy",
    "difficulty": "Extreme",
    "question": "What is the safest API versioning strategy?",
    "options": {
      "A": "Header-based only",
      "B": "URL-based major versioning",
      "C": "Query param versioning",
      "D": "No versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "URL versioning avoids ambiguity and breaking changes.",
      "incorrect": {
        "A": "Headers are less visible.",
        "C": "Query params are brittle.",
        "D": "Unversioned APIs break consumers."
      }
    }
  },

  {
    "id": "EXP-MS-0941",
    "component": "Deploying & Managing APIs – API Proxy Purpose",
    "difficulty": "Extreme",
    "question": "Why use a separate API proxy instead of auto-discovery?",
    "options": {
      "A": "Better performance",
      "B": "Decouple policy management from implementation",
      "C": "Simpler deployment",
      "D": "Mandatory for CloudHub"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proxies isolate governance from implementation.",
      "incorrect": {
        "A": "Performance difference is minimal.",
        "C": "Adds complexity.",
        "D": "Not mandatory."
      }
    }
  },
  {
    "id": "EXP-MS-0942",
    "component": "Deploying & Managing APIs – Proxy Failure Impact",
    "difficulty": "Extreme",
    "question": "If an API proxy is down, what happens?",
    "options": {
      "A": "Requests bypass proxy",
      "B": "Implementation is unreachable",
      "C": "Policies are skipped",
      "D": "Requests are queued"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proxy is the entry point for traffic.",
      "incorrect": {
        "A": "Bypass is not allowed.",
        "C": "Policies cannot be skipped.",
        "D": "No automatic queuing."
      }
    }
  },
  {
    "id": "EXP-MS-0943",
    "component": "Deploying & Managing APIs – SLA Tier Enforcement",
    "difficulty": "Extreme",
    "question": "Where are SLA tiers enforced?",
    "options": {
      "A": "Inside Mule flow",
      "B": "API Manager policy layer",
      "C": "Runtime Manager",
      "D": "APIkit router"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLA enforcement is a policy concern.",
      "incorrect": {
        "A": "Flow is unaware of SLA.",
        "C": "Runtime Manager deploys apps.",
        "D": "APIkit routes only."
      }
    }
  },
  {
    "id": "EXP-MS-0944",
    "component": "Deploying & Managing APIs – Rate Limiting Accuracy",
    "difficulty": "Extreme",
    "question": "What affects accuracy of rate limiting in multi-worker deployments?",
    "options": {
      "A": "Worker heap size",
      "B": "Shared policy state backend",
      "C": "HTTP listener port",
      "D": "Thread pool size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limits rely on shared counters.",
      "incorrect": {
        "A": "Heap size is irrelevant.",
        "C": "Port does not affect limits.",
        "D": "Threads do not coordinate limits."
      }
    }
  },
  {
    "id": "EXP-MS-0945",
    "component": "Deploying & Managing APIs – Analytics Latency",
    "difficulty": "Extreme",
    "question": "Why should API analytics not be used for real-time decisions?",
    "options": {
      "A": "They are inaccurate",
      "B": "They are eventually consistent",
      "C": "They reduce throughput",
      "D": "They require RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Analytics data is not real-time.",
      "incorrect": {
        "A": "Accuracy is acceptable.",
        "C": "Throughput unaffected.",
        "D": "RAML is unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0946",
    "component": "Deploying & Managing APIs – Blue/Green Strategy",
    "difficulty": "Extreme",
    "question": "What is the main advantage of blue/green deployments?",
    "options": {
      "A": "Faster builds",
      "B": "Instant rollback capability",
      "C": "Lower cost",
      "D": "Simpler logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traffic can switch back immediately.",
      "incorrect": {
        "A": "Build speed unchanged.",
        "C": "Cost may increase.",
        "D": "Logging unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0947",
    "component": "Deploying & Managing APIs – Environment Promotion",
    "difficulty": "Extreme",
    "question": "What should be promoted across environments?",
    "options": {
      "A": "Runtime properties",
      "B": "The same application artifact",
      "C": "Worker sizes",
      "D": "Client credentials"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Artifacts must be immutable across environments.",
      "incorrect": {
        "A": "Properties differ per env.",
        "C": "Sizing differs.",
        "D": "Credentials are env-specific."
      }
    }
  },
  {
    "id": "EXP-MS-0948",
    "component": "Deploying & Managing APIs – Rollback Failure",
    "difficulty": "Extreme",
    "question": "Why might a rollback fail?",
    "options": {
      "A": "Old artifact missing",
      "B": "Backward-incompatible data changes",
      "C": "Policy mismatch",
      "D": "Worker restart"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Data migrations may not be reversible.",
      "incorrect": {
        "A": "Artifacts are usually stored.",
        "C": "Policies are versioned.",
        "D": "Restarts are safe."
      }
    }
  },
  {
    "id": "EXP-MS-0949",
    "component": "Deploying & Managing APIs – Deployment Verification",
    "difficulty": "Extreme",
    "question": "What is the best way to verify a deployment?",
    "options": {
      "A": "Application starts",
      "B": "Synthetic health checks",
      "C": "No errors in logs",
      "D": "Successful build"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Health checks validate runtime behavior.",
      "incorrect": {
        "A": "Startup does not guarantee correctness.",
        "C": "Errors may be latent.",
        "D": "Build success is insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0950",
    "component": "Deploying & Managing APIs – Horizontal Scaling Limit",
    "difficulty": "Extreme",
    "question": "What ultimately limits horizontal scaling effectiveness?",
    "options": {
      "A": "Worker count",
      "B": "Downstream system capacity",
      "C": "API policies",
      "D": "RAML size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Downstream systems often become bottlenecks.",
      "incorrect": {
        "A": "Workers can be added.",
        "C": "Policies add minor overhead.",
        "D": "RAML size is irrelevant."
      }
    }
  },

  {
    "id": "EXP-MS-0951",
    "component": "Deploying & Managing APIs – CloudHub Restart Semantics",
    "difficulty": "Extreme",
    "question": "What happens during a CloudHub worker restart?",
    "options": {
      "A": "In-flight requests are preserved",
      "B": "In-flight requests may be lost",
      "C": "Requests are queued",
      "D": "Traffic is paused"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restarts are not graceful by default.",
      "incorrect": {
        "A": "No guarantee of preservation.",
        "C": "No built-in queuing.",
        "D": "Traffic continues to other workers."
      }
    }
  },
  {
    "id": "EXP-MS-0952",
    "component": "Deploying & Managing APIs – Object Store Persistence",
    "difficulty": "Extreme",
    "question": "Which Object Store scope persists across restarts?",
    "options": {
      "A": "In-memory",
      "B": "Persistent object store",
      "C": "Flow variables",
      "D": "Session variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Persistent stores survive restarts.",
      "incorrect": {
        "A": "Memory is lost.",
        "C": "Vars are ephemeral.",
        "D": "Sessions are not persisted."
      }
    }
  },
  {
    "id": "EXP-MS-0953",
    "component": "Deploying & Managing APIs – Runtime Upgrade Risk",
    "difficulty": "Extreme",
    "question": "What is the main risk of upgrading Mule runtime?",
    "options": {
      "A": "Compilation failure",
      "B": "Behavioral changes in connectors",
      "C": "RAML incompatibility",
      "D": "Policy removal"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connector behavior may subtly change.",
      "incorrect": {
        "A": "Code usually compiles.",
        "C": "RAML is runtime-agnostic.",
        "D": "Policies remain."
      }
    }
  },
  {
    "id": "EXP-MS-0954",
    "component": "Deploying & Managing APIs – Canary Traffic Split",
    "difficulty": "Extreme",
    "question": "How is canary traffic typically routed?",
    "options": {
      "A": "By random worker selection",
      "B": "By load balancer rules",
      "C": "By APIkit router",
      "D": "By DataWeave conditions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traffic splitting is done at the load balancer.",
      "incorrect": {
        "A": "Random selection is uncontrolled.",
        "C": "APIkit is internal.",
        "D": "DW is not used."
      }
    }
  },
  {
    "id": "EXP-MS-0955",
    "component": "Deploying & Managing APIs – API Deprecation",
    "difficulty": "Extreme",
    "question": "What is the safest way to deprecate an API?",
    "options": {
      "A": "Immediate shutdown",
      "B": "Communicate and sunset gradually",
      "C": "Block old clients",
      "D": "Remove RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Gradual sunset avoids breaking consumers.",
      "incorrect": {
        "A": "Breaks clients.",
        "C": "Abrupt failures.",
        "D": "RAML removal is insufficient."
      }
    }
  },

  {
    "id": "EXP-MS-0956",
    "component": "Deploying & Managing APIs – Access Log Value",
    "difficulty": "Extreme",
    "question": "What is the primary value of access logs?",
    "options": {
      "A": "Debugging payloads",
      "B": "Auditing and traffic analysis",
      "C": "Improving performance",
      "D": "Enforcing policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Access logs provide request-level visibility.",
      "incorrect": {
        "A": "Payload logging is separate.",
        "C": "Logs do not improve performance.",
        "D": "Policies enforce rules."
      }
    }
  },
  {
    "id": "EXP-MS-0957",
    "component": "Deploying & Managing APIs – API Governance Failure",
    "difficulty": "Extreme",
    "question": "What indicates weak API governance?",
    "options": {
      "A": "Consistent policies",
      "B": "Inconsistent error contracts",
      "C": "Versioned APIs",
      "D": "Documented standards"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inconsistency breaks consumer expectations.",
      "incorrect": {
        "A": "Consistency is good governance.",
        "C": "Versioning is good practice.",
        "D": "Documentation supports governance."
      }
    }
  },
  {
    "id": "EXP-MS-0958",
    "component": "Deploying & Managing APIs – Deployment Automation",
    "difficulty": "Extreme",
    "question": "Why is CI/CD critical for Mule deployments?",
    "options": {
      "A": "Faster coding",
      "B": "Repeatable and auditable deployments",
      "C": "Larger workers",
      "D": "Reduced RAML size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistency and auditability.",
      "incorrect": {
        "A": "Coding speed is unrelated.",
        "C": "Worker size is orthogonal.",
        "D": "RAML size irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0959",
    "component": "Deploying & Managing APIs – Secrets Rotation",
    "difficulty": "Extreme",
    "question": "What is the safest way to rotate secrets?",
    "options": {
      "A": "Hard-code new values",
      "B": "Update Runtime Manager properties",
      "C": "Redeploy with code change",
      "D": "Restart workers manually"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runtime Manager supports dynamic secret updates.",
      "incorrect": {
        "A": "Hard-coding is insecure.",
        "C": "Code change is unnecessary.",
        "D": "Manual restarts are risky."
      }
    }
  },
  {
    "id": "EXP-MS-0960",
    "component": "Deploying & Managing APIs – Operational Readiness",
    "difficulty": "Extreme",
    "question": "What best indicates an API is production-ready?",
    "options": {
      "A": "Successful deployment",
      "B": "Defined SLOs, alerts, and runbooks",
      "C": "No errors in dev",
      "D": "RAML published"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operational readiness requires observability and procedures.",
      "incorrect": {
        "A": "Deployment alone is insufficient.",
        "C": "Dev stability is not enough.",
        "D": "RAML is design-time."
      }
    }
  },

  {
    "id": "EXP-MS-0961",
    "component": "Deploying & Managing APIs – Scaling vs Cost Tradeoff",
    "difficulty": "Extreme",
    "question": "What is the primary tradeoff of aggressive auto-scaling?",
    "options": {
      "A": "Lower latency",
      "B": "Higher infrastructure cost",
      "C": "Simpler debugging",
      "D": "Reduced governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "More workers increase cost.",
      "incorrect": {
        "A": "Latency may improve.",
        "C": "Debugging may get harder.",
        "D": "Governance unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0962",
    "component": "Deploying & Managing APIs – API Ownership",
    "difficulty": "Extreme",
    "question": "Why must APIs have clear ownership?",
    "options": {
      "A": "For certification",
      "B": "For accountability and lifecycle management",
      "C": "For faster coding",
      "D": "For RAML reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ownership ensures accountability.",
      "incorrect": {
        "A": "Certification is irrelevant.",
        "C": "Coding speed unaffected.",
        "D": "Reuse is secondary."
      }
    }
  },
  {
    "id": "EXP-MS-0963",
    "component": "Deploying & Managing APIs – Breaking Change Detection",
    "difficulty": "Extreme",
    "question": "What is the best way to detect breaking API changes?",
    "options": {
      "A": "Manual review",
      "B": "Contract testing",
      "C": "Runtime logs",
      "D": "Analytics dashboards"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract tests validate compatibility.",
      "incorrect": {
        "A": "Manual review is error-prone.",
        "C": "Logs are reactive.",
        "D": "Dashboards are aggregated."
      }
    }
  },
  {
    "id": "EXP-MS-0964",
    "component": "Deploying & Managing APIs – Governance Completion",
    "difficulty": "Extreme",
    "question": "What defines mature API governance in Mule?",
    "options": {
      "A": "Many policies",
      "B": "Consistent standards, automation, and monitoring",
      "C": "Maximum security",
      "D": "Single proxy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance combines standards, automation, and observability.",
      "incorrect": {
        "A": "Quantity is irrelevant.",
        "C": "Security alone is insufficient.",
        "D": "Single proxy is not governance."
      }
    }
  },
  {
    "id": "EXP-MS-0965",
    "component": "Deploying & Managing APIs – Section Progress Marker",
    "difficulty": "Extreme",
    "question": "What is the defining goal of API deployment and management?",
    "options": {
      "A": "Fast releases",
      "B": "Reliable, governable, and observable APIs",
      "C": "Minimal configuration",
      "D": "Zero downtime always"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability and governance define success.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Configuration must be explicit.",
        "D": "Zero downtime is aspirational."
      }
    }
  },
  {
    "id": "EXP-MS-0966",
    "component": "Deploying & Managing APIs – Runtime Fabric Placement",
    "difficulty": "Extreme",
    "question": "What determines pod placement for Mule apps on Runtime Fabric?",
    "options": {
      "A": "RAML definition",
      "B": "Kubernetes scheduler and resource requests",
      "C": "API Manager policy order",
      "D": "Application name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runtime Fabric relies on Kubernetes scheduling decisions.",
      "incorrect": {
        "A": "RAML is design-time only.",
        "C": "Policies do not affect placement.",
        "D": "Names are irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0967",
    "component": "Deploying & Managing APIs – RTF Scaling Constraint",
    "difficulty": "Extreme",
    "question": "What most commonly limits scaling on Runtime Fabric?",
    "options": {
      "A": "API policies",
      "B": "Cluster resource quotas",
      "C": "RAML size",
      "D": "APIkit routers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CPU and memory quotas bound scaling.",
      "incorrect": {
        "A": "Policies add minimal overhead.",
        "C": "RAML size is irrelevant.",
        "D": "Routing logic does not limit scaling."
      }
    }
  },
  {
    "id": "EXP-MS-0968",
    "component": "Deploying & Managing APIs – Log Persistence",
    "difficulty": "Extreme",
    "question": "Why must logs be externalized in CloudHub and RTF?",
    "options": {
      "A": "To improve performance",
      "B": "Workers and pods are ephemeral",
      "C": "To reduce heap usage",
      "D": "To satisfy RAML contracts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ephemeral infrastructure loses local logs on restart.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Heap usage is unrelated.",
        "D": "RAML is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0969",
    "component": "Deploying & Managing APIs – Canary Abort Signal",
    "difficulty": "Extreme",
    "question": "What metric should immediately abort a canary deployment?",
    "options": {
      "A": "Slight latency increase",
      "B": "Spike in error rate",
      "C": "Higher throughput",
      "D": "Increased logging volume"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error-rate spikes indicate regressions.",
      "incorrect": {
        "A": "Latency may fluctuate.",
        "C": "Throughput increase is positive.",
        "D": "Logging volume is not critical."
      }
    }
  },
  {
    "id": "EXP-MS-0970",
    "component": "Deploying & Managing APIs – Policy Change Risk",
    "difficulty": "Extreme",
    "question": "Why should API policy changes be treated like code changes?",
    "options": {
      "A": "They require redeployment",
      "B": "They can change runtime behavior instantly",
      "C": "They affect RAML",
      "D": "They increase worker size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policy changes apply immediately and can break clients.",
      "incorrect": {
        "A": "Policies do not require redeploy.",
        "C": "RAML is unchanged.",
        "D": "Worker size unaffected."
      }
    }
  },

  {
    "id": "EXP-MS-0971",
    "component": "Deploying & Managing APIs – Multi-Region Strategy",
    "difficulty": "Extreme",
    "question": "What is the primary challenge of multi-region API deployments?",
    "options": {
      "A": "RAML synchronization",
      "B": "Data consistency and latency",
      "C": "Policy attachment",
      "D": "APIkit routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cross-region data consistency is complex.",
      "incorrect": {
        "A": "RAML is static.",
        "C": "Policies can be replicated.",
        "D": "Routing is local."
      }
    }
  },
  {
    "id": "EXP-MS-0972",
    "component": "Deploying & Managing APIs – Disaster Recovery Test",
    "difficulty": "Extreme",
    "question": "How should disaster recovery plans be validated?",
    "options": {
      "A": "Documentation review",
      "B": "Regular failover testing",
      "C": "Increasing worker count",
      "D": "Adding retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only testing validates DR effectiveness.",
      "incorrect": {
        "A": "Docs alone are insufficient.",
        "C": "Scaling is unrelated.",
        "D": "Retries do not test DR."
      }
    }
  },
  {
    "id": "EXP-MS-0973",
    "component": "Deploying & Managing APIs – API Contract Drift",
    "difficulty": "Extreme",
    "question": "What causes API contract drift most often?",
    "options": {
      "A": "Policy updates",
      "B": "Implementation changes without spec updates",
      "C": "Client misuse",
      "D": "Runtime upgrades"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Spec and implementation must evolve together.",
      "incorrect": {
        "A": "Policies do not change contracts.",
        "C": "Clients expose but do not cause drift.",
        "D": "Runtime upgrades are orthogonal."
      }
    }
  },
  {
    "id": "EXP-MS-0974",
    "component": "Deploying & Managing APIs – Backward Compatibility Check",
    "difficulty": "Extreme",
    "question": "Which change is backward compatible?",
    "options": {
      "A": "Removing a required field",
      "B": "Adding an optional response field",
      "C": "Changing HTTP status codes",
      "D": "Renaming endpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Optional additions do not break consumers.",
      "incorrect": {
        "A": "Breaks clients.",
        "C": "May break expectations.",
        "D": "Breaks routing."
      }
    }
  },
  {
    "id": "EXP-MS-0975",
    "component": "Deploying & Managing APIs – SLA Exhaustion",
    "difficulty": "Extreme",
    "question": "What happens when an SLA limit is exhausted?",
    "options": {
      "A": "Requests queue",
      "B": "Requests are rejected by the gateway",
      "C": "Flow retries",
      "D": "Application restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Gateway enforces SLA limits.",
      "incorrect": {
        "A": "No queuing.",
        "C": "Retries are not automatic.",
        "D": "No restart occurs."
      }
    }
  },

  {
    "id": "EXP-MS-0976",
    "component": "Deploying & Managing APIs – Cost Visibility",
    "difficulty": "Extreme",
    "question": "What improves cost attribution for APIs?",
    "options": {
      "A": "More workers",
      "B": "Environment and application tagging",
      "C": "Larger heaps",
      "D": "Verbose logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tagging enables cost breakdown.",
      "incorrect": {
        "A": "Increases cost.",
        "C": "Unrelated.",
        "D": "Logging does not affect cost attribution."
      }
    }
  },
  {
    "id": "EXP-MS-0977",
    "component": "Deploying & Managing APIs – Runtime Drift Detection",
    "difficulty": "Extreme",
    "question": "How can runtime drift between replicas be detected?",
    "options": {
      "A": "Manual inspection",
      "B": "Configuration and artifact checksums",
      "C": "API analytics",
      "D": "RAML comparison"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Checksums verify identical runtime state.",
      "incorrect": {
        "A": "Not scalable.",
        "C": "Analytics is behavioral.",
        "D": "RAML is design-time."
      }
    }
  },
  {
    "id": "EXP-MS-0978",
    "component": "Deploying & Managing APIs – Immutable Infrastructure",
    "difficulty": "Extreme",
    "question": "Why is immutable infrastructure recommended?",
    "options": {
      "A": "Faster debugging",
      "B": "Eliminates configuration drift",
      "C": "Lower memory usage",
      "D": "Simpler RAML"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutable artifacts prevent drift.",
      "incorrect": {
        "A": "Debugging may be harder.",
        "C": "Memory usage unchanged.",
        "D": "RAML unaffected."
      }
    }
  },
  {
    "id": "EXP-MS-0979",
    "component": "Deploying & Managing APIs – Change Failure Rate",
    "difficulty": "Extreme",
    "question": "What does a high change failure rate indicate?",
    "options": {
      "A": "Too much traffic",
      "B": "Weak deployment and testing practices",
      "C": "Strong governance",
      "D": "Over-scaling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Frequent failures point to process gaps.",
      "incorrect": {
        "A": "Traffic is not the root cause.",
        "C": "Governance reduces failures.",
        "D": "Scaling is unrelated."
      }
    }
  },
  {
    "id": "EXP-MS-0980",
    "component": "Deploying & Managing APIs – Operational Maturity",
    "difficulty": "Extreme",
    "question": "Which metric best reflects operational maturity?",
    "options": {
      "A": "Deployment frequency",
      "B": "Mean time to recovery (MTTR)",
      "C": "Lines of code",
      "D": "Worker size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Low MTTR reflects resilient operations.",
      "incorrect": {
        "A": "Frequency alone is insufficient.",
        "C": "Code size irrelevant.",
        "D": "Worker size unrelated."
      }
    }
  },

  {
    "id": "EXP-MS-0981",
    "component": "Deploying & Managing APIs – API Ownership Handoff",
    "difficulty": "Extreme",
    "question": "What must accompany API ownership transfer?",
    "options": {
      "A": "Source code only",
      "B": "Runbooks, alerts, and contracts",
      "C": "New RAML",
      "D": "Worker resize"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operational knowledge must transfer with ownership.",
      "incorrect": {
        "A": "Code alone is insufficient.",
        "C": "RAML already exists.",
        "D": "Resizing is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0982",
    "component": "Deploying & Managing APIs – API Sunsetting Signal",
    "difficulty": "Extreme",
    "question": "What metric best signals readiness to sunset an API?",
    "options": {
      "A": "Low error rate",
      "B": "Sustained zero or near-zero consumer traffic",
      "C": "Old RAML version",
      "D": "Low latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "No consumers indicates safe deprecation.",
      "incorrect": {
        "A": "Error rate is irrelevant.",
        "C": "Age alone is insufficient.",
        "D": "Latency does not indicate usage."
      }
    }
  },
  {
    "id": "EXP-MS-0983",
    "component": "Deploying & Managing APIs – Audit Readiness",
    "difficulty": "Extreme",
    "question": "What enables effective API audits?",
    "options": {
      "A": "Verbose logs",
      "B": "Versioned artifacts and deployment history",
      "C": "Large worker sizes",
      "D": "Frequent restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audits require traceability and history.",
      "incorrect": {
        "A": "Logs alone are insufficient.",
        "C": "Worker size irrelevant.",
        "D": "Restarts hide evidence."
      }
    }
  },
  {
    "id": "EXP-MS-0984",
    "component": "Deploying & Managing APIs – Compliance Drift",
    "difficulty": "Extreme",
    "question": "What causes compliance drift most often?",
    "options": {
      "A": "Stable standards",
      "B": "Manual changes outside CI/CD",
      "C": "Automated pipelines",
      "D": "Contract testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Out-of-band changes bypass controls.",
      "incorrect": {
        "A": "Standards prevent drift.",
        "C": "Automation enforces consistency.",
        "D": "Testing detects drift."
      }
    }
  },
  {
    "id": "EXP-MS-0985",
    "component": "Deploying & Managing APIs – Section Completion Marker",
    "difficulty": "Extreme",
    "question": "What defines expert-level API deployment and management?",
    "options": {
      "A": "High availability only",
      "B": "Predictable, governable, and resilient operations",
      "C": "Fastest deployments",
      "D": "Maximum scaling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expertise balances reliability, governance, and resilience.",
      "incorrect": {
        "A": "Availability alone is insufficient.",
        "C": "Speed without safety is risky.",
        "D": "Scaling without control is dangerous."
      }
    }
  },

  {
    "id": "EXP-MS-0986",
    "component": "Deploying & Managing APIs – API Lifecycle Closure",
    "difficulty": "Extreme",
    "question": "What marks the end of an API lifecycle?",
    "options": {
      "A": "No new features",
      "B": "Formal deprecation and consumer offboarding",
      "C": "RAML deletion",
      "D": "Policy removal"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lifecycle ends only after consumers are migrated.",
      "incorrect": {
        "A": "Features may stop earlier.",
        "C": "Docs alone do not end lifecycle.",
        "D": "Policies are irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0987",
    "component": "Deploying & Managing APIs – Postmortem Trigger",
    "difficulty": "Extreme",
    "question": "When should deployment postmortems be conducted?",
    "options": {
      "A": "After every deployment",
      "B": "After any customer-impacting incident",
      "C": "Only yearly",
      "D": "Only for outages"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Customer impact warrants analysis.",
      "incorrect": {
        "A": "Too heavy-weight.",
        "C": "Too infrequent.",
        "D": "Near-misses also matter."
      }
    }
  },
  {
    "id": "EXP-MS-0988",
    "component": "Deploying & Managing APIs – Final Governance Signal",
    "difficulty": "Extreme",
    "question": "What is the strongest signal of mature API operations?",
    "options": {
      "A": "No incidents",
      "B": "Fast recovery with minimal customer impact",
      "C": "Maximum logging",
      "D": "Strict policies everywhere"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience is measured by recovery, not perfection.",
      "incorrect": {
        "A": "Incidents are inevitable.",
        "C": "Logs alone do not ensure maturity.",
        "D": "Policies must be balanced."
      }
    }
  },
  {
    "id": "EXP-MS-0989",
    "component": "Deploying & Managing APIs – End-to-End Ownership",
    "difficulty": "Extreme",
    "question": "Why is end-to-end ownership critical for APIs?",
    "options": {
      "A": "Faster coding",
      "B": "Clear accountability from design to operations",
      "C": "Simpler RAML",
      "D": "Lower cost"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ownership prevents gaps between teams.",
      "incorrect": {
        "A": "Coding speed is secondary.",
        "C": "RAML complexity unchanged.",
        "D": "Cost impact is indirect."
      }
    }
  },
  {
    "id": "EXP-MS-0990",
    "component": "Deploying & Managing APIs – Reliability Objective",
    "difficulty": "Extreme",
    "question": "What is the primary reliability objective for APIs?",
    "options": {
      "A": "Zero latency",
      "B": "Meeting defined SLOs consistently",
      "C": "Unlimited scaling",
      "D": "No retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability is defined against SLOs.",
      "incorrect": {
        "A": "Zero latency is impossible.",
        "C": "Scaling must be bounded.",
        "D": "Retries are situational."
      }
    }
  },

  {
    "id": "EXP-MS-0991",
    "component": "Deploying & Managing APIs – Final Integration Check",
    "difficulty": "Extreme",
    "question": "Before go-live, what must be validated end-to-end?",
    "options": {
      "A": "RAML syntax",
      "B": "Functional, non-functional, and failure scenarios",
      "C": "Worker size only",
      "D": "Policy count"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "All scenarios must be validated.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "Sizing is partial.",
        "D": "Policy count is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-0992",
    "component": "Deploying & Managing APIs – Release Confidence",
    "difficulty": "Extreme",
    "question": "What provides the highest release confidence?",
    "options": {
      "A": "Manual testing",
      "B": "Automated tests plus canary deployments",
      "C": "Fast rollbacks",
      "D": "Verbose logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation plus controlled exposure reduces risk.",
      "incorrect": {
        "A": "Manual testing does not scale.",
        "C": "Rollback is reactive.",
        "D": "Logging is observational."
      }
    }
  },
  {
    "id": "EXP-MS-0993",
    "component": "Deploying & Managing APIs – Ops Anti-Pattern",
    "difficulty": "Extreme",
    "question": "Which is a common API operations anti-pattern?",
    "options": {
      "A": "Versioned deployments",
      "B": "Manual hotfixes in production",
      "C": "Contract testing",
      "D": "CI/CD pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Manual hotfixes cause drift and risk.",
      "incorrect": {
        "A": "Versioning is good practice.",
        "C": "Contract testing prevents breaks.",
        "D": "Pipelines enforce discipline."
      }
    }
  },
  {
    "id": "EXP-MS-0994",
    "component": "Deploying & Managing APIs – Final Risk Indicator",
    "difficulty": "Extreme",
    "question": "What indicates unacceptable operational risk?",
    "options": {
      "A": "Occasional incidents",
      "B": "Unknown blast radius of failures",
      "C": "Defined SLOs",
      "D": "Automated deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unknown blast radius signals poor design.",
      "incorrect": {
        "A": "Incidents are normal.",
        "C": "SLOs reduce risk.",
        "D": "Automation reduces risk."
      }
    }
  },
  {
    "id": "EXP-MS-0995",
    "component": "Deploying & Managing APIs – Operational Excellence",
    "difficulty": "Extreme",
    "question": "What is the hallmark of operational excellence?",
    "options": {
      "A": "No alerts",
      "B": "Fast, predictable recovery from failures",
      "C": "Maximum scaling",
      "D": "Minimal configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Recovery speed defines excellence.",
      "incorrect": {
        "A": "Silence may hide issues.",
        "C": "Scaling is not the goal.",
        "D": "Configuration must be explicit."
      }
    }
  },

  {
    "id": "EXP-MS-0996",
    "component": "Deploying & Managing APIs – End State Definition",
    "difficulty": "Extreme",
    "question": "What is the desired end state for API platforms?",
    "options": {
      "A": "High traffic",
      "B": "Self-service, governed, and observable APIs",
      "C": "Large teams",
      "D": "Frequent releases"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platforms balance autonomy with governance.",
      "incorrect": {
        "A": "Traffic volume is incidental.",
        "C": "Team size irrelevant.",
        "D": "Release frequency alone is insufficient."
      }
    }
  },
  {
    "id": "EXP-MS-0997",
    "component": "Deploying & Managing APIs – Knowledge Continuity",
    "difficulty": "Extreme",
    "question": "What prevents loss of operational knowledge?",
    "options": {
      "A": "Individual expertise",
      "B": "Runbooks and shared documentation",
      "C": "Verbose logging",
      "D": "Large teams"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation ensures continuity.",
      "incorrect": {
        "A": "Individuals can leave.",
        "C": "Logs do not capture decisions.",
        "D": "Team size does not guarantee knowledge."
      }
    }
  },
  {
    "id": "EXP-MS-0998",
    "component": "Deploying & Managing APIs – Final Exam Marker",
    "difficulty": "Extreme",
    "question": "What distinguishes an expert MuleSoft platform engineer?",
    "options": {
      "A": "Tool mastery",
      "B": "Systemic thinking across design, runtime, and operations",
      "C": "Fast coding",
      "D": "Large deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expertise spans the full lifecycle.",
      "incorrect": {
        "A": "Tools alone are insufficient.",
        "C": "Speed without rigor is risky.",
        "D": "Scale alone does not imply expertise."
      }
    }
  },
  {
    "id": "EXP-MS-0999",
    "component": "Deploying & Managing APIs – Certification Closure",
    "difficulty": "Extreme",
    "question": "What does certification-level mastery emphasize?",
    "options": {
      "A": "Memorization",
      "B": "Correct decisions under constraints",
      "C": "Speed of answers",
      "D": "UI familiarity"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test decision-making, not recall.",
      "incorrect": {
        "A": "Memorization is insufficient.",
        "C": "Speed is secondary.",
        "D": "UI familiarity is irrelevant."
      }
    }
  },
  {
    "id": "EXP-MS-1000",
    "component": "Deploying & Managing APIs – Full Syllabus Completion",
    "difficulty": "Extreme",
    "question": "What is the ultimate goal of MuleSoft application networks?",
    "options": {
      "A": "More APIs",
      "B": "Composable, resilient business capabilities",
      "C": "Faster integrations",
      "D": "Lower code volume"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Application networks enable composable capabilities.",
      "incorrect": {
        "A": "Quantity is not the goal.",
        "C": "Speed is a side effect.",
        "D": "Code volume is irrelevant."
      }
    }
  }
]
